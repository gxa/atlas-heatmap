var heatmapHighcharts =
webpackJsonp_name_([1],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = __webpack_require__(607);

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */,
/* 569 */,
/* 570 */,
/* 571 */,
/* 572 */,
/* 573 */,
/* 574 */,
/* 575 */,
/* 576 */,
/* 577 */,
/* 578 */,
/* 579 */,
/* 580 */,
/* 581 */,
/* 582 */,
/* 583 */,
/* 584 */,
/* 585 */,
/* 586 */,
/* 587 */,
/* 588 */,
/* 589 */,
/* 590 */,
/* 591 */,
/* 592 */,
/* 593 */,
/* 594 */,
/* 595 */,
/* 596 */,
/* 597 */,
/* 598 */,
/* 599 */,
/* 600 */,
/* 601 */,
/* 602 */,
/* 603 */,
/* 604 */,
/* 605 */,
/* 606 */,
/* 607 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(139);
	var ReactDOM = __webpack_require__(300);

	var EventEmitter = __webpack_require__(608);
	var HighchartsHeatmapContainer = __webpack_require__(609);

	/**
	 API of this widget
	------------------
	### Minimal example
	{
	  params:"geneQuery=zinc finger&species=mus musculus",
	  target:"myDomElementId"
	}

	### Note
	changes to this API will be announced to the mailing list atlas-widget@ebi.ac.uk

	### Target
	@param {string | Object} options.target - a <div> id or a DOM element, as returned by ReactDOM.findDOMNode()

	### Query settings
	@param {string}          options.params - Alternate way of sourcing data if you do not provide the sourceURL
	e.g. 'geneQuery=[{value:"BRCA1"}, {value:"REG1B"}]&species=homo sapiens',
	e.g. 'geneQuery=[{value:"PIP",category:"symbol"}]&species=homo sapiens',
	e.g. 'geneQuery=zinc finger&species=mus musculus',
	e.g. 'experiment=E-MTAB-513'

	### Optional recommended alternative query settings
	@param {string}          options.sourceURL - Where to source the data from (used by Atlas instead of options.params)
	e.g. https://www.ebi.ac.uk/gxa/json/experiments/E-PROT-1
	e.g. https://www.ebi.ac.uk/gxa/json/search/baselineResults?query={value:"zinc finger"}&species=homo sapiens
	e.g. https://www.ebi.ac.uk/gxa/widgets/heatmap/baselineAnalytics?geneQuery={value:"zinc finger"}&species=homo sapiens
	e.g. https://www.ebi.ac.uk/gxa/widgets/heatmap/referenceExperiment?experiment=E-MTAB-513
	Note: the URL is otherwise inferred from options.params.
	You could select this option and add yourself an integration test that checks what data the backend will serve you.

	### Optional connection setup
	@param {string}          options.proxyPrefix - proxy prefix for outbound links, optionally set as "http(s?)://" or to proxy URL e.g. "www.myproxy.org?url="
	@param {string}         options.atlasHost - Atlas host with protocol and port - where to source the data from, default: "https://www.ebi.ac.uk"

	### Optional options
	@param {boolean}        options.disableGoogleAnalytics - Disable Google Analytics
	@param {function}        options.fail - Callback to run if the AJAX request to the server fails. (jqXHR, textStatus)
	@param {boolean}        options.showAnatomogram - optionally hide the anatomogram

	### Advanced options
	@param {Object}          options.anatomogramDataEventEmitter - emits events to the facets tree to signal the existence of anatomogram
	@param {boolean}         options.isDifferential
	@param {boolean}         options.isMultiExperiment
	@param {boolean}        options.isWidget

	### Development only
	@param {string}          options.pathToFolderWithBundledResources - use if you're serving the /svg's from an unusual location. Development only.
	**/

	exports.render = function (options) {
	    var atlasHost = options.atlasHost === undefined ? "https://www.ebi.ac.uk" : options.atlasHost;
	    var atlasPath = "/gxa";
	    var proxyPrefix = options.proxyPrefix || "https://";

	    var atlasBaseURL = (atlasHost.indexOf("http://") === 0 || atlasHost.indexOf("https://") === 0 ? "" : proxyPrefix) + atlasHost + atlasPath;

	    var linksAtlasBaseURL = options.selfHosted ? (options.proxyPrefix || "https://") + "www.ebi.ac.uk/gxa" : atlasBaseURL;

	    //If using this renderer for a standalone widget, see uk.ac.ebi.atlas.widget.HeatmapWidgetController.java for the source URL/params required
	    var sourceURL = options.sourceURL || atlasBaseURL + "/widgets/heatmap" + (options.isMultiExperiment ? "/baselineAnalytics" : "/referenceExperiment") + "?" + options.params;

	    var anatomogramEventEmitter = new EventEmitter();
	    anatomogramEventEmitter.setMaxListeners(0);

	    ReactDOM.render(React.createElement(HighchartsHeatmapContainer, {
	        sourceURL: sourceURL,
	        atlasBaseURL: atlasBaseURL,
	        proxyPrefix: proxyPrefix,
	        linksAtlasBaseURL: linksAtlasBaseURL,
	        pathToFolderWithBundledResources: options.pathToFolderWithBundledResources || atlasBaseURL + "/resources/js-bundles/",
	        showAnatomogram: options.showAnatomogram === undefined || options.showAnatomogram,
	        isDifferential: !!options.isDifferential,
	        isMultiExperiment: !!options.isMultiExperiment,
	        isWidget: options.isWidget === undefined || options.isWidget,
	        disableGoogleAnalytics: !!options.disableGoogleAnalytics,
	        fail: options.fail,
	        anatomogramEventEmitter: anatomogramEventEmitter,
	        anatomogramDataEventEmitter: options.anatomogramDataEventEmitter
	    }), typeof options.target === "string" ? document.getElementById(options.target) : options.target);
	};

/***/ },
/* 608 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 609 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var React = __webpack_require__(139);
	var $ = __webpack_require__(18);

	var Anatomogram = __webpack_require__(610);

	var Load = __webpack_require__(675);
	var HighchartsHeatmap = __webpack_require__(685);
	__webpack_require__(817);

	var outwardLink = __webpack_require__(690);

	var ExperimentDescription = React.createClass({
	    displayName: "ExperimentDescription",

	    propTypes: {
	        url: React.PropTypes.string.isRequired,
	        description: React.PropTypes.string.isRequired,
	        species: React.PropTypes.string.isRequired
	    },

	    render: function render() {
	        return React.createElement(
	            "div",
	            { style: { width: "100%", paddingBottom: "20px" } },
	            React.createElement(
	                "div",
	                { id: "experimentDescription" },
	                React.createElement(
	                    "a",
	                    { id: "goto-experiment", className: "gxaThickLink", title: "Experiment Page", href: this.props.url },
	                    this.props.description
	                )
	            ),
	            React.createElement(
	                "div",
	                { id: "experimentOrganisms" },
	                "Organism: ",
	                React.createElement(
	                    "span",
	                    { style: { fontStyle: "italic" } },
	                    this.props.species
	                )
	            )
	        );
	    }
	});

	var Container = React.createClass({
	    displayName: "Container",
	    getDefaultProps: function getDefaultProps() {
	        return {
	            referenceToAnatomogramContainer: "anatomogramContainer"
	        };
	    },
	    render: function render() {
	        var heatmapProps = {
	            loadResult: this.props.loadResult,
	            googleAnalyticsCallback: this.props.googleAnalyticsCallback
	        }; // Overridden: ontologyIdsToHighlight, onOntologyIdIsUnderFocus

	        var anatomogramConfig = {
	            pathToFolderWithBundledResources: this.props.pathToFolderWithBundledResources,
	            anatomogramData: this.props.anatomogramData,
	            expressedTissueColour: this.props.loadResult.heatmapConfig.isExperimentPage ? "gray" : "red",
	            hoveredTissueColour: this.props.loadResult.heatmapConfig.isExperimentPage ? "red" : "purple",
	            atlasBaseURL: this.props.atlasBaseURL,
	            idsExpressedInExperiment: this._ontologyIdsForTissuesExpressedInAllRows()
	        };

	        var Wrapped = Anatomogram.wrapComponent(anatomogramConfig, HighchartsHeatmap, heatmapProps);
	        return this._showAnatomogram() ? React.createElement(Wrapped, { ref: this.props.referenceToAnatomogramContainer }) : React.createElement(HighchartsHeatmap, _extends({}, heatmapProps, { ontologyIdsToHighlight: [], onOntologyIdIsUnderFocus: function onOntologyIdIsUnderFocus() {} }));
	    },
	    _showAnatomogram: function _showAnatomogram() {
	        return this.props.showAnatomogram && this.props.anatomogramData && Object.keys(this.props.anatomogramData).length;
	    },
	    _ontologyIdsForTissuesExpressedInAllRows: function _ontologyIdsForTissuesExpressedInAllRows() {
	        //TODO be less copypastey
	        var _expressedFactors = function _expressedFactors(expressedFactorsPerRow) {
	            var o = expressedFactorsPerRow;
	            var vs = Object.keys(o).map(function (e) {
	                return o[e];
	            });
	            return [].concat.apply([], vs).filter(function (e, ix, self) {
	                return self.indexOf(e) === ix;
	            });
	        };

	        var _expressedFactorsPerRow = function _expressedFactorsPerRow(profileRows) {
	            return profileRows.reduce(function (result, row) {
	                result[row.name] = row.expressions.filter(function (expression) {
	                    return expression.value;
	                }).map(function (expression) {
	                    return expression.svgPathId;
	                });
	                return result;
	            }, {});
	        };

	        return _expressedFactors(_expressedFactorsPerRow(this.props.profiles.rows));
	    }
	});

	var ContainerLoader = React.createClass({
	    displayName: "ContainerLoader",


	    propTypes: {
	        pathToFolderWithBundledResources: React.PropTypes.string.isRequired,
	        sourceURL: React.PropTypes.string.isRequired,
	        atlasBaseURL: React.PropTypes.string.isRequired,
	        proxyPrefix: React.PropTypes.string.isRequired,
	        showAnatomogram: React.PropTypes.bool.isRequired,
	        isDifferential: React.PropTypes.bool.isRequired,
	        isMultiExperiment: React.PropTypes.bool.isRequired,
	        isWidget: React.PropTypes.bool.isRequired,
	        disableGoogleAnalytics: React.PropTypes.bool.isRequired,
	        fail: React.PropTypes.func,
	        googleAnalyticsCallback: React.PropTypes.func,
	        anatomogramDataEventEmitter: React.PropTypes.object
	    },

	    render: function render() {
	        return React.createElement(
	            "div",
	            null,
	            this._isReferenceExperiment() && this.state.experimentData ? React.createElement(ExperimentDescription, {
	                url: this.state.loadResult.heatmapConfig.moreInformationLink,
	                description: this.state.experimentData.description,
	                species: this.state.experimentData.species }) : null,
	            this.state.ajaxCompleted ? this.state.error ? React.createElement(
	                "div",
	                { ref: "gxaError" },
	                this.state.error
	            ) : React.createElement(Container, _extends({}, this.props, this.state)) : React.createElement(
	                "div",
	                null,
	                React.createElement("img", { src: this.props.atlasBaseURL + "/resources/images/loading.gif" })
	            ),
	            this.props.isWidget ? React.createElement(
	                "div",
	                null,
	                React.createElement(
	                    "p",
	                    null,
	                    React.createElement(
	                        "a",
	                        { href: outwardLink(this.props.proxyPrefix, this.state.ajaxCompleted ? this.state.loadResult.heatmapConfig.moreInformationLink : this.props.atlasBaseURL) },
	                        " See more expression data at Expression Atlas."
	                    ),
	                    React.createElement("br", null),
	                    "This expression view is provided by ",
	                    React.createElement(
	                        "a",
	                        { href: outwardLink(this.props.proxyPrefix, this.props.atlasBaseURL) },
	                        "Expression Atlas"
	                    ),
	                    ".",
	                    React.createElement("br", null),
	                    "Please direct any queries or feedback to ",
	                    React.createElement(
	                        "a",
	                        { href: "mailto:arrayexpress-atlas@ebi.ac.uk" },
	                        "arrayexpress-atlas@ebi.ac.uk"
	                    )
	                )
	            ) : null
	        );
	    },
	    componentDidUpdate: function componentDidUpdate() {
	        if (this.props.anatomogramDataEventEmitter) {
	            if (this.state.anatomogramData && Object.keys(this.state.anatomogramData).length !== 0) {
	                this.props.anatomogramDataEventEmitter.emit("existAnatomogramData", true);
	            } else {
	                this.props.anatomogramDataEventEmitter.emit("existAnatomogramData", false);
	            }
	        }
	    },
	    getInitialState: function getInitialState() {
	        return {
	            ajaxCompleted: false,
	            error: false,
	            profiles: {
	                rows: [],
	                minExpressionLevel: 0,
	                maxExpressionLevel: 0
	            },
	            geneSetProfiles: {},
	            anatomogramData: {},
	            googleAnalyticsCallback: function googleAnalyticsCallback() {},
	            loadResult: {
	                heatmapConfig: {},
	                orderings: {
	                    "Default": {
	                        columns: [],
	                        rows: []
	                    }
	                }
	            }
	        };
	    },
	    _handleAjaxFailure: function _handleAjaxFailure(jqXHR, textStatus, errorThrown) {
	        if (this.props.fail) {
	            this.props.fail(jqXHR, textStatus, errorThrown);
	        } else {
	            this.setState({
	                ajaxCompleted: true,
	                error: textStatus === "parsererror" ? "Could not parse JSON response" : errorThrown
	            });
	        }
	    },
	    _onAjaxDone: function _onAjaxDone(data, textStatus, jqXHR) {
	        if (!this.isMounted()) {
	            this._handleAjaxFailure(jqXHR, textStatus, "DOM element not mounted!");
	        } else if (data.hasOwnProperty("error")) {
	            this._handleAjaxFailure(jqXHR, textStatus, data.error);
	        } else if (!data.profiles) {
	            this._handleAjaxFailure(jqXHR, textStatus, "No table data present in the response to query.");
	        } else {
	            this.onAjaxSuccessful(data);
	        }
	    },
	    _isExperimentPage: function _isExperimentPage() {
	        return this.props.sourceURL.indexOf("/json/experiments/") > -1;
	    },
	    _isReferenceExperiment: function _isReferenceExperiment() {
	        return !this.props.isMultiExperiment && !this._isExperimentPage();
	    },
	    onAjaxSuccessful: function onAjaxSuccessful(data) {

	        var setupConfig = {
	            isExperimentPage: this._isExperimentPage(),
	            isMultiExperiment: this.props.isMultiExperiment,
	            isReferenceExperiment: this._isReferenceExperiment(),
	            isDifferential: this.props.isDifferential,
	            atlasBaseURL: this.props.atlasBaseURL,
	            proxyPrefix: this.props.proxyPrefix,
	            pathToFolderWithBundledResources: this.props.pathToFolderWithBundledResources
	        };

	        this.setState({
	            ajaxCompleted: true,
	            columnHeaders: data.columnHeaders,
	            profiles: data.profiles,
	            anatomogramData: data.anatomogram,
	            experimentData: data.experiment,
	            loadResult: Load(setupConfig, data)
	        });
	    },
	    componentDidMount: function componentDidMount() {
	        var httpRequest = {
	            url: this.props.sourceURL,
	            dataType: "json",
	            method: "GET"
	        };

	        $.ajax(httpRequest).done(this._onAjaxDone).fail(this._handleAjaxFailure);

	        if (!this.props.disableGoogleAnalytics) {
	            (function (i, s, o, g, r, a, m) {
	                i['GoogleAnalyticsObject'] = r;i[r] = i[r] || function () {
	                    (i[r].q = i[r].q || []).push(arguments);
	                }, i[r].l = 1 * new Date();a = s.createElement(o), m = s.getElementsByTagName(o)[0];a.async = 1;a.src = g;m.parentNode.insertBefore(a, m);
	            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

	            ga('create', 'UA-37676851-1', 'auto');
	            ga('send', 'pageview');
	            this.setState({ googleAnalyticsCallback: ga });
	        }
	    }
	});

	module.exports = ContainerLoader;

/***/ },
/* 610 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = __webpack_require__(611);

/***/ },
/* 611 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var React = __webpack_require__(139);
	var validate = __webpack_require__(612);
	var Anatomogram = __webpack_require__(613);
	var getSvgsForSpecies = __webpack_require__(617).GetSvgsForSpecies;
	var EventEmitter = __webpack_require__(608);
	__webpack_require__(673);

	//*------------------------------------------------------------------*

	var RequiredString = React.PropTypes.string.isRequired;

	var argumentShape = {
	    pathToFolderWithBundledResources: RequiredString,
	    anatomogramData: React.PropTypes.shape({
	        species: RequiredString,
	        allSvgPathIds: React.PropTypes.arrayOf(RequiredString) //if not provided, we use properties read in from the file
	    }).isRequired,
	    expressedTissueColour: RequiredString,
	    hoveredTissueColour: RequiredString,
	    eventEmitter: React.PropTypes.instanceOf(EventEmitter)
	};

	var _availableAnatomograms = function _availableAnatomograms(species, pathToFolderWithBundledResources, allSvgPathIds) {
	    return getSvgsForSpecies(pathToFolderWithBundledResources, species).filter(function (e) {
	        return !allSvgPathIds || allSvgPathIds.some(function (id) {
	            return e.ids.indexOf(id) > -1;
	        });
	    });
	};

	var callEmitterWhenMousedOverTissuesChange = function callEmitterWhenMousedOverTissuesChange(eventEmitter) {
	    var forEachXNotInYsEmit = function forEachXNotInYsEmit(xs, ys, eventName) {
	        xs.filter(function (id) {
	            return ys.indexOf(id) === -1;
	        }).forEach(function (id) {
	            eventEmitter.emit(eventName, id);
	        });
	    };

	    return function emitEvents(nextIds, previousIds) {
	        forEachXNotInYsEmit(nextIds, previousIds, 'gxaAnatomogramTissueMouseEnter');
	        forEachXNotInYsEmit(previousIds, nextIds, 'gxaAnatomogramTissueMouseLeave');
	    };
	};

	var createAnatomogram = function createAnatomogram(args) {
	    validate(args, argumentShape);

	    var availableAnatomograms = _availableAnatomograms(args.anatomogramData.species, args.pathToFolderWithBundledResources, args.anatomogramData.allSvgPathIds || null);

	    return availableAnatomograms.length ? React.createElement(Anatomogram, _extends({
	        pathToFolderWithBundledResources: args.pathToFolderWithBundledResources,
	        expressedTissueColour: args.expressedTissueColour,
	        hoveredTissueColour: args.hoveredTissueColour,
	        availableAnatomograms: availableAnatomograms,
	        height: args.anatomogramData.species.indexOf("homo sapiens") > -1 ? 375 : 265,
	        whenMousedOverIdsChange: args.whenMousedOverIdsChange || (args.eventEmitter ? callEmitterWhenMousedOverTissuesChange(args.eventEmitter) : function () {}),
	        idsExpressedInExperiment: args.idsExpressedInExperiment || args.ontologyIdsForTissuesExpressedInAllRows || [],
	        idsToBeHighlighted: args.idsToBeHighlighted || []
	    }, args.anatomogramData.allSvgPathIds ? { allSvgPathIds: args.anatomogramData.allSvgPathIds } : {})) : null;
	};

	//http://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
	var arraysEqual = function arraysEqual(a, b) {
	    if (a === b) return true;
	    if (a == null || b == null) return false;
	    if (a.length != b.length) return false;
	    for (var i = 0; i < a.length; ++i) {
	        if (a[i] !== b[i]) return false;
	    }
	    return true;
	};

	var makeWrapper = function makeWrapper(ComponentClass) {
	    return React.createClass({
	        displayName: "WrappedComponent",
	        propTypes: {
	            ontologyIdsToHighlight: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	            onOntologyIdIsUnderFocus: React.PropTypes.func.isRequired,
	            componentProps: React.PropTypes.object.isRequired
	        },

	        shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	            return !arraysEqual(nextProps.ontologyIdsToHighlight, this.props.ontologyIdsToHighlight);
	        },
	        render: function render() {
	            return React.createElement(
	                'div',
	                { id: 'gxaAnatomogramWrapper' },
	                React.createElement(ComponentClass, _extends({ ontologyIdsToHighlight: this.props.ontologyIdsToHighlight,
	                    onOntologyIdIsUnderFocus: this.props.onOntologyIdIsUnderFocus
	                }, this.props.componentProps))
	            );
	        }
	    });
	};

	/**
	anatomogramConfig: see argumentShape
	componentClass : a React class to be wrapped. Should accept props onOntologyIdIsUnderFocus and ontologyIdsToHighlight
	componentProps : other props to be passed over.
	*/
	var wrapComponentWithAnatomogram = function wrapComponentWithAnatomogram(anatomogramConfig, componentClass, componentProps) {
	    var Wrapped = makeWrapper(componentClass);

	    return React.createClass({
	        displayName: "AnatomogramComponentWrapper",

	        getInitialState: function getInitialState() {
	            return {
	                ontologyIdsForComponentContentUnderFocus: [],
	                ontologyIdsForAnatomogramContentUnderFocus: []
	            };
	        },
	        render: function render() {
	            var _this = this;

	            return React.createElement(
	                'div',
	                null,
	                React.createElement(
	                    'div',
	                    { id: 'gxaAnatomogramAside' },
	                    createAnatomogram(Object.assign({}, anatomogramConfig, {
	                        idsToBeHighlighted: this.state.ontologyIdsForComponentContentUnderFocus,
	                        whenMousedOverIdsChange: function whenMousedOverIdsChange(nextIds) {
	                            _this.setState({ ontologyIdsForAnatomogramContentUnderFocus: nextIds });
	                        }
	                    }))
	                ),
	                React.createElement(Wrapped, { componentProps: componentProps,
	                    onOntologyIdIsUnderFocus: function onOntologyIdIsUnderFocus(selectedIdOrIds) {
	                        _this.setState({
	                            ontologyIdsForComponentContentUnderFocus: selectedIdOrIds ? typeof selectedIdOrIds === 'string' ? [selectedIdOrIds] : selectedIdOrIds : [] });
	                    },
	                    ontologyIdsToHighlight: this.state.ontologyIdsForAnatomogramContentUnderFocus })
	            );
	        }
	    });
	};

	module.exports = { "create": createAnatomogram, "wrapComponent": wrapComponentWithAnatomogram };

/***/ },
/* 612 */
/***/ function(module, exports) {

	/**
	 * @param {Object} object to be validated
	 * @param {Object} propTypes object with defined prop types
	 * @param {Boolean} _throw if set to true, invalid prop types will throw
	 */
	'use strict';

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});
	exports['default'] = check;

	function check(object, propTypes, _throw) {
	    var propName = undefined;

	    for (propName in propTypes) {
	        if (propTypes.hasOwnProperty(propName)) {
	            var error = propTypes[propName](object, propName, JSON.stringify(object), 'prop');
	            if (error) {
	                if (_throw) {
	                    throw error;
	                } else {
	                    console.error(error.message);
	                }
	            }
	        }
	    }
	}

	module.exports = exports['default'];

/***/ },
/* 613 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var React = __webpack_require__(139);
	var AnatomogramImage = __webpack_require__(614);
	var SelectionIcon = __webpack_require__(616);

	var Anatomogram = React.createClass({
	    displayName: "Anatomogram",

	    propTypes: {
	        pathToFolderWithBundledResources: React.PropTypes.string.isRequired,
	        expressedTissueColour: React.PropTypes.string.isRequired,
	        hoveredTissueColour: React.PropTypes.string.isRequired,
	        availableAnatomograms: React.PropTypes.arrayOf(React.PropTypes.shape({
	            type: React.PropTypes.string.isRequired,
	            path: React.PropTypes.string.isRequired,
	            ids: React.PropTypes.arrayOf(React.PropTypes.string).isRequired
	        })).isRequired,
	        height: React.PropTypes.number.isRequired,
	        whenMousedOverIdsChange: React.PropTypes.func,
	        allSvgPathIds: React.PropTypes.arrayOf(React.PropTypes.string),
	        idsToBeHighlighted: React.PropTypes.arrayOf(React.PropTypes.string).isRequired
	    },

	    getInitialState: function getInitialState() {
	        return { selectedType: this.props.availableAnatomograms[0].type };
	    },
	    render: function render() {
	        return React.createElement(
	            "div",
	            { className: "gxaAnatomogram", style: { display: "table", paddingTop: "4px" } },
	            React.createElement(
	                "div",
	                { style: { display: "table-row" } },
	                React.createElement(
	                    "div",
	                    { style: { display: "table-cell", verticalAlign: "top" } },
	                    this._anatomogramSelectImageButtons()
	                ),
	                React.createElement(AnatomogramImage, _extends({
	                    key: this.state.selectedType,
	                    file: this._selectedAnatomogram().path,
	                    allSvgPathIds: this.props.allSvgPathIds || this._selectedAnatomogram().ids
	                }, this.props))
	            )
	        );
	    },
	    _anatomogramSelectImageButtons: function _anatomogramSelectImageButtons() {
	        var _this = this;

	        return this.props.availableAnatomograms.length < 2 ? [] : this.props.availableAnatomograms.map(function (availableAnatomogram) {
	            return React.createElement(SelectionIcon, {
	                key: availableAnatomogram.type + "_toggle",
	                pathToFolderWithBundledResources: _this.props.pathToFolderWithBundledResources,
	                anatomogramType: availableAnatomogram.type,
	                selected: _this.state.selectedType === availableAnatomogram.type,
	                onClick: function onClick() {
	                    _this._afterUserSelectedAnatomogram(availableAnatomogram.type);
	                } });
	        });
	    },
	    _afterUserSelectedAnatomogram: function _afterUserSelectedAnatomogram(newSelectedType) {
	        if (newSelectedType !== this.state.selectedType) {
	            this.setState({ selectedType: newSelectedType });
	        }
	    },
	    _selectedAnatomogram: function _selectedAnatomogram() {
	        var _this2 = this;

	        return this.props.availableAnatomograms.filter(function (e) {
	            return e.type === _this2.state.selectedType;
	        }).concat({
	            type: "_",
	            path: "__invalid__.svg",
	            ids: []
	        })[0];
	    }
	});

	module.exports = Anatomogram;

/***/ },
/* 614 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	var React = __webpack_require__(139);
	var ReactDOM = __webpack_require__(300);
	var Snap = __webpack_require__(615);

	//http://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
	var ArraysEqual = function ArraysEqual(a, b) {
	    if (a === b) return true;
	    if (a == null || b == null) return false;
	    if (a.length != b.length) return false;
	    for (var i = 0; i < a.length; ++i) {
	        if (a[i] !== b[i]) return false;
	    }
	    return true;
	};

	var AnatomogramImageParts = React.createClass({
	    displayName: "AnatomogramImageParts",

	    propTypes: {
	        idsExpressedInExperiment: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	        idsHeatmapWantsHighlighted: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	        idsMousedOver: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	        idsNotHighlighted: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	        expressedTissueColour: React.PropTypes.string.isRequired,
	        hoveredTissueColour: React.PropTypes.string.isRequired,
	        whenMousedOverIdsChange: React.PropTypes.func
	    },

	    getDefaultProps: function getDefaultProps() {
	        return { whenMousedOverIdsChange: function whenMousedOverIdsChange(nextIds, oldIds) {} };
	    },
	    getInitialState: function getInitialState() {
	        return {
	            toDraw: [].concat(this._idsThatShouldBeStronglyHighlighted(this.props).map(this._highlightStrongly), this.props.idsExpressedInExperiment.map(this._highlightSlightly), this.props.idsNotHighlighted.map(this._highlightAsBackground)) };
	    },
	    render: function render() {
	        return React.createElement("span", null);
	    },
	    _highlightStrongly: function _highlightStrongly(svgPathId) {
	        return { id: svgPathId, colour: this.props.hoveredTissueColour, opacity: 0.7 };
	    },
	    _highlightSlightly: function _highlightSlightly(svgPathId) {
	        return { id: svgPathId, colour: this.props.expressedTissueColour, opacity: 0.5 };
	    },
	    _highlightAsBackground: function _highlightAsBackground(svgPathId) {
	        return { id: svgPathId, colour: "gray", opacity: 0.5 };
	    },
	    componentWillUnmount: function componentWillUnmount() {
	        this.props.whenMousedOverIdsChange([], this.props.idsMousedOver);
	    },
	    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	        var _this = this;

	        if (!ArraysEqual(nextProps.idsMousedOver, this.props.idsMousedOver)) {
	            this.props.whenMousedOverIdsChange(nextProps.idsMousedOver, this.props.idsMousedOver);
	        }
	        var oldStrong = this._idsThatShouldBeStronglyHighlighted(this.props);
	        var newStrong = this._idsThatShouldBeStronglyHighlighted(nextProps);
	        var oldWeak = this.props.idsExpressedInExperiment;
	        var newWeak = nextProps.idsExpressedInExperiment;

	        var toDraw = [].concat(
	        //ids that heatmap wants highlighted are the most highlighted
	        newStrong.filter(function (id) {
	            return !oldStrong.includes(id);
	        }).map(this._highlightStrongly),
	        //ids that are expressed in the experiment are highlighted with a weaker colour, often the same as background
	        newWeak.filter(function (id) {
	            return !newStrong.includes(id);
	        }).filter(function (id) {
	            return !oldWeak.includes(id);
	        }).map(this._highlightSlightly), nextProps.idsNotHighlighted.filter(function (id) {
	            return !_this.props.idsNotHighlighted.includes(id);
	        }).map(this._highlightAsBackground));

	        this.setState({ toDraw: toDraw });
	    },
	    _idsThatShouldBeStronglyHighlighted: function _idsThatShouldBeStronglyHighlighted(properties) {
	        return properties.idsHeatmapWantsHighlighted.concat(properties.idsMousedOver);
	    }
	});

	var AnatomogramImage = React.createClass({
	    displayName: "AnatomogramImage",

	    propTypes: {
	        file: function file(props, propName, componentName) {
	            if (propName === "file") {
	                if (typeof props[propName] !== "string") {
	                    return new Error("Expected string to specify file, got: " + props[propName]);
	                }
	                if (!props[propName]) {
	                    return new Error("Path to file empty!");
	                }
	            }
	            return "";
	        },
	        height: React.PropTypes.number.isRequired,
	        allSvgPathIds: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	        idsExpressedInExperiment: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	        idsToBeHighlighted: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	        expressedTissueColour: React.PropTypes.string.isRequired,
	        hoveredTissueColour: React.PropTypes.string.isRequired,
	        whenMousedOverIdsChange: React.PropTypes.func
	    },

	    getInitialState: function getInitialState() {
	        return { mousedOverSvgIds: [] };
	    },
	    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	        if (nextProps.file !== this.props.file) {
	            this._loadAnatomogram(nextProps.file);
	        }
	    },
	    componentDidMount: function componentDidMount() {
	        this._loadAnatomogram(this.props.file);
	        this._draw();
	    },
	    componentDidUpdate: function componentDidUpdate() {
	        this._draw();
	    },
	    _draw: function _draw() {
	        var svg = Snap(ReactDOM.findDOMNode(this._anatomogram)).select("#LAYER_EFO");
	        if (svg !== null) {
	            this._drawOnSvg(svg, this._imageParts.state.toDraw);
	            this._imageParts.setState({ toDraw: [] });
	        }
	    },
	    _drawInitialLayout: function _drawInitialLayout(svg) {
	        if (this._imageParts) {
	            this._drawOnSvg(svg, this._imageParts.getInitialState().toDraw);
	            this._imageParts.setState({ toDraw: [] });
	        }
	    },
	    _drawOnSvg: function _drawOnSvg(svg, instructions) {
	        var _this2 = this;

	        instructions.forEach(function (instruction) {
	            _this2._highlightOrganismParts(svg, instruction.id, instruction.colour, instruction.opacity);
	        });
	    },
	    render: function render() {
	        var _this3 = this;

	        var idsExpressedInExperiment = [],
	            idsHoveredOver = [],
	            idsHeatmapWantsHighlighted = [],
	            idsNotHighlighted = [];

	        this.props.allSvgPathIds.forEach(function (id) {
	            if (_this3.state.mousedOverSvgIds.includes(id)) {
	                idsHoveredOver.push(id);
	            } else if (_this3.props.idsToBeHighlighted.includes(id)) {
	                idsHeatmapWantsHighlighted.push(id);
	            } else if (_this3.props.idsExpressedInExperiment.includes(id)) {
	                idsExpressedInExperiment.push(id);
	            } else {
	                idsNotHighlighted.push(id);
	            }
	        });

	        return React.createElement(
	            "span",
	            null,
	            React.createElement("svg", { ref: function ref(c) {
	                    return _this3._anatomogram = c;
	                }, style: { display: "table-cell", width: "230px", height: this.props.height + "px" } }),
	            React.createElement(AnatomogramImageParts, {
	                ref: function ref(c) {
	                    return _this3._imageParts = c;
	                }, key: this.props.file,
	                idsExpressedInExperiment: idsExpressedInExperiment,
	                idsHeatmapWantsHighlighted: idsHeatmapWantsHighlighted,
	                idsMousedOver: idsHoveredOver,
	                idsNotHighlighted: idsNotHighlighted,
	                expressedTissueColour: this.props.expressedTissueColour,
	                hoveredTissueColour: this.props.hoveredTissueColour,
	                whenMousedOverIdsChange: this.props.whenMousedOverIdsChange
	            })
	        );
	    },
	    _highlightPath: function _highlightPath(svgPathId) {
	        this.setState({ hoveredPathId: svgPathId });
	    },
	    _loadAnatomogram: function _loadAnatomogram(svgFile) {
	        var _this4 = this;

	        var svgCanvas = Snap(ReactDOM.findDOMNode(this._anatomogram)),
	            allElements = svgCanvas.selectAll("*");

	        if (allElements) {
	            allElements.remove();
	        }

	        var displayAllOrganismPartsCallback = this._drawInitialLayout;
	        var registerHoverEventsCallback = this._registerHoverEvents;

	        Snap.load(svgFile, function (fragment) {
	            displayAllOrganismPartsCallback(fragment.select("#LAYER_EFO"));
	            registerHoverEventsCallback(fragment.select("#LAYER_EFO"));
	            fragment.selectAll("svg > g").forEach(function (g) {
	                g.transform("S1.6,0,0");
	                svgCanvas.append(g);
	            });
	            var img = fragment.select("#ccLogo");
	            if (img) {
	                // svgCanvas.node.clientHeight and svgCanvas.node.clientWidth is more “correct” but are 0 in Firefox
	                var heightTranslate = Number.parseInt(_this4._anatomogram.style.height) - 15;
	                var widthTranslate = Number.parseInt(_this4._anatomogram.style.width) / 2 - 40;
	                img.transform("t" + widthTranslate + "," + heightTranslate);
	                svgCanvas.append(img);
	            }
	        });
	    },
	    _registerHoverEvents: function _registerHoverEvents(svg) {
	        var _this5 = this;

	        if (svg) {
	            (function () {
	                // Sometimes svg is null... why?
	                var MaxOverlappingTissues = 5;
	                var mouseoverCallback = function mouseoverCallback(svgPathId) {
	                    _this5.setState(function (previousState) {
	                        return { mousedOverSvgIds: [].concat(_toConsumableArray(previousState.mousedOverSvgIds), [svgPathId]).slice(-MaxOverlappingTissues) };
	                    });
	                };

	                var mouseoutCallback = function mouseoutCallback(svgPathId) {
	                    _this5.setState(function (previousState) {
	                        return { mousedOverSvgIds: previousState.mousedOverSvgIds.map(function (el) {
	                                return el === svgPathId ? "" : el;
	                            }) };
	                    });
	                };

	                var attachCallbacks = function attachCallbacks(svgElement, svgPathId) {
	                    if (svgElement) {
	                        svgElement.mouseover(function () {
	                            mouseoverCallback(svgPathId);
	                        });
	                        svgElement.mouseout(function () {
	                            mouseoutCallback(svgPathId);
	                        });
	                    }
	                };

	                _this5.props.allSvgPathIds.forEach(function (svgPathId) {
	                    var svgElement = svg.select("#" + svgPathId);
	                    attachCallbacks(svgElement, svgPathId);
	                    if (svgElement && svgElement.type === "use") {
	                        attachCallbacks(svg.select(svgElement.node.getAttribute("xlink:href")), svgPathId);
	                    }
	                });
	            })();
	        }
	    },
	    _highlightOrganismParts: function _highlightOrganismParts(svg, svgPathId, colour, opacity) {
	        var el = svg.select("#" + svgPathId);
	        if (el && el.type === "use") {
	            this._recursivelyChangeProperties(svg.select(el.node.getAttribute("xlink:href")), colour, opacity);
	        }
	        this._recursivelyChangeProperties(el, colour, opacity);
	    },
	    _recursivelyChangeProperties: function _recursivelyChangeProperties(svgElement, colour, opacity) {
	        var _this6 = this;

	        if (svgElement) {
	            svgElement.selectAll("*").forEach(function (innerElement) {
	                _this6._recursivelyChangeProperties(innerElement);
	            });
	            svgElement.attr({ "fill": colour, "fill-opacity": opacity });
	        }
	    }
	});

	module.exports = AnatomogramImage;

/***/ },
/* 615 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
	(function() {
	var fix = module.exports=0;

	// Snap.svg 0.4.0
	// 
	// Copyright (c) 2013 – 2015 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	// 
	// build: 2015-04-07

	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	// ┌────────────────────────────────────────────────────────────┐ \\
	// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
	// ├────────────────────────────────────────────────────────────┤ \\
	// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
	// └────────────────────────────────────────────────────────────┘ \\

	(function (glob) {
	    var version = "0.4.2",
	        has = "hasOwnProperty",
	        separator = /[\.\/]/,
	        comaseparator = /\s*,\s*/,
	        wildcard = "*",
	        fun = function () {},
	        numsort = function (a, b) {
	            return a - b;
	        },
	        current_event,
	        stop,
	        events = {n: {}},
	        firstDefined = function () {
	            for (var i = 0, ii = this.length; i < ii; i++) {
	                if (typeof this[i] != "undefined") {
	                    return this[i];
	                }
	            }
	        },
	        lastDefined = function () {
	            var i = this.length;
	            while (--i) {
	                if (typeof this[i] != "undefined") {
	                    return this[i];
	                }
	            }
	        },
	    /*\
	     * eve
	     [ method ]

	     * Fires event with given `name`, given scope and other parameters.

	     > Arguments

	     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
	     - scope (object) context for the event handlers
	     - varargs (...) the rest of arguments will be sent to event handlers

	     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
	    \*/
	        eve = function (name, scope) {
	            name = String(name);
	            var e = events,
	                oldstop = stop,
	                args = Array.prototype.slice.call(arguments, 2),
	                listeners = eve.listeners(name),
	                z = 0,
	                f = false,
	                l,
	                indexed = [],
	                queue = {},
	                out = [],
	                ce = current_event,
	                errors = [];
	            out.firstDefined = firstDefined;
	            out.lastDefined = lastDefined;
	            current_event = name;
	            stop = 0;
	            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
	                indexed.push(listeners[i].zIndex);
	                if (listeners[i].zIndex < 0) {
	                    queue[listeners[i].zIndex] = listeners[i];
	                }
	            }
	            indexed.sort(numsort);
	            while (indexed[z] < 0) {
	                l = queue[indexed[z++]];
	                out.push(l.apply(scope, args));
	                if (stop) {
	                    stop = oldstop;
	                    return out;
	                }
	            }
	            for (i = 0; i < ii; i++) {
	                l = listeners[i];
	                if ("zIndex" in l) {
	                    if (l.zIndex == indexed[z]) {
	                        out.push(l.apply(scope, args));
	                        if (stop) {
	                            break;
	                        }
	                        do {
	                            z++;
	                            l = queue[indexed[z]];
	                            l && out.push(l.apply(scope, args));
	                            if (stop) {
	                                break;
	                            }
	                        } while (l)
	                    } else {
	                        queue[l.zIndex] = l;
	                    }
	                } else {
	                    out.push(l.apply(scope, args));
	                    if (stop) {
	                        break;
	                    }
	                }
	            }
	            stop = oldstop;
	            current_event = ce;
	            return out;
	        };
	        // Undocumented. Debug only.
	        eve._events = events;
	    /*\
	     * eve.listeners
	     [ method ]

	     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

	     > Arguments

	     - name (string) name of the event, dot (`.`) or slash (`/`) separated

	     = (array) array of event handlers
	    \*/
	    eve.listeners = function (name) {
	        var names = name.split(separator),
	            e = events,
	            item,
	            items,
	            k,
	            i,
	            ii,
	            j,
	            jj,
	            nes,
	            es = [e],
	            out = [];
	        for (i = 0, ii = names.length; i < ii; i++) {
	            nes = [];
	            for (j = 0, jj = es.length; j < jj; j++) {
	                e = es[j].n;
	                items = [e[names[i]], e[wildcard]];
	                k = 2;
	                while (k--) {
	                    item = items[k];
	                    if (item) {
	                        nes.push(item);
	                        out = out.concat(item.f || []);
	                    }
	                }
	            }
	            es = nes;
	        }
	        return out;
	    };
	    
	    /*\
	     * eve.on
	     [ method ]
	     **
	     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
	     | eve.on("*.under.*", f);
	     | eve("mouse.under.floor"); // triggers f
	     * Use @eve to trigger the listener.
	     **
	     > Arguments
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	     **
	     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
	     > Example:
	     | eve.on("mouse", eatIt)(2);
	     | eve.on("mouse", scream);
	     | eve.on("mouse", catchIt)(1);
	     * This will ensure that `catchIt` function will be called before `eatIt`.
	     *
	     * If you want to put your handler before non-indexed handlers, specify a negative value.
	     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
	    \*/
	    eve.on = function (name, f) {
	        name = String(name);
	        if (typeof f != "function") {
	            return function () {};
	        }
	        var names = name.split(comaseparator);
	        for (var i = 0, ii = names.length; i < ii; i++) {
	            (function (name) {
	                var names = name.split(separator),
	                    e = events,
	                    exist;
	                for (var i = 0, ii = names.length; i < ii; i++) {
	                    e = e.n;
	                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
	                }
	                e.f = e.f || [];
	                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
	                    exist = true;
	                    break;
	                }
	                !exist && e.f.push(f);
	            }(names[i]));
	        }
	        return function (zIndex) {
	            if (+zIndex == +zIndex) {
	                f.zIndex = +zIndex;
	            }
	        };
	    };
	    /*\
	     * eve.f
	     [ method ]
	     **
	     * Returns function that will fire given event with optional arguments.
	     * Arguments that will be passed to the result function will be also
	     * concated to the list of final arguments.
	     | el.onclick = eve.f("click", 1, 2);
	     | eve.on("click", function (a, b, c) {
	     |     console.log(a, b, c); // 1, 2, [event object]
	     | });
	     > Arguments
	     - event (string) event name
	     - varargs (…) and any other arguments
	     = (function) possible event handler function
	    \*/
	    eve.f = function (event) {
	        var attrs = [].slice.call(arguments, 1);
	        return function () {
	            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
	        };
	    };
	    /*\
	     * eve.stop
	     [ method ]
	     **
	     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
	    \*/
	    eve.stop = function () {
	        stop = 1;
	    };
	    /*\
	     * eve.nt
	     [ method ]
	     **
	     * Could be used inside event handler to figure out actual name of the event.
	     **
	     > Arguments
	     **
	     - subname (string) #optional subname of the event
	     **
	     = (string) name of the event, if `subname` is not specified
	     * or
	     = (boolean) `true`, if current event’s name contains `subname`
	    \*/
	    eve.nt = function (subname) {
	        if (subname) {
	            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
	        }
	        return current_event;
	    };
	    /*\
	     * eve.nts
	     [ method ]
	     **
	     * Could be used inside event handler to figure out actual name of the event.
	     **
	     **
	     = (array) names of the event
	    \*/
	    eve.nts = function () {
	        return current_event.split(separator);
	    };
	    /*\
	     * eve.off
	     [ method ]
	     **
	     * Removes given function from the list of event listeners assigned to given name.
	     * If no arguments specified all the events will be cleared.
	     **
	     > Arguments
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	    \*/
	    /*\
	     * eve.unbind
	     [ method ]
	     **
	     * See @eve.off
	    \*/
	    eve.off = eve.unbind = function (name, f) {
	        if (!name) {
	            eve._events = events = {n: {}};
	            return;
	        }
	        var names = name.split(comaseparator);
	        if (names.length > 1) {
	            for (var i = 0, ii = names.length; i < ii; i++) {
	                eve.off(names[i], f);
	            }
	            return;
	        }
	        names = name.split(separator);
	        var e,
	            key,
	            splice,
	            i, ii, j, jj,
	            cur = [events];
	        for (i = 0, ii = names.length; i < ii; i++) {
	            for (j = 0; j < cur.length; j += splice.length - 2) {
	                splice = [j, 1];
	                e = cur[j].n;
	                if (names[i] != wildcard) {
	                    if (e[names[i]]) {
	                        splice.push(e[names[i]]);
	                    }
	                } else {
	                    for (key in e) if (e[has](key)) {
	                        splice.push(e[key]);
	                    }
	                }
	                cur.splice.apply(cur, splice);
	            }
	        }
	        for (i = 0, ii = cur.length; i < ii; i++) {
	            e = cur[i];
	            while (e.n) {
	                if (f) {
	                    if (e.f) {
	                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
	                            e.f.splice(j, 1);
	                            break;
	                        }
	                        !e.f.length && delete e.f;
	                    }
	                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
	                        var funcs = e.n[key].f;
	                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
	                            funcs.splice(j, 1);
	                            break;
	                        }
	                        !funcs.length && delete e.n[key].f;
	                    }
	                } else {
	                    delete e.f;
	                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
	                        delete e.n[key].f;
	                    }
	                }
	                e = e.n;
	            }
	        }
	    };
	    /*\
	     * eve.once
	     [ method ]
	     **
	     * Binds given event handler with a given name to only run once then unbind itself.
	     | eve.once("login", f);
	     | eve("login"); // triggers f
	     | eve("login"); // no listeners
	     * Use @eve to trigger the listener.
	     **
	     > Arguments
	     **
	     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
	     - f (function) event handler function
	     **
	     = (function) same return function as @eve.on
	    \*/
	    eve.once = function (name, f) {
	        var f2 = function () {
	            eve.unbind(name, f2);
	            return f.apply(this, arguments);
	        };
	        return eve.on(name, f2);
	    };
	    /*\
	     * eve.version
	     [ property (string) ]
	     **
	     * Current version of the library.
	    \*/
	    eve.version = version;
	    eve.toString = function () {
	        return "You are running Eve " + version;
	    };
	    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_0__ = (function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))) : (glob.eve = eve));
	})(this);

	(function (glob, factory) {
	    // AMD support
	    if (true) {
	        // Define as an anonymous module
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__], __WEBPACK_AMD_DEFINE_RESULT__ = function (eve) {
	            return factory(glob, eve);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports != 'undefined') {
	        // Next for Node.js or CommonJS
	        var eve = require('eve');
	        module.exports = factory(glob, eve);
	    } else {
	        // Browser globals (glob is window)
	        // Snap adds itself to window
	        factory(glob, glob.eve);
	    }
	}(window || this, function (window, eve) {

	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	var mina = (function (eve) {
	    var animations = {},
	    requestAnimFrame = window.requestAnimationFrame       ||
	                       window.webkitRequestAnimationFrame ||
	                       window.mozRequestAnimationFrame    ||
	                       window.oRequestAnimationFrame      ||
	                       window.msRequestAnimationFrame     ||
	                       function (callback) {
	                           setTimeout(callback, 16);
	                       },
	    isArray = Array.isArray || function (a) {
	        return a instanceof Array ||
	            Object.prototype.toString.call(a) == "[object Array]";
	    },
	    idgen = 0,
	    idprefix = "M" + (+new Date).toString(36),
	    ID = function () {
	        return idprefix + (idgen++).toString(36);
	    },
	    diff = function (a, b, A, B) {
	        if (isArray(a)) {
	            res = [];
	            for (var i = 0, ii = a.length; i < ii; i++) {
	                res[i] = diff(a[i], b, A[i], B);
	            }
	            return res;
	        }
	        var dif = (A - a) / (B - b);
	        return function (bb) {
	            return a + dif * (bb - b);
	        };
	    },
	    timer = Date.now || function () {
	        return +new Date;
	    },
	    sta = function (val) {
	        var a = this;
	        if (val == null) {
	            return a.s;
	        }
	        var ds = a.s - val;
	        a.b += a.dur * ds;
	        a.B += a.dur * ds;
	        a.s = val;
	    },
	    speed = function (val) {
	        var a = this;
	        if (val == null) {
	            return a.spd;
	        }
	        a.spd = val;
	    },
	    duration = function (val) {
	        var a = this;
	        if (val == null) {
	            return a.dur;
	        }
	        a.s = a.s * val / a.dur;
	        a.dur = val;
	    },
	    stopit = function () {
	        var a = this;
	        delete animations[a.id];
	        a.update();
	        eve("mina.stop." + a.id, a);
	    },
	    pause = function () {
	        var a = this;
	        if (a.pdif) {
	            return;
	        }
	        delete animations[a.id];
	        a.update();
	        a.pdif = a.get() - a.b;
	    },
	    resume = function () {
	        var a = this;
	        if (!a.pdif) {
	            return;
	        }
	        a.b = a.get() - a.pdif;
	        delete a.pdif;
	        animations[a.id] = a;
	    },
	    update = function () {
	        var a = this,
	            res;
	        if (isArray(a.start)) {
	            res = [];
	            for (var j = 0, jj = a.start.length; j < jj; j++) {
	                res[j] = +a.start[j] +
	                    (a.end[j] - a.start[j]) * a.easing(a.s);
	            }
	        } else {
	            res = +a.start + (a.end - a.start) * a.easing(a.s);
	        }
	        a.set(res);
	    },
	    frame = function () {
	        var len = 0;
	        for (var i in animations) if (animations.hasOwnProperty(i)) {
	            var a = animations[i],
	                b = a.get(),
	                res;
	            len++;
	            a.s = (b - a.b) / (a.dur / a.spd);
	            if (a.s >= 1) {
	                delete animations[i];
	                a.s = 1;
	                len--;
	                (function (a) {
	                    setTimeout(function () {
	                        eve("mina.finish." + a.id, a);
	                    });
	                }(a));
	            }
	            a.update();
	        }
	        len && requestAnimFrame(frame);
	    },
	    /*\
	     * mina
	     [ method ]
	     **
	     * Generic animation of numbers
	     **
	     - a (number) start _slave_ number
	     - A (number) end _slave_ number
	     - b (number) start _master_ number (start time in general case)
	     - B (number) end _master_ number (end time in gereal case)
	     - get (function) getter of _master_ number (see @mina.time)
	     - set (function) setter of _slave_ number
	     - easing (function) #optional easing function, default is @mina.linear
	     = (object) animation descriptor
	     o {
	     o         id (string) animation id,
	     o         start (number) start _slave_ number,
	     o         end (number) end _slave_ number,
	     o         b (number) start _master_ number,
	     o         s (number) animation status (0..1),
	     o         dur (number) animation duration,
	     o         spd (number) animation speed,
	     o         get (function) getter of _master_ number (see @mina.time),
	     o         set (function) setter of _slave_ number,
	     o         easing (function) easing function, default is @mina.linear,
	     o         status (function) status getter/setter,
	     o         speed (function) speed getter/setter,
	     o         duration (function) duration getter/setter,
	     o         stop (function) animation stopper
	     o         pause (function) pauses the animation
	     o         resume (function) resumes the animation
	     o         update (function) calles setter with the right value of the animation
	     o }
	    \*/
	    mina = function (a, A, b, B, get, set, easing) {
	        var anim = {
	            id: ID(),
	            start: a,
	            end: A,
	            b: b,
	            s: 0,
	            dur: B - b,
	            spd: 1,
	            get: get,
	            set: set,
	            easing: easing || mina.linear,
	            status: sta,
	            speed: speed,
	            duration: duration,
	            stop: stopit,
	            pause: pause,
	            resume: resume,
	            update: update
	        };
	        animations[anim.id] = anim;
	        var len = 0, i;
	        for (i in animations) if (animations.hasOwnProperty(i)) {
	            len++;
	            if (len == 2) {
	                break;
	            }
	        }
	        len == 1 && requestAnimFrame(frame);
	        return anim;
	    };
	    /*\
	     * mina.time
	     [ method ]
	     **
	     * Returns the current time. Equivalent to:
	     | function () {
	     |     return (new Date).getTime();
	     | }
	    \*/
	    mina.time = timer;
	    /*\
	     * mina.getById
	     [ method ]
	     **
	     * Returns an animation by its id
	     - id (string) animation's id
	     = (object) See @mina
	    \*/
	    mina.getById = function (id) {
	        return animations[id] || null;
	    };

	    /*\
	     * mina.linear
	     [ method ]
	     **
	     * Default linear easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.linear = function (n) {
	        return n;
	    };
	    /*\
	     * mina.easeout
	     [ method ]
	     **
	     * Easeout easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.easeout = function (n) {
	        return Math.pow(n, 1.7);
	    };
	    /*\
	     * mina.easein
	     [ method ]
	     **
	     * Easein easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.easein = function (n) {
	        return Math.pow(n, .48);
	    };
	    /*\
	     * mina.easeinout
	     [ method ]
	     **
	     * Easeinout easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.easeinout = function (n) {
	        if (n == 1) {
	            return 1;
	        }
	        if (n == 0) {
	            return 0;
	        }
	        var q = .48 - n / 1.04,
	            Q = Math.sqrt(.1734 + q * q),
	            x = Q - q,
	            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
	            y = -Q - q,
	            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
	            t = X + Y + .5;
	        return (1 - t) * 3 * t * t + t * t * t;
	    };
	    /*\
	     * mina.backin
	     [ method ]
	     **
	     * Backin easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.backin = function (n) {
	        if (n == 1) {
	            return 1;
	        }
	        var s = 1.70158;
	        return n * n * ((s + 1) * n - s);
	    };
	    /*\
	     * mina.backout
	     [ method ]
	     **
	     * Backout easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.backout = function (n) {
	        if (n == 0) {
	            return 0;
	        }
	        n = n - 1;
	        var s = 1.70158;
	        return n * n * ((s + 1) * n + s) + 1;
	    };
	    /*\
	     * mina.elastic
	     [ method ]
	     **
	     * Elastic easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.elastic = function (n) {
	        if (n == !!n) {
	            return n;
	        }
	        return Math.pow(2, -10 * n) * Math.sin((n - .075) *
	            (2 * Math.PI) / .3) + 1;
	    };
	    /*\
	     * mina.bounce
	     [ method ]
	     **
	     * Bounce easing
	     - n (number) input 0..1
	     = (number) output 0..1
	    \*/
	    mina.bounce = function (n) {
	        var s = 7.5625,
	            p = 2.75,
	            l;
	        if (n < (1 / p)) {
	            l = s * n * n;
	        } else {
	            if (n < (2 / p)) {
	                n -= (1.5 / p);
	                l = s * n * n + .75;
	            } else {
	                if (n < (2.5 / p)) {
	                    n -= (2.25 / p);
	                    l = s * n * n + .9375;
	                } else {
	                    n -= (2.625 / p);
	                    l = s * n * n + .984375;
	                }
	            }
	        }
	        return l;
	    };
	    window.mina = mina;
	    return mina;
	})(typeof eve == "undefined" ? function () {} : eve);
	// Copyright (c) 2013 - 2015 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.

	var Snap = (function(root) {
	Snap.version = "0.4.0";
	/*\
	 * Snap
	 [ method ]
	 **
	 * Creates a drawing surface or wraps existing SVG element.
	 **
	 - width (number|string) width of surface
	 - height (number|string) height of surface
	 * or
	 - DOM (SVGElement) element to be wrapped into Snap structure
	 * or
	 - array (array) array of elements (will return set of elements)
	 * or
	 - query (string) CSS query selector
	 = (object) @Element
	\*/
	function Snap(w, h) {
	    if (w) {
	        if (w.nodeType) {
	            return wrap(w);
	        }
	        if (is(w, "array") && Snap.set) {
	            return Snap.set.apply(Snap, w);
	        }
	        if (w instanceof Element) {
	            return w;
	        }
	        if (h == null) {
	            w = glob.doc.querySelector(String(w));
	            return wrap(w);
	        }
	    }
	    w = w == null ? "100%" : w;
	    h = h == null ? "100%" : h;
	    return new Paper(w, h);
	}
	Snap.toString = function () {
	    return "Snap v" + this.version;
	};
	Snap._ = {};
	var glob = {
	    win: root.window,
	    doc: root.window.document
	};
	Snap._.glob = glob;
	var has = "hasOwnProperty",
	    Str = String,
	    toFloat = parseFloat,
	    toInt = parseInt,
	    math = Math,
	    mmax = math.max,
	    mmin = math.min,
	    abs = math.abs,
	    pow = math.pow,
	    PI = math.PI,
	    round = math.round,
	    E = "",
	    S = " ",
	    objectToString = Object.prototype.toString,
	    ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
	    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
	    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
	    reURLValue = /^url\(#?([^)]+)\)$/,
	    separator = Snap._.separator = /[,\s]+/,
	    whitespace = /[\s]/g,
	    commaSpaces = /[\s]*,[\s]*/,
	    hsrg = {hs: 1, rg: 1},
	    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
	    tCommand = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
	    pathValues = /(-?\d*\.?\d*(?:e[\-+]?\\d+)?)[\s]*,?[\s]*/ig,
	    idgen = 0,
	    idprefix = "S" + (+new Date).toString(36),
	    ID = function (el) {
	        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);
	    },
	    xlink = "http://www.w3.org/1999/xlink",
	    xmlns = "http://www.w3.org/2000/svg",
	    hub = {},
	    URL = Snap.url = function (url) {
	        return "url('#" + url + "')";
	    };

	function $(el, attr) {
	    if (attr) {
	        if (el == "#text") {
	            el = glob.doc.createTextNode(attr.text || attr["#text"] || "");
	        }
	        if (el == "#comment") {
	            el = glob.doc.createComment(attr.text || attr["#text"] || "");
	        }
	        if (typeof el == "string") {
	            el = $(el);
	        }
	        if (typeof attr == "string") {
	            if (el.nodeType == 1) {
	                if (attr.substring(0, 6) == "xlink:") {
	                    return el.getAttributeNS(xlink, attr.substring(6));
	                }
	                if (attr.substring(0, 4) == "xml:") {
	                    return el.getAttributeNS(xmlns, attr.substring(4));
	                }
	                return el.getAttribute(attr);
	            } else if (attr == "text") {
	                return el.nodeValue;
	            } else {
	                return null;
	            }
	        }
	        if (el.nodeType == 1) {
	            for (var key in attr) if (attr[has](key)) {
	                var val = Str(attr[key]);
	                if (val) {
	                    if (key.substring(0, 6) == "xlink:") {
	                        el.setAttributeNS(xlink, key.substring(6), val);
	                    } else if (key.substring(0, 4) == "xml:") {
	                        el.setAttributeNS(xmlns, key.substring(4), val);
	                    } else {
	                        el.setAttribute(key, val);
	                    }
	                } else {
	                    el.removeAttribute(key);
	                }
	            }
	        } else if ("text" in attr) {
	            el.nodeValue = attr.text;
	        }
	    } else {
	        el = glob.doc.createElementNS(xmlns, el);
	    }
	    return el;
	}
	Snap._.$ = $;
	Snap._.id = ID;
	function getAttrs(el) {
	    var attrs = el.attributes,
	        name,
	        out = {};
	    for (var i = 0; i < attrs.length; i++) {
	        if (attrs[i].namespaceURI == xlink) {
	            name = "xlink:";
	        } else {
	            name = "";
	        }
	        name += attrs[i].name;
	        out[name] = attrs[i].textContent;
	    }
	    return out;
	}
	function is(o, type) {
	    type = Str.prototype.toLowerCase.call(type);
	    if (type == "finite") {
	        return isFinite(o);
	    }
	    if (type == "array" &&
	        (o instanceof Array || Array.isArray && Array.isArray(o))) {
	        return true;
	    }
	    return  (type == "null" && o === null) ||
	            (type == typeof o && o !== null) ||
	            (type == "object" && o === Object(o)) ||
	            objectToString.call(o).slice(8, -1).toLowerCase() == type;
	}
	/*\
	 * Snap.format
	 [ method ]
	 **
	 * Replaces construction of type `{<name>}` to the corresponding argument
	 **
	 - token (string) string to format
	 - json (object) object which properties are used as a replacement
	 = (string) formatted string
	 > Usage
	 | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
	 | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
	 |     x: 10,
	 |     y: 20,
	 |     dim: {
	 |         width: 40,
	 |         height: 50,
	 |         "negative width": -40
	 |     }
	 | }));
	\*/
	Snap.format = (function () {
	    var tokenRegex = /\{([^\}]+)\}/g,
	        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
	        replacer = function (all, key, obj) {
	            var res = obj;
	            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
	                name = name || quotedName;
	                if (res) {
	                    if (name in res) {
	                        res = res[name];
	                    }
	                    typeof res == "function" && isFunc && (res = res());
	                }
	            });
	            res = (res == null || res == obj ? all : res) + "";
	            return res;
	        };
	    return function (str, obj) {
	        return Str(str).replace(tokenRegex, function (all, key) {
	            return replacer(all, key, obj);
	        });
	    };
	})();
	function clone(obj) {
	    if (typeof obj == "function" || Object(obj) !== obj) {
	        return obj;
	    }
	    var res = new obj.constructor;
	    for (var key in obj) if (obj[has](key)) {
	        res[key] = clone(obj[key]);
	    }
	    return res;
	}
	Snap._.clone = clone;
	function repush(array, item) {
	    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
	        return array.push(array.splice(i, 1)[0]);
	    }
	}
	function cacher(f, scope, postprocessor) {
	    function newf() {
	        var arg = Array.prototype.slice.call(arguments, 0),
	            args = arg.join("\u2400"),
	            cache = newf.cache = newf.cache || {},
	            count = newf.count = newf.count || [];
	        if (cache[has](args)) {
	            repush(count, args);
	            return postprocessor ? postprocessor(cache[args]) : cache[args];
	        }
	        count.length >= 1e3 && delete cache[count.shift()];
	        count.push(args);
	        cache[args] = f.apply(scope, arg);
	        return postprocessor ? postprocessor(cache[args]) : cache[args];
	    }
	    return newf;
	}
	Snap._.cacher = cacher;
	function angle(x1, y1, x2, y2, x3, y3) {
	    if (x3 == null) {
	        var x = x1 - x2,
	            y = y1 - y2;
	        if (!x && !y) {
	            return 0;
	        }
	        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
	    } else {
	        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
	    }
	}
	function rad(deg) {
	    return deg % 360 * PI / 180;
	}
	function deg(rad) {
	    return rad * 180 / PI % 360;
	}
	function x_y() {
	    return this.x + S + this.y;
	}
	function x_y_w_h() {
	    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
	}

	/*\
	 * Snap.rad
	 [ method ]
	 **
	 * Transform angle to radians
	 - deg (number) angle in degrees
	 = (number) angle in radians
	\*/
	Snap.rad = rad;
	/*\
	 * Snap.deg
	 [ method ]
	 **
	 * Transform angle to degrees
	 - rad (number) angle in radians
	 = (number) angle in degrees
	\*/
	Snap.deg = deg;
	/*\
	 * Snap.sin
	 [ method ]
	 **
	 * Equivalent to `Math.sin()` only works with degrees, not radians.
	 - angle (number) angle in degrees
	 = (number) sin
	\*/
	Snap.sin = function (angle) {
	    return math.sin(Snap.rad(angle));
	};
	/*\
	 * Snap.tan
	 [ method ]
	 **
	 * Equivalent to `Math.tan()` only works with degrees, not radians.
	 - angle (number) angle in degrees
	 = (number) tan
	\*/
	Snap.tan = function (angle) {
	    return math.tan(Snap.rad(angle));
	};
	/*\
	 * Snap.cos
	 [ method ]
	 **
	 * Equivalent to `Math.cos()` only works with degrees, not radians.
	 - angle (number) angle in degrees
	 = (number) cos
	\*/
	Snap.cos = function (angle) {
	    return math.cos(Snap.rad(angle));
	};
	/*\
	 * Snap.asin
	 [ method ]
	 **
	 * Equivalent to `Math.asin()` only works with degrees, not radians.
	 - num (number) value
	 = (number) asin in degrees
	\*/
	Snap.asin = function (num) {
	    return Snap.deg(math.asin(num));
	};
	/*\
	 * Snap.acos
	 [ method ]
	 **
	 * Equivalent to `Math.acos()` only works with degrees, not radians.
	 - num (number) value
	 = (number) acos in degrees
	\*/
	Snap.acos = function (num) {
	    return Snap.deg(math.acos(num));
	};
	/*\
	 * Snap.atan
	 [ method ]
	 **
	 * Equivalent to `Math.atan()` only works with degrees, not radians.
	 - num (number) value
	 = (number) atan in degrees
	\*/
	Snap.atan = function (num) {
	    return Snap.deg(math.atan(num));
	};
	/*\
	 * Snap.atan2
	 [ method ]
	 **
	 * Equivalent to `Math.atan2()` only works with degrees, not radians.
	 - num (number) value
	 = (number) atan2 in degrees
	\*/
	Snap.atan2 = function (num) {
	    return Snap.deg(math.atan2(num));
	};
	/*\
	 * Snap.angle
	 [ method ]
	 **
	 * Returns an angle between two or three points
	 > Parameters
	 - x1 (number) x coord of first point
	 - y1 (number) y coord of first point
	 - x2 (number) x coord of second point
	 - y2 (number) y coord of second point
	 - x3 (number) #optional x coord of third point
	 - y3 (number) #optional y coord of third point
	 = (number) angle in degrees
	\*/
	Snap.angle = angle;
	/*\
	 * Snap.len
	 [ method ]
	 **
	 * Returns distance between two points
	 > Parameters
	 - x1 (number) x coord of first point
	 - y1 (number) y coord of first point
	 - x2 (number) x coord of second point
	 - y2 (number) y coord of second point
	 = (number) distance
	\*/
	Snap.len = function (x1, y1, x2, y2) {
	    return Math.sqrt(Snap.len2(x1, y1, x2, y2));
	};
	/*\
	 * Snap.len2
	 [ method ]
	 **
	 * Returns squared distance between two points
	 > Parameters
	 - x1 (number) x coord of first point
	 - y1 (number) y coord of first point
	 - x2 (number) x coord of second point
	 - y2 (number) y coord of second point
	 = (number) distance
	\*/
	Snap.len2 = function (x1, y1, x2, y2) {
	    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	};
	/*\
	 * Snap.closestPoint
	 [ method ]
	 **
	 * Returns closest point to a given one on a given path.
	 > Parameters
	 - path (Element) path element
	 - x (number) x coord of a point
	 - y (number) y coord of a point
	 = (object) in format
	 {
	    x (number) x coord of the point on the path
	    y (number) y coord of the point on the path
	    length (number) length of the path to the point
	    distance (number) distance from the given point to the path
	 }
	\*/
	// Copied from http://bl.ocks.org/mbostock/8027637
	Snap.closestPoint = function (path, x, y) {
	    function distance2(p) {
	        var dx = p.x - x,
	            dy = p.y - y;
	        return dx * dx + dy * dy;
	    }
	    var pathNode = path.node,
	        pathLength = pathNode.getTotalLength(),
	        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,
	        best,
	        bestLength,
	        bestDistance = Infinity;

	    // linear scan for coarse approximation
	    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
	        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
	            best = scan, bestLength = scanLength, bestDistance = scanDistance;
	        }
	    }

	    // binary search for precise estimate
	    precision *= .5;
	    while (precision > .5) {
	        var before,
	            after,
	            beforeLength,
	            afterLength,
	            beforeDistance,
	            afterDistance;
	        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
	            best = before, bestLength = beforeLength, bestDistance = beforeDistance;
	        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
	            best = after, bestLength = afterLength, bestDistance = afterDistance;
	        } else {
	            precision *= .5;
	        }
	    }

	    best = {
	        x: best.x,
	        y: best.y,
	        length: bestLength,
	        distance: Math.sqrt(bestDistance)
	    };
	    return best;
	}
	/*\
	 * Snap.is
	 [ method ]
	 **
	 * Handy replacement for the `typeof` operator
	 - o (…) any object or primitive
	 - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
	 = (boolean) `true` if given value is of given type
	\*/
	Snap.is = is;
	/*\
	 * Snap.snapTo
	 [ method ]
	 **
	 * Snaps given value to given grid
	 - values (array|number) given array of values or step of the grid
	 - value (number) value to adjust
	 - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
	 = (number) adjusted value
	\*/
	Snap.snapTo = function (values, value, tolerance) {
	    tolerance = is(tolerance, "finite") ? tolerance : 10;
	    if (is(values, "array")) {
	        var i = values.length;
	        while (i--) if (abs(values[i] - value) <= tolerance) {
	            return values[i];
	        }
	    } else {
	        values = +values;
	        var rem = value % values;
	        if (rem < tolerance) {
	            return value - rem;
	        }
	        if (rem > values - tolerance) {
	            return value - rem + values;
	        }
	    }
	    return value;
	};
	// Colour
	/*\
	 * Snap.getRGB
	 [ method ]
	 **
	 * Parses color string as RGB object
	 - color (string) color string in one of the following formats:
	 # <ul>
	 #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
	 #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
	 #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
	 #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
	 #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>
	 #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
	 #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>
	 #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
	 #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>
	 #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
	 #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>
	 #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
	 #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>
	 #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
	 #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>
	 # </ul>
	 * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
	 = (object) RGB object in the following format:
	 o {
	 o     r (number) red,
	 o     g (number) green,
	 o     b (number) blue,
	 o     hex (string) color in HTML/CSS format: #••••••,
	 o     error (boolean) true if string can't be parsed
	 o }
	\*/
	Snap.getRGB = cacher(function (colour) {
	    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
	        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
	    }
	    if (colour == "none") {
	        return {r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString};
	    }
	    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
	    if (!colour) {
	        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
	    }
	    var res,
	        red,
	        green,
	        blue,
	        opacity,
	        t,
	        values,
	        rgb = colour.match(colourRegExp);
	    if (rgb) {
	        if (rgb[2]) {
	            blue = toInt(rgb[2].substring(5), 16);
	            green = toInt(rgb[2].substring(3, 5), 16);
	            red = toInt(rgb[2].substring(1, 3), 16);
	        }
	        if (rgb[3]) {
	            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
	            green = toInt((t = rgb[3].charAt(2)) + t, 16);
	            red = toInt((t = rgb[3].charAt(1)) + t, 16);
	        }
	        if (rgb[4]) {
	            values = rgb[4].split(commaSpaces);
	            red = toFloat(values[0]);
	            values[0].slice(-1) == "%" && (red *= 2.55);
	            green = toFloat(values[1]);
	            values[1].slice(-1) == "%" && (green *= 2.55);
	            blue = toFloat(values[2]);
	            values[2].slice(-1) == "%" && (blue *= 2.55);
	            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
	            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
	        }
	        if (rgb[5]) {
	            values = rgb[5].split(commaSpaces);
	            red = toFloat(values[0]);
	            values[0].slice(-1) == "%" && (red /= 100);
	            green = toFloat(values[1]);
	            values[1].slice(-1) == "%" && (green /= 100);
	            blue = toFloat(values[2]);
	            values[2].slice(-1) == "%" && (blue /= 100);
	            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
	            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
	            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
	            return Snap.hsb2rgb(red, green, blue, opacity);
	        }
	        if (rgb[6]) {
	            values = rgb[6].split(commaSpaces);
	            red = toFloat(values[0]);
	            values[0].slice(-1) == "%" && (red /= 100);
	            green = toFloat(values[1]);
	            values[1].slice(-1) == "%" && (green /= 100);
	            blue = toFloat(values[2]);
	            values[2].slice(-1) == "%" && (blue /= 100);
	            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
	            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
	            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
	            return Snap.hsl2rgb(red, green, blue, opacity);
	        }
	        red = mmin(math.round(red), 255);
	        green = mmin(math.round(green), 255);
	        blue = mmin(math.round(blue), 255);
	        opacity = mmin(mmax(opacity, 0), 1);
	        rgb = {r: red, g: green, b: blue, toString: rgbtoString};
	        rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
	        rgb.opacity = is(opacity, "finite") ? opacity : 1;
	        return rgb;
	    }
	    return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
	}, Snap);
	/*\
	 * Snap.hsb
	 [ method ]
	 **
	 * Converts HSB values to a hex representation of the color
	 - h (number) hue
	 - s (number) saturation
	 - b (number) value or brightness
	 = (string) hex representation of the color
	\*/
	Snap.hsb = cacher(function (h, s, b) {
	    return Snap.hsb2rgb(h, s, b).hex;
	});
	/*\
	 * Snap.hsl
	 [ method ]
	 **
	 * Converts HSL values to a hex representation of the color
	 - h (number) hue
	 - s (number) saturation
	 - l (number) luminosity
	 = (string) hex representation of the color
	\*/
	Snap.hsl = cacher(function (h, s, l) {
	    return Snap.hsl2rgb(h, s, l).hex;
	});
	/*\
	 * Snap.rgb
	 [ method ]
	 **
	 * Converts RGB values to a hex representation of the color
	 - r (number) red
	 - g (number) green
	 - b (number) blue
	 = (string) hex representation of the color
	\*/
	Snap.rgb = cacher(function (r, g, b, o) {
	    if (is(o, "finite")) {
	        var round = math.round;
	        return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
	    }
	    return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
	});
	var toHex = function (color) {
	    var i = glob.doc.getElementsByTagName("head")[0] || glob.doc.getElementsByTagName("svg")[0],
	        red = "rgb(255, 0, 0)";
	    toHex = cacher(function (color) {
	        if (color.toLowerCase() == "red") {
	            return red;
	        }
	        i.style.color = red;
	        i.style.color = color;
	        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
	        return out == red ? null : out;
	    });
	    return toHex(color);
	},
	hsbtoString = function () {
	    return "hsb(" + [this.h, this.s, this.b] + ")";
	},
	hsltoString = function () {
	    return "hsl(" + [this.h, this.s, this.l] + ")";
	},
	rgbtoString = function () {
	    return this.opacity == 1 || this.opacity == null ?
	            this.hex :
	            "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
	},
	prepareRGB = function (r, g, b) {
	    if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
	        b = r.b;
	        g = r.g;
	        r = r.r;
	    }
	    if (g == null && is(r, string)) {
	        var clr = Snap.getRGB(r);
	        r = clr.r;
	        g = clr.g;
	        b = clr.b;
	    }
	    if (r > 1 || g > 1 || b > 1) {
	        r /= 255;
	        g /= 255;
	        b /= 255;
	    }
	    
	    return [r, g, b];
	},
	packageRGB = function (r, g, b, o) {
	    r = math.round(r * 255);
	    g = math.round(g * 255);
	    b = math.round(b * 255);
	    var rgb = {
	        r: r,
	        g: g,
	        b: b,
	        opacity: is(o, "finite") ? o : 1,
	        hex: Snap.rgb(r, g, b),
	        toString: rgbtoString
	    };
	    is(o, "finite") && (rgb.opacity = o);
	    return rgb;
	};
	/*\
	 * Snap.color
	 [ method ]
	 **
	 * Parses the color string and returns an object featuring the color's component values
	 - clr (string) color string in one of the supported formats (see @Snap.getRGB)
	 = (object) Combined RGB/HSB object in the following format:
	 o {
	 o     r (number) red,
	 o     g (number) green,
	 o     b (number) blue,
	 o     hex (string) color in HTML/CSS format: #••••••,
	 o     error (boolean) `true` if string can't be parsed,
	 o     h (number) hue,
	 o     s (number) saturation,
	 o     v (number) value (brightness),
	 o     l (number) lightness
	 o }
	\*/
	Snap.color = function (clr) {
	    var rgb;
	    if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
	        rgb = Snap.hsb2rgb(clr);
	        clr.r = rgb.r;
	        clr.g = rgb.g;
	        clr.b = rgb.b;
	        clr.opacity = 1;
	        clr.hex = rgb.hex;
	    } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
	        rgb = Snap.hsl2rgb(clr);
	        clr.r = rgb.r;
	        clr.g = rgb.g;
	        clr.b = rgb.b;
	        clr.opacity = 1;
	        clr.hex = rgb.hex;
	    } else {
	        if (is(clr, "string")) {
	            clr = Snap.getRGB(clr);
	        }
	        if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
	            rgb = Snap.rgb2hsl(clr);
	            clr.h = rgb.h;
	            clr.s = rgb.s;
	            clr.l = rgb.l;
	            rgb = Snap.rgb2hsb(clr);
	            clr.v = rgb.b;
	        } else {
	            clr = {hex: "none"};
	            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
	            clr.error = 1;
	        }
	    }
	    clr.toString = rgbtoString;
	    return clr;
	};
	/*\
	 * Snap.hsb2rgb
	 [ method ]
	 **
	 * Converts HSB values to an RGB object
	 - h (number) hue
	 - s (number) saturation
	 - v (number) value or brightness
	 = (object) RGB object in the following format:
	 o {
	 o     r (number) red,
	 o     g (number) green,
	 o     b (number) blue,
	 o     hex (string) color in HTML/CSS format: #••••••
	 o }
	\*/
	Snap.hsb2rgb = function (h, s, v, o) {
	    if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
	        v = h.b;
	        s = h.s;
	        o = h.o;
	        h = h.h;
	    }
	    h *= 360;
	    var R, G, B, X, C;
	    h = (h % 360) / 60;
	    C = v * s;
	    X = C * (1 - abs(h % 2 - 1));
	    R = G = B = v - C;

	    h = ~~h;
	    R += [C, X, 0, 0, X, C][h];
	    G += [X, C, C, X, 0, 0][h];
	    B += [0, 0, X, C, C, X][h];
	    return packageRGB(R, G, B, o);
	};
	/*\
	 * Snap.hsl2rgb
	 [ method ]
	 **
	 * Converts HSL values to an RGB object
	 - h (number) hue
	 - s (number) saturation
	 - l (number) luminosity
	 = (object) RGB object in the following format:
	 o {
	 o     r (number) red,
	 o     g (number) green,
	 o     b (number) blue,
	 o     hex (string) color in HTML/CSS format: #••••••
	 o }
	\*/
	Snap.hsl2rgb = function (h, s, l, o) {
	    if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
	        l = h.l;
	        s = h.s;
	        h = h.h;
	    }
	    if (h > 1 || s > 1 || l > 1) {
	        h /= 360;
	        s /= 100;
	        l /= 100;
	    }
	    h *= 360;
	    var R, G, B, X, C;
	    h = (h % 360) / 60;
	    C = 2 * s * (l < .5 ? l : 1 - l);
	    X = C * (1 - abs(h % 2 - 1));
	    R = G = B = l - C / 2;

	    h = ~~h;
	    R += [C, X, 0, 0, X, C][h];
	    G += [X, C, C, X, 0, 0][h];
	    B += [0, 0, X, C, C, X][h];
	    return packageRGB(R, G, B, o);
	};
	/*\
	 * Snap.rgb2hsb
	 [ method ]
	 **
	 * Converts RGB values to an HSB object
	 - r (number) red
	 - g (number) green
	 - b (number) blue
	 = (object) HSB object in the following format:
	 o {
	 o     h (number) hue,
	 o     s (number) saturation,
	 o     b (number) brightness
	 o }
	\*/
	Snap.rgb2hsb = function (r, g, b) {
	    b = prepareRGB(r, g, b);
	    r = b[0];
	    g = b[1];
	    b = b[2];

	    var H, S, V, C;
	    V = mmax(r, g, b);
	    C = V - mmin(r, g, b);
	    H = (C == 0 ? null :
	         V == r ? (g - b) / C :
	         V == g ? (b - r) / C + 2 :
	                  (r - g) / C + 4
	        );
	    H = ((H + 360) % 6) * 60 / 360;
	    S = C == 0 ? 0 : C / V;
	    return {h: H, s: S, b: V, toString: hsbtoString};
	};
	/*\
	 * Snap.rgb2hsl
	 [ method ]
	 **
	 * Converts RGB values to an HSL object
	 - r (number) red
	 - g (number) green
	 - b (number) blue
	 = (object) HSL object in the following format:
	 o {
	 o     h (number) hue,
	 o     s (number) saturation,
	 o     l (number) luminosity
	 o }
	\*/
	Snap.rgb2hsl = function (r, g, b) {
	    b = prepareRGB(r, g, b);
	    r = b[0];
	    g = b[1];
	    b = b[2];

	    var H, S, L, M, m, C;
	    M = mmax(r, g, b);
	    m = mmin(r, g, b);
	    C = M - m;
	    H = (C == 0 ? null :
	         M == r ? (g - b) / C :
	         M == g ? (b - r) / C + 2 :
	                  (r - g) / C + 4);
	    H = ((H + 360) % 6) * 60 / 360;
	    L = (M + m) / 2;
	    S = (C == 0 ? 0 :
	         L < .5 ? C / (2 * L) :
	                  C / (2 - 2 * L));
	    return {h: H, s: S, l: L, toString: hsltoString};
	};

	// Transformations
	/*\
	 * Snap.parsePathString
	 [ method ]
	 **
	 * Utility method
	 **
	 * Parses given path string into an array of arrays of path segments
	 - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
	 = (array) array of segments
	\*/
	Snap.parsePathString = function (pathString) {
	    if (!pathString) {
	        return null;
	    }
	    var pth = Snap.path(pathString);
	    if (pth.arr) {
	        return Snap.path.clone(pth.arr);
	    }
	    
	    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},
	        data = [];
	    if (is(pathString, "array") && is(pathString[0], "array")) { // rough assumption
	        data = Snap.path.clone(pathString);
	    }
	    if (!data.length) {
	        Str(pathString).replace(pathCommand, function (a, b, c) {
	            var params = [],
	                name = b.toLowerCase();
	            c.replace(pathValues, function (a, b) {
	                b && params.push(+b);
	            });
	            if (name == "m" && params.length > 2) {
	                data.push([b].concat(params.splice(0, 2)));
	                name = "l";
	                b = b == "m" ? "l" : "L";
	            }
	            if (name == "o" && params.length == 1) {
	                data.push([b, params[0]]);
	            }
	            if (name == "r") {
	                data.push([b].concat(params));
	            } else while (params.length >= paramCounts[name]) {
	                data.push([b].concat(params.splice(0, paramCounts[name])));
	                if (!paramCounts[name]) {
	                    break;
	                }
	            }
	        });
	    }
	    data.toString = Snap.path.toString;
	    pth.arr = Snap.path.clone(data);
	    return data;
	};
	/*\
	 * Snap.parseTransformString
	 [ method ]
	 **
	 * Utility method
	 **
	 * Parses given transform string into an array of transformations
	 - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
	 = (array) array of transformations
	\*/
	var parseTransformString = Snap.parseTransformString = function (TString) {
	    if (!TString) {
	        return null;
	    }
	    var paramCounts = {r: 3, s: 4, t: 2, m: 6},
	        data = [];
	    if (is(TString, "array") && is(TString[0], "array")) { // rough assumption
	        data = Snap.path.clone(TString);
	    }
	    if (!data.length) {
	        Str(TString).replace(tCommand, function (a, b, c) {
	            var params = [],
	                name = b.toLowerCase();
	            c.replace(pathValues, function (a, b) {
	                b && params.push(+b);
	            });
	            data.push([b].concat(params));
	        });
	    }
	    data.toString = Snap.path.toString;
	    return data;
	};
	function svgTransform2string(tstr) {
	    var res = [];
	    tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
	        params = params.split(/\s*,\s*|\s+/);
	        if (name == "rotate" && params.length == 1) {
	            params.push(0, 0);
	        }
	        if (name == "scale") {
	            if (params.length > 2) {
	                params = params.slice(0, 2);
	            } else if (params.length == 2) {
	                params.push(0, 0);
	            }
	            if (params.length == 1) {
	                params.push(params[0], 0, 0);
	            }
	        }
	        if (name == "skewX") {
	            res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
	        } else if (name == "skewY") {
	            res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
	        } else {
	            res.push([name.charAt(0)].concat(params));
	        }
	        return all;
	    });
	    return res;
	}
	Snap._.svgTransform2string = svgTransform2string;
	Snap._.rgTransform = /^[a-z][\s]*-?\.?\d/i;
	function transform2matrix(tstr, bbox) {
	    var tdata = parseTransformString(tstr),
	        m = new Snap.Matrix;
	    if (tdata) {
	        for (var i = 0, ii = tdata.length; i < ii; i++) {
	            var t = tdata[i],
	                tlen = t.length,
	                command = Str(t[0]).toLowerCase(),
	                absolute = t[0] != command,
	                inver = absolute ? m.invert() : 0,
	                x1,
	                y1,
	                x2,
	                y2,
	                bb;
	            if (command == "t" && tlen == 2){
	                m.translate(t[1], 0);
	            } else if (command == "t" && tlen == 3) {
	                if (absolute) {
	                    x1 = inver.x(0, 0);
	                    y1 = inver.y(0, 0);
	                    x2 = inver.x(t[1], t[2]);
	                    y2 = inver.y(t[1], t[2]);
	                    m.translate(x2 - x1, y2 - y1);
	                } else {
	                    m.translate(t[1], t[2]);
	                }
	            } else if (command == "r") {
	                if (tlen == 2) {
	                    bb = bb || bbox;
	                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
	                } else if (tlen == 4) {
	                    if (absolute) {
	                        x2 = inver.x(t[2], t[3]);
	                        y2 = inver.y(t[2], t[3]);
	                        m.rotate(t[1], x2, y2);
	                    } else {
	                        m.rotate(t[1], t[2], t[3]);
	                    }
	                }
	            } else if (command == "s") {
	                if (tlen == 2 || tlen == 3) {
	                    bb = bb || bbox;
	                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
	                } else if (tlen == 4) {
	                    if (absolute) {
	                        x2 = inver.x(t[2], t[3]);
	                        y2 = inver.y(t[2], t[3]);
	                        m.scale(t[1], t[1], x2, y2);
	                    } else {
	                        m.scale(t[1], t[1], t[2], t[3]);
	                    }
	                } else if (tlen == 5) {
	                    if (absolute) {
	                        x2 = inver.x(t[3], t[4]);
	                        y2 = inver.y(t[3], t[4]);
	                        m.scale(t[1], t[2], x2, y2);
	                    } else {
	                        m.scale(t[1], t[2], t[3], t[4]);
	                    }
	                }
	            } else if (command == "m" && tlen == 7) {
	                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
	            }
	        }
	    }
	    return m;
	}
	Snap._.transform2matrix = transform2matrix;
	Snap._unit2px = unit2px;
	var contains = glob.doc.contains || glob.doc.compareDocumentPosition ?
	    function (a, b) {
	        var adown = a.nodeType == 9 ? a.documentElement : a,
	            bup = b && b.parentNode;
	            return a == bup || !!(bup && bup.nodeType == 1 && (
	                adown.contains ?
	                    adown.contains(bup) :
	                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
	            ));
	    } :
	    function (a, b) {
	        if (b) {
	            while (b) {
	                b = b.parentNode;
	                if (b == a) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	function getSomeDefs(el) {
	    var p = (el.node.ownerSVGElement && wrap(el.node.ownerSVGElement)) ||
	            (el.node.parentNode && wrap(el.node.parentNode)) ||
	            Snap.select("svg") ||
	            Snap(0, 0),
	        pdefs = p.select("defs"),
	        defs  = pdefs == null ? false : pdefs.node;
	    if (!defs) {
	        defs = make("defs", p.node).node;
	    }
	    return defs;
	}
	function getSomeSVG(el) {
	    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select("svg");
	}
	Snap._.getSomeDefs = getSomeDefs;
	Snap._.getSomeSVG = getSomeSVG;
	function unit2px(el, name, value) {
	    var svg = getSomeSVG(el).node,
	        out = {},
	        mgr = svg.querySelector(".svg---mgr");
	    if (!mgr) {
	        mgr = $("rect");
	        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, "class": "svg---mgr", fill: "none"});
	        svg.appendChild(mgr);
	    }
	    function getW(val) {
	        if (val == null) {
	            return E;
	        }
	        if (val == +val) {
	            return val;
	        }
	        $(mgr, {width: val});
	        try {
	            return mgr.getBBox().width;
	        } catch (e) {
	            return 0;
	        }
	    }
	    function getH(val) {
	        if (val == null) {
	            return E;
	        }
	        if (val == +val) {
	            return val;
	        }
	        $(mgr, {height: val});
	        try {
	            return mgr.getBBox().height;
	        } catch (e) {
	            return 0;
	        }
	    }
	    function set(nam, f) {
	        if (name == null) {
	            out[nam] = f(el.attr(nam) || 0);
	        } else if (nam == name) {
	            out = f(value == null ? el.attr(nam) || 0 : value);
	        }
	    }
	    switch (el.type) {
	        case "rect":
	            set("rx", getW);
	            set("ry", getH);
	        case "image":
	            set("width", getW);
	            set("height", getH);
	        case "text":
	            set("x", getW);
	            set("y", getH);
	        break;
	        case "circle":
	            set("cx", getW);
	            set("cy", getH);
	            set("r", getW);
	        break;
	        case "ellipse":
	            set("cx", getW);
	            set("cy", getH);
	            set("rx", getW);
	            set("ry", getH);
	        break;
	        case "line":
	            set("x1", getW);
	            set("x2", getW);
	            set("y1", getH);
	            set("y2", getH);
	        break;
	        case "marker":
	            set("refX", getW);
	            set("markerWidth", getW);
	            set("refY", getH);
	            set("markerHeight", getH);
	        break;
	        case "radialGradient":
	            set("fx", getW);
	            set("fy", getH);
	        break;
	        case "tspan":
	            set("dx", getW);
	            set("dy", getH);
	        break;
	        default:
	            set(name, getW);
	    }
	    svg.removeChild(mgr);
	    return out;
	}
	/*\
	 * Snap.select
	 [ method ]
	 **
	 * Wraps a DOM element specified by CSS selector as @Element
	 - query (string) CSS selector of the element
	 = (Element) the current element
	\*/
	Snap.select = function (query) {
	    query = Str(query).replace(/([^\\]):/g, "$1\\:");
	    return wrap(glob.doc.querySelector(query));
	};
	/*\
	 * Snap.selectAll
	 [ method ]
	 **
	 * Wraps DOM elements specified by CSS selector as set or array of @Element
	 - query (string) CSS selector of the element
	 = (Element) the current element
	\*/
	Snap.selectAll = function (query) {
	    var nodelist = glob.doc.querySelectorAll(query),
	        set = (Snap.set || Array)();
	    for (var i = 0; i < nodelist.length; i++) {
	        set.push(wrap(nodelist[i]));
	    }
	    return set;
	};

	function add2group(list) {
	    if (!is(list, "array")) {
	        list = Array.prototype.slice.call(arguments, 0);
	    }
	    var i = 0,
	        j = 0,
	        node = this.node;
	    while (this[i]) delete this[i++];
	    for (i = 0; i < list.length; i++) {
	        if (list[i].type == "set") {
	            list[i].forEach(function (el) {
	                node.appendChild(el.node);
	            });
	        } else {
	            node.appendChild(list[i].node);
	        }
	    }
	    var children = node.childNodes;
	    for (i = 0; i < children.length; i++) {
	        this[j++] = wrap(children[i]);
	    }
	    return this;
	}
	// Hub garbage collector every 10s
	setInterval(function () {
	    for (var key in hub) if (hub[has](key)) {
	        var el = hub[key],
	            node = el.node;
	        if (el.type != "svg" && !node.ownerSVGElement || el.type == "svg" && (!node.parentNode || "ownerSVGElement" in node.parentNode && !node.ownerSVGElement)) {
	            delete hub[key];
	        }
	    }
	}, 1e4);
	function Element(el) {
	    if (el.snap in hub) {
	        return hub[el.snap];
	    }
	    var svg;
	    try {
	        svg = el.ownerSVGElement;
	    } catch(e) {}
	    /*\
	     * Element.node
	     [ property (object) ]
	     **
	     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
	     > Usage
	     | // draw a circle at coordinate 10,10 with radius of 10
	     | var c = paper.circle(10, 10, 10);
	     | c.node.onclick = function () {
	     |     c.attr("fill", "red");
	     | };
	    \*/
	    this.node = el;
	    if (svg) {
	        this.paper = new Paper(svg);
	    }
	    /*\
	     * Element.type
	     [ property (string) ]
	     **
	     * SVG tag name of the given element.
	    \*/
	    this.type = el.tagName || el.nodeName;
	    var id = this.id = ID(this);
	    this.anims = {};
	    this._ = {
	        transform: []
	    };
	    el.snap = id;
	    hub[id] = this;
	    if (this.type == "g") {
	        this.add = add2group;
	    }
	    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {
	        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {
	            this[method] = Paper.prototype[method];
	        }
	    }
	}
	   /*\
	     * Element.attr
	     [ method ]
	     **
	     * Gets or sets given attributes of the element.
	     **
	     - params (object) contains key-value pairs of attributes you want to set
	     * or
	     - param (string) name of the attribute
	     = (Element) the current element
	     * or
	     = (string) value of attribute
	     > Usage
	     | el.attr({
	     |     fill: "#fc0",
	     |     stroke: "#000",
	     |     strokeWidth: 2, // CamelCase...
	     |     "fill-opacity": 0.5, // or dash-separated names
	     |     width: "*=2" // prefixed values
	     | });
	     | console.log(el.attr("fill")); // #fc0
	     * Prefixed values in format `"+=10"` supported. All four operations
	     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`
	     * and `-`: `"+=2em"`.
	    \*/
	    Element.prototype.attr = function (params, value) {
	        var el = this,
	            node = el.node;
	        if (!params) {
	            if (node.nodeType != 1) {
	                return {
	                    text: node.nodeValue
	                };
	            }
	            var attr = node.attributes,
	                out = {};
	            for (var i = 0, ii = attr.length; i < ii; i++) {
	                out[attr[i].nodeName] = attr[i].nodeValue;
	            }
	            return out;
	        }
	        if (is(params, "string")) {
	            if (arguments.length > 1) {
	                var json = {};
	                json[params] = value;
	                params = json;
	            } else {
	                return eve("snap.util.getattr." + params, el).firstDefined();
	            }
	        }
	        for (var att in params) {
	            if (params[has](att)) {
	                eve("snap.util.attr." + att, el, params[att]);
	            }
	        }
	        return el;
	    };
	/*\
	 * Snap.parse
	 [ method ]
	 **
	 * Parses SVG fragment and converts it into a @Fragment
	 **
	 - svg (string) SVG string
	 = (Fragment) the @Fragment
	\*/
	Snap.parse = function (svg) {
	    var f = glob.doc.createDocumentFragment(),
	        full = true,
	        div = glob.doc.createElement("div");
	    svg = Str(svg);
	    if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
	        svg = "<svg>" + svg + "</svg>";
	        full = false;
	    }
	    div.innerHTML = svg;
	    svg = div.getElementsByTagName("svg")[0];
	    if (svg) {
	        if (full) {
	            f = svg;
	        } else {
	            while (svg.firstChild) {
	                f.appendChild(svg.firstChild);
	            }
	        }
	    }
	    return new Fragment(f);
	};
	function Fragment(frag) {
	    this.node = frag;
	}
	/*\
	 * Snap.fragment
	 [ method ]
	 **
	 * Creates a DOM fragment from a given list of elements or strings
	 **
	 - varargs (…) SVG string
	 = (Fragment) the @Fragment
	\*/
	Snap.fragment = function () {
	    var args = Array.prototype.slice.call(arguments, 0),
	        f = glob.doc.createDocumentFragment();
	    for (var i = 0, ii = args.length; i < ii; i++) {
	        var item = args[i];
	        if (item.node && item.node.nodeType) {
	            f.appendChild(item.node);
	        }
	        if (item.nodeType) {
	            f.appendChild(item);
	        }
	        if (typeof item == "string") {
	            f.appendChild(Snap.parse(item).node);
	        }
	    }
	    return new Fragment(f);
	};

	function make(name, parent) {
	    var res = $(name);
	    parent.appendChild(res);
	    var el = wrap(res);
	    return el;
	}
	function Paper(w, h) {
	    var res,
	        desc,
	        defs,
	        proto = Paper.prototype;
	    if (w && w.tagName == "svg") {
	        if (w.snap in hub) {
	            return hub[w.snap];
	        }
	        var doc = w.ownerDocument;
	        res = new Element(w);
	        desc = w.getElementsByTagName("desc")[0];
	        defs = w.getElementsByTagName("defs")[0];
	        if (!desc) {
	            desc = $("desc");
	            desc.appendChild(doc.createTextNode("Created with Snap"));
	            res.node.appendChild(desc);
	        }
	        if (!defs) {
	            defs = $("defs");
	            res.node.appendChild(defs);
	        }
	        res.defs = defs;
	        for (var key in proto) if (proto[has](key)) {
	            res[key] = proto[key];
	        }
	        res.paper = res.root = res;
	    } else {
	        res = make("svg", glob.doc.body);
	        $(res.node, {
	            height: h,
	            version: 1.1,
	            width: w,
	            xmlns: xmlns
	        });
	    }
	    return res;
	}
	function wrap(dom) {
	    if (!dom) {
	        return dom;
	    }
	    if (dom instanceof Element || dom instanceof Fragment) {
	        return dom;
	    }
	    if (dom.tagName && dom.tagName.toLowerCase() == "svg") {
	        return new Paper(dom);
	    }
	    if (dom.tagName && dom.tagName.toLowerCase() == "object" && dom.type == "image/svg+xml") {
	        return new Paper(dom.contentDocument.getElementsByTagName("svg")[0]);
	    }
	    return new Element(dom);
	}

	Snap._.make = make;
	Snap._.wrap = wrap;
	/*\
	 * Paper.el
	 [ method ]
	 **
	 * Creates an element on paper with a given name and no attributes
	 **
	 - name (string) tag name
	 - attr (object) attributes
	 = (Element) the current element
	 > Usage
	 | var c = paper.circle(10, 10, 10); // is the same as...
	 | var c = paper.el("circle").attr({
	 |     cx: 10,
	 |     cy: 10,
	 |     r: 10
	 | });
	 | // and the same as
	 | var c = paper.el("circle", {
	 |     cx: 10,
	 |     cy: 10,
	 |     r: 10
	 | });
	\*/
	Paper.prototype.el = function (name, attr) {
	    var el = make(name, this.node);
	    attr && el.attr(attr);
	    return el;
	};
	/*\
	 * Element.children
	 [ method ]
	 **
	 * Returns array of all the children of the element.
	 = (array) array of Elements
	\*/
	Element.prototype.children = function () {
	    var out = [],
	        ch = this.node.childNodes;
	    for (var i = 0, ii = ch.length; i < ii; i++) {
	        out[i] = Snap(ch[i]);
	    }
	    return out;
	};
	function jsonFiller(root, o) {
	    for (var i = 0, ii = root.length; i < ii; i++) {
	        var item = {
	                type: root[i].type,
	                attr: root[i].attr()
	            },
	            children = root[i].children();
	        o.push(item);
	        if (children.length) {
	            jsonFiller(children, item.childNodes = []);
	        }
	    }
	}
	/*\
	 * Element.toJSON
	 [ method ]
	 **
	 * Returns object representation of the given element and all its children.
	 = (object) in format
	 o {
	 o     type (string) this.type,
	 o     attr (object) attributes map,
	 o     childNodes (array) optional array of children in the same format
	 o }
	\*/
	Element.prototype.toJSON = function () {
	    var out = [];
	    jsonFiller([this], out);
	    return out[0];
	};
	// default
	eve.on("snap.util.getattr", function () {
	    var att = eve.nt();
	    att = att.substring(att.lastIndexOf(".") + 1);
	    var css = att.replace(/[A-Z]/g, function (letter) {
	        return "-" + letter.toLowerCase();
	    });
	    if (cssAttr[has](css)) {
	        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
	    } else {
	        return $(this.node, att);
	    }
	});
	var cssAttr = {
	    "alignment-baseline": 0,
	    "baseline-shift": 0,
	    "clip": 0,
	    "clip-path": 0,
	    "clip-rule": 0,
	    "color": 0,
	    "color-interpolation": 0,
	    "color-interpolation-filters": 0,
	    "color-profile": 0,
	    "color-rendering": 0,
	    "cursor": 0,
	    "direction": 0,
	    "display": 0,
	    "dominant-baseline": 0,
	    "enable-background": 0,
	    "fill": 0,
	    "fill-opacity": 0,
	    "fill-rule": 0,
	    "filter": 0,
	    "flood-color": 0,
	    "flood-opacity": 0,
	    "font": 0,
	    "font-family": 0,
	    "font-size": 0,
	    "font-size-adjust": 0,
	    "font-stretch": 0,
	    "font-style": 0,
	    "font-variant": 0,
	    "font-weight": 0,
	    "glyph-orientation-horizontal": 0,
	    "glyph-orientation-vertical": 0,
	    "image-rendering": 0,
	    "kerning": 0,
	    "letter-spacing": 0,
	    "lighting-color": 0,
	    "marker": 0,
	    "marker-end": 0,
	    "marker-mid": 0,
	    "marker-start": 0,
	    "mask": 0,
	    "opacity": 0,
	    "overflow": 0,
	    "pointer-events": 0,
	    "shape-rendering": 0,
	    "stop-color": 0,
	    "stop-opacity": 0,
	    "stroke": 0,
	    "stroke-dasharray": 0,
	    "stroke-dashoffset": 0,
	    "stroke-linecap": 0,
	    "stroke-linejoin": 0,
	    "stroke-miterlimit": 0,
	    "stroke-opacity": 0,
	    "stroke-width": 0,
	    "text-anchor": 0,
	    "text-decoration": 0,
	    "text-rendering": 0,
	    "unicode-bidi": 0,
	    "visibility": 0,
	    "word-spacing": 0,
	    "writing-mode": 0
	};

	eve.on("snap.util.attr", function (value) {
	    var att = eve.nt(),
	        attr = {};
	    att = att.substring(att.lastIndexOf(".") + 1);
	    attr[att] = value;
	    var style = att.replace(/-(\w)/gi, function (all, letter) {
	            return letter.toUpperCase();
	        }),
	        css = att.replace(/[A-Z]/g, function (letter) {
	            return "-" + letter.toLowerCase();
	        });
	    if (cssAttr[has](css)) {
	        this.node.style[style] = value == null ? E : value;
	    } else {
	        $(this.node, attr);
	    }
	});
	(function (proto) {}(Paper.prototype));

	// simple ajax
	/*\
	 * Snap.ajax
	 [ method ]
	 **
	 * Simple implementation of Ajax
	 **
	 - url (string) URL
	 - postData (object|string) data for post request
	 - callback (function) callback
	 - scope (object) #optional scope of callback
	 * or
	 - url (string) URL
	 - callback (function) callback
	 - scope (object) #optional scope of callback
	 = (XMLHttpRequest) the XMLHttpRequest object, just in case
	\*/
	Snap.ajax = function (url, postData, callback, scope){
	    var req = new XMLHttpRequest,
	        id = ID();
	    if (req) {
	        if (is(postData, "function")) {
	            scope = callback;
	            callback = postData;
	            postData = null;
	        } else if (is(postData, "object")) {
	            var pd = [];
	            for (var key in postData) if (postData.hasOwnProperty(key)) {
	                pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
	            }
	            postData = pd.join("&");
	        }
	        req.open((postData ? "POST" : "GET"), url, true);
	        if (postData) {
	            req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
	            req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	        }
	        if (callback) {
	            eve.once("snap.ajax." + id + ".0", callback);
	            eve.once("snap.ajax." + id + ".200", callback);
	            eve.once("snap.ajax." + id + ".304", callback);
	        }
	        req.onreadystatechange = function() {
	            if (req.readyState != 4) return;
	            eve("snap.ajax." + id + "." + req.status, scope, req);
	        };
	        if (req.readyState == 4) {
	            return req;
	        }
	        req.send(postData);
	        return req;
	    }
	};
	/*\
	 * Snap.load
	 [ method ]
	 **
	 * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
	 **
	 - url (string) URL
	 - callback (function) callback
	 - scope (object) #optional scope of callback
	\*/
	Snap.load = function (url, callback, scope) {
	    Snap.ajax(url, function (req) {
	        var f = Snap.parse(req.responseText);
	        scope ? callback.call(scope, f) : callback(f);
	    });
	};
	var getOffset = function (elem) {
	    var box = elem.getBoundingClientRect(),
	        doc = elem.ownerDocument,
	        body = doc.body,
	        docElem = doc.documentElement,
	        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
	        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
	        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
	    return {
	        y: top,
	        x: left
	    };
	};
	/*\
	 * Snap.getElementByPoint
	 [ method ]
	 **
	 * Returns you topmost element under given point.
	 **
	 = (object) Snap element object
	 - x (number) x coordinate from the top left corner of the window
	 - y (number) y coordinate from the top left corner of the window
	 > Usage
	 | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
	\*/
	Snap.getElementByPoint = function (x, y) {
	    var paper = this,
	        svg = paper.canvas,
	        target = glob.doc.elementFromPoint(x, y);
	    if (glob.win.opera && target.tagName == "svg") {
	        var so = getOffset(target),
	            sr = target.createSVGRect();
	        sr.x = x - so.x;
	        sr.y = y - so.y;
	        sr.width = sr.height = 1;
	        var hits = target.getIntersectionList(sr, null);
	        if (hits.length) {
	            target = hits[hits.length - 1];
	        }
	    }
	    if (!target) {
	        return null;
	    }
	    return wrap(target);
	};
	/*\
	 * Snap.plugin
	 [ method ]
	 **
	 * Let you write plugins. You pass in a function with five arguments, like this:
	 | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {
	 |     Snap.newmethod = function () {};
	 |     Element.prototype.newmethod = function () {};
	 |     Paper.prototype.newmethod = function () {};
	 | });
	 * Inside the function you have access to all main objects (and their
	 * prototypes). This allow you to extend anything you want.
	 **
	 - f (function) your plugin body
	\*/
	Snap.plugin = function (f) {
	    f(Snap, Element, Paper, glob, Fragment);
	};
	glob.win.Snap = Snap;
	return Snap;
	}(window || this));

	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var elproto = Element.prototype,
	        is = Snap.is,
	        Str = String,
	        unit2px = Snap._unit2px,
	        $ = Snap._.$,
	        make = Snap._.make,
	        getSomeDefs = Snap._.getSomeDefs,
	        has = "hasOwnProperty",
	        wrap = Snap._.wrap;
	    /*\
	     * Element.getBBox
	     [ method ]
	     **
	     * Returns the bounding box descriptor for the given element
	     **
	     = (object) bounding box descriptor:
	     o {
	     o     cx: (number) x of the center,
	     o     cy: (number) x of the center,
	     o     h: (number) height,
	     o     height: (number) height,
	     o     path: (string) path command for the box,
	     o     r0: (number) radius of a circle that fully encloses the box,
	     o     r1: (number) radius of the smallest circle that can be enclosed,
	     o     r2: (number) radius of the largest circle that can be enclosed,
	     o     vb: (string) box as a viewbox command,
	     o     w: (number) width,
	     o     width: (number) width,
	     o     x2: (number) x of the right side,
	     o     x: (number) x of the left side,
	     o     y2: (number) y of the bottom edge,
	     o     y: (number) y of the top edge
	     o }
	    \*/
	    elproto.getBBox = function (isWithoutTransform) {
	        if (!Snap.Matrix || !Snap.path) {
	            return this.node.getBBox();
	        }
	        var el = this,
	            m = new Snap.Matrix;
	        if (el.removed) {
	            return Snap._.box();
	        }
	        while (el.type == "use") {
	            if (!isWithoutTransform) {
	                m = m.add(el.transform().localMatrix.translate(el.attr("x") || 0, el.attr("y") || 0));
	            }
	            if (el.original) {
	                el = el.original;
	            } else {
	                var href = el.attr("xlink:href");
	                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf("#") + 1));
	            }
	        }
	        var _ = el._,
	            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;
	        try {
	            if (isWithoutTransform) {
	                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());
	                return Snap._.box(_.bboxwt);
	            } else {
	                el.realPath = pathfinder(el);
	                el.matrix = el.transform().localMatrix;
	                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));
	                return Snap._.box(_.bbox);
	            }
	        } catch (e) {
	            // Firefox doesn’t give you bbox of hidden element
	            return Snap._.box();
	        }
	    };
	    var propString = function () {
	        return this.string;
	    };
	    function extractTransform(el, tstr) {
	        if (tstr == null) {
	            var doReturn = true;
	            if (el.type == "linearGradient" || el.type == "radialGradient") {
	                tstr = el.node.getAttribute("gradientTransform");
	            } else if (el.type == "pattern") {
	                tstr = el.node.getAttribute("patternTransform");
	            } else {
	                tstr = el.node.getAttribute("transform");
	            }
	            if (!tstr) {
	                return new Snap.Matrix;
	            }
	            tstr = Snap._.svgTransform2string(tstr);
	        } else {
	            if (!Snap._.rgTransform.test(tstr)) {
	                tstr = Snap._.svgTransform2string(tstr);
	            } else {
	                tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
	            }
	            if (is(tstr, "array")) {
	                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
	            }
	            el._.transform = tstr;
	        }
	        var m = Snap._.transform2matrix(tstr, el.getBBox(1));
	        if (doReturn) {
	            return m;
	        } else {
	            el.matrix = m;
	        }
	    }
	    /*\
	     * Element.transform
	     [ method ]
	     **
	     * Gets or sets transformation of the element
	     **
	     - tstr (string) transform string in Snap or SVG format
	     = (Element) the current element
	     * or
	     = (object) transformation descriptor:
	     o {
	     o     string (string) transform string,
	     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
	     o     localMatrix (Matrix) matrix of transformations applied only to the element,
	     o     diffMatrix (Matrix) matrix of difference between global and local transformations,
	     o     global (string) global transformation as string,
	     o     local (string) local transformation as string,
	     o     toString (function) returns `string` property
	     o }
	    \*/
	    elproto.transform = function (tstr) {
	        var _ = this._;
	        if (tstr == null) {
	            var papa = this,
	                global = new Snap.Matrix(this.node.getCTM()),
	                local = extractTransform(this),
	                ms = [local],
	                m = new Snap.Matrix,
	                i,
	                localString = local.toTransformString(),
	                string = Str(local) == Str(this.matrix) ?
	                            Str(_.transform) : localString;
	            while (papa.type != "svg" && (papa = papa.parent())) {
	                ms.push(extractTransform(papa));
	            }
	            i = ms.length;
	            while (i--) {
	                m.add(ms[i]);
	            }
	            return {
	                string: string,
	                globalMatrix: global,
	                totalMatrix: m,
	                localMatrix: local,
	                diffMatrix: global.clone().add(local.invert()),
	                global: global.toTransformString(),
	                total: m.toTransformString(),
	                local: localString,
	                toString: propString
	            };
	        }
	        if (tstr instanceof Snap.Matrix) {
	            this.matrix = tstr;
	            this._.transform = tstr.toTransformString();
	        } else {
	            extractTransform(this, tstr);
	        }

	        if (this.node) {
	            if (this.type == "linearGradient" || this.type == "radialGradient") {
	                $(this.node, {gradientTransform: this.matrix});
	            } else if (this.type == "pattern") {
	                $(this.node, {patternTransform: this.matrix});
	            } else {
	                $(this.node, {transform: this.matrix});
	            }
	        }

	        return this;
	    };
	    /*\
	     * Element.parent
	     [ method ]
	     **
	     * Returns the element's parent
	     **
	     = (Element) the parent element
	    \*/
	    elproto.parent = function () {
	        return wrap(this.node.parentNode);
	    };
	    /*\
	     * Element.append
	     [ method ]
	     **
	     * Appends the given element to current one
	     **
	     - el (Element|Set) element to append
	     = (Element) the parent element
	    \*/
	    /*\
	     * Element.add
	     [ method ]
	     **
	     * See @Element.append
	    \*/
	    elproto.append = elproto.add = function (el) {
	        if (el) {
	            if (el.type == "set") {
	                var it = this;
	                el.forEach(function (el) {
	                    it.add(el);
	                });
	                return this;
	            }
	            el = wrap(el);
	            this.node.appendChild(el.node);
	            el.paper = this.paper;
	        }
	        return this;
	    };
	    /*\
	     * Element.appendTo
	     [ method ]
	     **
	     * Appends the current element to the given one
	     **
	     - el (Element) parent element to append to
	     = (Element) the child element
	    \*/
	    elproto.appendTo = function (el) {
	        if (el) {
	            el = wrap(el);
	            el.append(this);
	        }
	        return this;
	    };
	    /*\
	     * Element.prepend
	     [ method ]
	     **
	     * Prepends the given element to the current one
	     **
	     - el (Element) element to prepend
	     = (Element) the parent element
	    \*/
	    elproto.prepend = function (el) {
	        if (el) {
	            if (el.type == "set") {
	                var it = this,
	                    first;
	                el.forEach(function (el) {
	                    if (first) {
	                        first.after(el);
	                    } else {
	                        it.prepend(el);
	                    }
	                    first = el;
	                });
	                return this;
	            }
	            el = wrap(el);
	            var parent = el.parent();
	            this.node.insertBefore(el.node, this.node.firstChild);
	            this.add && this.add();
	            el.paper = this.paper;
	            this.parent() && this.parent().add();
	            parent && parent.add();
	        }
	        return this;
	    };
	    /*\
	     * Element.prependTo
	     [ method ]
	     **
	     * Prepends the current element to the given one
	     **
	     - el (Element) parent element to prepend to
	     = (Element) the child element
	    \*/
	    elproto.prependTo = function (el) {
	        el = wrap(el);
	        el.prepend(this);
	        return this;
	    };
	    /*\
	     * Element.before
	     [ method ]
	     **
	     * Inserts given element before the current one
	     **
	     - el (Element) element to insert
	     = (Element) the parent element
	    \*/
	    elproto.before = function (el) {
	        if (el.type == "set") {
	            var it = this;
	            el.forEach(function (el) {
	                var parent = el.parent();
	                it.node.parentNode.insertBefore(el.node, it.node);
	                parent && parent.add();
	            });
	            this.parent().add();
	            return this;
	        }
	        el = wrap(el);
	        var parent = el.parent();
	        this.node.parentNode.insertBefore(el.node, this.node);
	        this.parent() && this.parent().add();
	        parent && parent.add();
	        el.paper = this.paper;
	        return this;
	    };
	    /*\
	     * Element.after
	     [ method ]
	     **
	     * Inserts given element after the current one
	     **
	     - el (Element) element to insert
	     = (Element) the parent element
	    \*/
	    elproto.after = function (el) {
	        el = wrap(el);
	        var parent = el.parent();
	        if (this.node.nextSibling) {
	            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
	        } else {
	            this.node.parentNode.appendChild(el.node);
	        }
	        this.parent() && this.parent().add();
	        parent && parent.add();
	        el.paper = this.paper;
	        return this;
	    };
	    /*\
	     * Element.insertBefore
	     [ method ]
	     **
	     * Inserts the element after the given one
	     **
	     - el (Element) element next to whom insert to
	     = (Element) the parent element
	    \*/
	    elproto.insertBefore = function (el) {
	        el = wrap(el);
	        var parent = this.parent();
	        el.node.parentNode.insertBefore(this.node, el.node);
	        this.paper = el.paper;
	        parent && parent.add();
	        el.parent() && el.parent().add();
	        return this;
	    };
	    /*\
	     * Element.insertAfter
	     [ method ]
	     **
	     * Inserts the element after the given one
	     **
	     - el (Element) element next to whom insert to
	     = (Element) the parent element
	    \*/
	    elproto.insertAfter = function (el) {
	        el = wrap(el);
	        var parent = this.parent();
	        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
	        this.paper = el.paper;
	        parent && parent.add();
	        el.parent() && el.parent().add();
	        return this;
	    };
	    /*\
	     * Element.remove
	     [ method ]
	     **
	     * Removes element from the DOM
	     = (Element) the detached element
	    \*/
	    elproto.remove = function () {
	        var parent = this.parent();
	        this.node.parentNode && this.node.parentNode.removeChild(this.node);
	        delete this.paper;
	        this.removed = true;
	        parent && parent.add();
	        return this;
	    };
	    /*\
	     * Element.select
	     [ method ]
	     **
	     * Gathers the nested @Element matching the given set of CSS selectors
	     **
	     - query (string) CSS selector
	     = (Element) result of query selection
	    \*/
	    elproto.select = function (query) {
	        query = Str(query).replace(/([^\\]):/g, "$1\\:");
	        return wrap(this.node.querySelector(query));
	    };
	    /*\
	     * Element.selectAll
	     [ method ]
	     **
	     * Gathers nested @Element objects matching the given set of CSS selectors
	     **
	     - query (string) CSS selector
	     = (Set|array) result of query selection
	    \*/
	    elproto.selectAll = function (query) {
	        var nodelist = this.node.querySelectorAll(query),
	            set = (Snap.set || Array)();
	        for (var i = 0; i < nodelist.length; i++) {
	            set.push(wrap(nodelist[i]));
	        }
	        return set;
	    };
	    /*\
	     * Element.asPX
	     [ method ]
	     **
	     * Returns given attribute of the element as a `px` value (not %, em, etc.)
	     **
	     - attr (string) attribute name
	     - value (string) #optional attribute value
	     = (Element) result of query selection
	    \*/
	    elproto.asPX = function (attr, value) {
	        if (value == null) {
	            value = this.attr(attr);
	        }
	        return +unit2px(this, attr, value);
	    };
	    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
	    /*\
	     * Element.use
	     [ method ]
	     **
	     * Creates a `<use>` element linked to the current element
	     **
	     = (Element) the `<use>` element
	    \*/
	    elproto.use = function () {
	        var use,
	            id = this.node.id;
	        if (!id) {
	            id = this.id;
	            $(this.node, {
	                id: id
	            });
	        }
	        if (this.type == "linearGradient" || this.type == "radialGradient" ||
	            this.type == "pattern") {
	            use = make(this.type, this.node.parentNode);
	        } else {
	            use = make("use", this.node.parentNode);
	        }
	        $(use.node, {
	            "xlink:href": "#" + id
	        });
	        use.original = this;
	        return use;
	    };
	    function fixids(el) {
	        var els = el.selectAll("*"),
	            it,
	            url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
	            ids = [],
	            uses = {};
	        function urltest(it, name) {
	            var val = $(it.node, name);
	            val = val && val.match(url);
	            val = val && val[2];
	            if (val && val.charAt() == "#") {
	                val = val.substring(1);
	            } else {
	                return;
	            }
	            if (val) {
	                uses[val] = (uses[val] || []).concat(function (id) {
	                    var attr = {};
	                    attr[name] = URL(id);
	                    $(it.node, attr);
	                });
	            }
	        }
	        function linktest(it) {
	            var val = $(it.node, "xlink:href");
	            if (val && val.charAt() == "#") {
	                val = val.substring(1);
	            } else {
	                return;
	            }
	            if (val) {
	                uses[val] = (uses[val] || []).concat(function (id) {
	                    it.attr("xlink:href", "#" + id);
	                });
	            }
	        }
	        for (var i = 0, ii = els.length; i < ii; i++) {
	            it = els[i];
	            urltest(it, "fill");
	            urltest(it, "stroke");
	            urltest(it, "filter");
	            urltest(it, "mask");
	            urltest(it, "clip-path");
	            linktest(it);
	            var oldid = $(it.node, "id");
	            if (oldid) {
	                $(it.node, {id: it.id});
	                ids.push({
	                    old: oldid,
	                    id: it.id
	                });
	            }
	        }
	        for (i = 0, ii = ids.length; i < ii; i++) {
	            var fs = uses[ids[i].old];
	            if (fs) {
	                for (var j = 0, jj = fs.length; j < jj; j++) {
	                    fs[j](ids[i].id);
	                }
	            }
	        }
	    }
	    /*\
	     * Element.clone
	     [ method ]
	     **
	     * Creates a clone of the element and inserts it after the element
	     **
	     = (Element) the clone
	    \*/
	    elproto.clone = function () {
	        var clone = wrap(this.node.cloneNode(true));
	        if ($(clone.node, "id")) {
	            $(clone.node, {id: clone.id});
	        }
	        fixids(clone);
	        clone.insertAfter(this);
	        return clone;
	    };
	    /*\
	     * Element.toDefs
	     [ method ]
	     **
	     * Moves element to the shared `<defs>` area
	     **
	     = (Element) the element
	    \*/
	    elproto.toDefs = function () {
	        var defs = getSomeDefs(this);
	        defs.appendChild(this.node);
	        return this;
	    };
	    /*\
	     * Element.toPattern
	     [ method ]
	     **
	     * Creates a `<pattern>` element from the current element
	     **
	     * To create a pattern you have to specify the pattern rect:
	     - x (string|number)
	     - y (string|number)
	     - width (string|number)
	     - height (string|number)
	     = (Element) the `<pattern>` element
	     * You can use pattern later on as an argument for `fill` attribute:
	     | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
	     |         fill: "none",
	     |         stroke: "#bada55",
	     |         strokeWidth: 5
	     |     }).pattern(0, 0, 10, 10),
	     |     c = paper.circle(200, 200, 100);
	     | c.attr({
	     |     fill: p
	     | });
	    \*/
	    elproto.pattern = elproto.toPattern = function (x, y, width, height) {
	        var p = make("pattern", getSomeDefs(this));
	        if (x == null) {
	            x = this.getBBox();
	        }
	        if (is(x, "object") && "x" in x) {
	            y = x.y;
	            width = x.width;
	            height = x.height;
	            x = x.x;
	        }
	        $(p.node, {
	            x: x,
	            y: y,
	            width: width,
	            height: height,
	            patternUnits: "userSpaceOnUse",
	            id: p.id,
	            viewBox: [x, y, width, height].join(" ")
	        });
	        p.node.appendChild(this.node);
	        return p;
	    };
	// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
	// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
	    /*\
	     * Element.marker
	     [ method ]
	     **
	     * Creates a `<marker>` element from the current element
	     **
	     * To create a marker you have to specify the bounding rect and reference point:
	     - x (number)
	     - y (number)
	     - width (number)
	     - height (number)
	     - refX (number)
	     - refY (number)
	     = (Element) the `<marker>` element
	     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
	    \*/
	    // TODO add usage for markers
	    elproto.marker = function (x, y, width, height, refX, refY) {
	        var p = make("marker", getSomeDefs(this));
	        if (x == null) {
	            x = this.getBBox();
	        }
	        if (is(x, "object") && "x" in x) {
	            y = x.y;
	            width = x.width;
	            height = x.height;
	            refX = x.refX || x.cx;
	            refY = x.refY || x.cy;
	            x = x.x;
	        }
	        $(p.node, {
	            viewBox: [x, y, width, height].join(" "),
	            markerWidth: width,
	            markerHeight: height,
	            orient: "auto",
	            refX: refX || 0,
	            refY: refY || 0,
	            id: p.id
	        });
	        p.node.appendChild(this.node);
	        return p;
	    };
	    // animation
	    function slice(from, to, f) {
	        return function (arr) {
	            var res = arr.slice(from, to);
	            if (res.length == 1) {
	                res = res[0];
	            }
	            return f ? f(res) : res;
	        };
	    }
	    var Animation = function (attr, ms, easing, callback) {
	        if (typeof easing == "function" && !easing.length) {
	            callback = easing;
	            easing = mina.linear;
	        }
	        this.attr = attr;
	        this.dur = ms;
	        easing && (this.easing = easing);
	        callback && (this.callback = callback);
	    };
	    Snap._.Animation = Animation;
	    /*\
	     * Snap.animation
	     [ method ]
	     **
	     * Creates an animation object
	     **
	     - attr (object) attributes of final destination
	     - duration (number) duration of the animation, in milliseconds
	     - easing (function) #optional one of easing functions of @mina or custom one
	     - callback (function) #optional callback function that fires when animation ends
	     = (object) animation object
	    \*/
	    Snap.animation = function (attr, ms, easing, callback) {
	        return new Animation(attr, ms, easing, callback);
	    };
	    /*\
	     * Element.inAnim
	     [ method ]
	     **
	     * Returns a set of animations that may be able to manipulate the current element
	     **
	     = (object) in format:
	     o {
	     o     anim (object) animation object,
	     o     mina (object) @mina object,
	     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,
	     o     status (function) gets or sets the status of the animation,
	     o     stop (function) stops the animation
	     o }
	    \*/
	    elproto.inAnim = function () {
	        var el = this,
	            res = [];
	        for (var id in el.anims) if (el.anims[has](id)) {
	            (function (a) {
	                res.push({
	                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
	                    mina: a,
	                    curStatus: a.status(),
	                    status: function (val) {
	                        return a.status(val);
	                    },
	                    stop: function () {
	                        a.stop();
	                    }
	                });
	            }(el.anims[id]));
	        }
	        return res;
	    };
	    /*\
	     * Snap.animate
	     [ method ]
	     **
	     * Runs generic animation of one number into another with a caring function
	     **
	     - from (number|array) number or array of numbers
	     - to (number|array) number or array of numbers
	     - setter (function) caring function that accepts one number argument
	     - duration (number) duration, in milliseconds
	     - easing (function) #optional easing function from @mina or custom
	     - callback (function) #optional callback function to execute when animation ends
	     = (object) animation object in @mina format
	     o {
	     o     id (string) animation id, consider it read-only,
	     o     duration (function) gets or sets the duration of the animation,
	     o     easing (function) easing,
	     o     speed (function) gets or sets the speed of the animation,
	     o     status (function) gets or sets the status of the animation,
	     o     stop (function) stops the animation
	     o }
	     | var rect = Snap().rect(0, 0, 10, 10);
	     | Snap.animate(0, 10, function (val) {
	     |     rect.attr({
	     |         x: val
	     |     });
	     | }, 1000);
	     | // in given context is equivalent to
	     | rect.animate({x: 10}, 1000);
	    \*/
	    Snap.animate = function (from, to, setter, ms, easing, callback) {
	        if (typeof easing == "function" && !easing.length) {
	            callback = easing;
	            easing = mina.linear;
	        }
	        var now = mina.time(),
	            anim = mina(from, to, now, now + ms, mina.time, setter, easing);
	        callback && eve.once("mina.finish." + anim.id, callback);
	        return anim;
	    };
	    /*\
	     * Element.stop
	     [ method ]
	     **
	     * Stops all the animations for the current element
	     **
	     = (Element) the current element
	    \*/
	    elproto.stop = function () {
	        var anims = this.inAnim();
	        for (var i = 0, ii = anims.length; i < ii; i++) {
	            anims[i].stop();
	        }
	        return this;
	    };
	    /*\
	     * Element.animate
	     [ method ]
	     **
	     * Animates the given attributes of the element
	     **
	     - attrs (object) key-value pairs of destination attributes
	     - duration (number) duration of the animation in milliseconds
	     - easing (function) #optional easing function from @mina or custom
	     - callback (function) #optional callback function that executes when the animation ends
	     = (Element) the current element
	    \*/
	    elproto.animate = function (attrs, ms, easing, callback) {
	        if (typeof easing == "function" && !easing.length) {
	            callback = easing;
	            easing = mina.linear;
	        }
	        if (attrs instanceof Animation) {
	            callback = attrs.callback;
	            easing = attrs.easing;
	            ms = easing.dur;
	            attrs = attrs.attr;
	        }
	        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,
	            el = this;
	        for (var key in attrs) if (attrs[has](key)) {
	            if (el.equal) {
	                eq = el.equal(key, Str(attrs[key]));
	                from = eq.from;
	                to = eq.to;
	                f = eq.f;
	            } else {
	                from = +el.attr(key);
	                to = +attrs[key];
	            }
	            var len = is(from, "array") ? from.length : 1;
	            keys[key] = slice(fkeys.length, fkeys.length + len, f);
	            fkeys = fkeys.concat(from);
	            tkeys = tkeys.concat(to);
	        }
	        var now = mina.time(),
	            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
	                var attr = {};
	                for (var key in keys) if (keys[has](key)) {
	                    attr[key] = keys[key](val);
	                }
	                el.attr(attr);
	            }, easing);
	        el.anims[anim.id] = anim;
	        anim._attrs = attrs;
	        anim._callback = callback;
	        eve("snap.animcreated." + el.id, anim);
	        eve.once("mina.finish." + anim.id, function () {
	            delete el.anims[anim.id];
	            callback && callback.call(el);
	        });
	        eve.once("mina.stop." + anim.id, function () {
	            delete el.anims[anim.id];
	        });
	        return el;
	    };
	    var eldata = {};
	    /*\
	     * Element.data
	     [ method ]
	     **
	     * Adds or retrieves given value associated with given key. (Don’t confuse
	     * with `data-` attributes)
	     *
	     * See also @Element.removeData
	     - key (string) key to store data
	     - value (any) #optional value to store
	     = (object) @Element
	     * or, if value is not specified:
	     = (any) value
	     > Usage
	     | for (var i = 0, i < 5, i++) {
	     |     paper.circle(10 + 15 * i, 10, 10)
	     |          .attr({fill: "#000"})
	     |          .data("i", i)
	     |          .click(function () {
	     |             alert(this.data("i"));
	     |          });
	     | }
	    \*/
	    elproto.data = function (key, value) {
	        var data = eldata[this.id] = eldata[this.id] || {};
	        if (arguments.length == 0){
	            eve("snap.data.get." + this.id, this, data, null);
	            return data;
	        }
	        if (arguments.length == 1) {
	            if (Snap.is(key, "object")) {
	                for (var i in key) if (key[has](i)) {
	                    this.data(i, key[i]);
	                }
	                return this;
	            }
	            eve("snap.data.get." + this.id, this, data[key], key);
	            return data[key];
	        }
	        data[key] = value;
	        eve("snap.data.set." + this.id, this, value, key);
	        return this;
	    };
	    /*\
	     * Element.removeData
	     [ method ]
	     **
	     * Removes value associated with an element by given key.
	     * If key is not provided, removes all the data of the element.
	     - key (string) #optional key
	     = (object) @Element
	    \*/
	    elproto.removeData = function (key) {
	        if (key == null) {
	            eldata[this.id] = {};
	        } else {
	            eldata[this.id] && delete eldata[this.id][key];
	        }
	        return this;
	    };
	    /*\
	     * Element.outerSVG
	     [ method ]
	     **
	     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
	     *
	     * See also @Element.innerSVG
	     = (string) SVG code for the element
	    \*/
	    /*\
	     * Element.toString
	     [ method ]
	     **
	     * See @Element.outerSVG
	    \*/
	    elproto.outerSVG = elproto.toString = toString(1);
	    /*\
	     * Element.innerSVG
	     [ method ]
	     **
	     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
	     = (string) SVG code for the element
	    \*/
	    elproto.innerSVG = toString();
	    function toString(type) {
	        return function () {
	            var res = type ? "<" + this.type : "",
	                attr = this.node.attributes,
	                chld = this.node.childNodes;
	            if (type) {
	                for (var i = 0, ii = attr.length; i < ii; i++) {
	                    res += " " + attr[i].name + '="' +
	                            attr[i].value.replace(/"/g, '\\"') + '"';
	                }
	            }
	            if (chld.length) {
	                type && (res += ">");
	                for (i = 0, ii = chld.length; i < ii; i++) {
	                    if (chld[i].nodeType == 3) {
	                        res += chld[i].nodeValue;
	                    } else if (chld[i].nodeType == 1) {
	                        res += wrap(chld[i]).toString();
	                    }
	                }
	                type && (res += "</" + this.type + ">");
	            } else {
	                type && (res += "/>");
	            }
	            return res;
	        };
	    }
	    elproto.toDataURL = function () {
	        if (window && window.btoa) {
	            var bb = this.getBBox(),
	                svg = Snap.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>', {
	                x: +bb.x.toFixed(3),
	                y: +bb.y.toFixed(3),
	                width: +bb.width.toFixed(3),
	                height: +bb.height.toFixed(3),
	                contents: this.outerSVG()
	            });
	            return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
	        }
	    };
	    /*\
	     * Fragment.select
	     [ method ]
	     **
	     * See @Element.select
	    \*/
	    Fragment.prototype.select = elproto.select;
	    /*\
	     * Fragment.selectAll
	     [ method ]
	     **
	     * See @Element.selectAll
	    \*/
	    Fragment.prototype.selectAll = elproto.selectAll;
	});

	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var objectToString = Object.prototype.toString,
	        Str = String,
	        math = Math,
	        E = "";
	    function Matrix(a, b, c, d, e, f) {
	        if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
	            this.a = a.a;
	            this.b = a.b;
	            this.c = a.c;
	            this.d = a.d;
	            this.e = a.e;
	            this.f = a.f;
	            return;
	        }
	        if (a != null) {
	            this.a = +a;
	            this.b = +b;
	            this.c = +c;
	            this.d = +d;
	            this.e = +e;
	            this.f = +f;
	        } else {
	            this.a = 1;
	            this.b = 0;
	            this.c = 0;
	            this.d = 1;
	            this.e = 0;
	            this.f = 0;
	        }
	    }
	    (function (matrixproto) {
	        /*\
	         * Matrix.add
	         [ method ]
	         **
	         * Adds the given matrix to existing one
	         - a (number)
	         - b (number)
	         - c (number)
	         - d (number)
	         - e (number)
	         - f (number)
	         * or
	         - matrix (object) @Matrix
	        \*/
	        matrixproto.add = function (a, b, c, d, e, f) {
	            var out = [[], [], []],
	                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
	                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
	                x, y, z, res;

	            if (a && a instanceof Matrix) {
	                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
	            }

	            for (x = 0; x < 3; x++) {
	                for (y = 0; y < 3; y++) {
	                    res = 0;
	                    for (z = 0; z < 3; z++) {
	                        res += m[x][z] * matrix[z][y];
	                    }
	                    out[x][y] = res;
	                }
	            }
	            this.a = out[0][0];
	            this.b = out[1][0];
	            this.c = out[0][1];
	            this.d = out[1][1];
	            this.e = out[0][2];
	            this.f = out[1][2];
	            return this;
	        };
	        /*\
	         * Matrix.invert
	         [ method ]
	         **
	         * Returns an inverted version of the matrix
	         = (object) @Matrix
	        \*/
	        matrixproto.invert = function () {
	            var me = this,
	                x = me.a * me.d - me.b * me.c;
	            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
	        };
	        /*\
	         * Matrix.clone
	         [ method ]
	         **
	         * Returns a copy of the matrix
	         = (object) @Matrix
	        \*/
	        matrixproto.clone = function () {
	            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
	        };
	        /*\
	         * Matrix.translate
	         [ method ]
	         **
	         * Translate the matrix
	         - x (number) horizontal offset distance
	         - y (number) vertical offset distance
	        \*/
	        matrixproto.translate = function (x, y) {
	            return this.add(1, 0, 0, 1, x, y);
	        };
	        /*\
	         * Matrix.scale
	         [ method ]
	         **
	         * Scales the matrix
	         - x (number) amount to be scaled, with `1` resulting in no change
	         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
	         - cx (number) #optional horizontal origin point from which to scale
	         - cy (number) #optional vertical origin point from which to scale
	         * Default cx, cy is the middle point of the element.
	        \*/
	        matrixproto.scale = function (x, y, cx, cy) {
	            y == null && (y = x);
	            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
	            this.add(x, 0, 0, y, 0, 0);
	            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
	            return this;
	        };
	        /*\
	         * Matrix.rotate
	         [ method ]
	         **
	         * Rotates the matrix
	         - a (number) angle of rotation, in degrees
	         - x (number) horizontal origin point from which to rotate
	         - y (number) vertical origin point from which to rotate
	        \*/
	        matrixproto.rotate = function (a, x, y) {
	            a = Snap.rad(a);
	            x = x || 0;
	            y = y || 0;
	            var cos = +math.cos(a).toFixed(9),
	                sin = +math.sin(a).toFixed(9);
	            this.add(cos, sin, -sin, cos, x, y);
	            return this.add(1, 0, 0, 1, -x, -y);
	        };
	        /*\
	         * Matrix.x
	         [ method ]
	         **
	         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
	         - x (number)
	         - y (number)
	         = (number) x
	        \*/
	        matrixproto.x = function (x, y) {
	            return x * this.a + y * this.c + this.e;
	        };
	        /*\
	         * Matrix.y
	         [ method ]
	         **
	         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
	         - x (number)
	         - y (number)
	         = (number) y
	        \*/
	        matrixproto.y = function (x, y) {
	            return x * this.b + y * this.d + this.f;
	        };
	        matrixproto.get = function (i) {
	            return +this[Str.fromCharCode(97 + i)].toFixed(4);
	        };
	        matrixproto.toString = function () {
	            return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
	        };
	        matrixproto.offset = function () {
	            return [this.e.toFixed(4), this.f.toFixed(4)];
	        };
	        function norm(a) {
	            return a[0] * a[0] + a[1] * a[1];
	        }
	        function normalize(a) {
	            var mag = math.sqrt(norm(a));
	            a[0] && (a[0] /= mag);
	            a[1] && (a[1] /= mag);
	        }
	        /*\
	         * Matrix.determinant
	         [ method ]
	         **
	         * Finds determinant of the given matrix.
	         = (number) determinant
	        \*/
	        matrixproto.determinant = function () {
	            return this.a * this.d - this.b * this.c;
	        };
	        /*\
	         * Matrix.split
	         [ method ]
	         **
	         * Splits matrix into primitive transformations
	         = (object) in format:
	         o dx (number) translation by x
	         o dy (number) translation by y
	         o scalex (number) scale by x
	         o scaley (number) scale by y
	         o shear (number) shear
	         o rotate (number) rotation in deg
	         o isSimple (boolean) could it be represented via simple transformations
	        \*/
	        matrixproto.split = function () {
	            var out = {};
	            // translation
	            out.dx = this.e;
	            out.dy = this.f;

	            // scale and shear
	            var row = [[this.a, this.c], [this.b, this.d]];
	            out.scalex = math.sqrt(norm(row[0]));
	            normalize(row[0]);

	            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
	            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

	            out.scaley = math.sqrt(norm(row[1]));
	            normalize(row[1]);
	            out.shear /= out.scaley;

	            if (this.determinant() < 0) {
	                out.scalex = -out.scalex;
	            }

	            // rotation
	            var sin = -row[0][1],
	                cos = row[1][1];
	            if (cos < 0) {
	                out.rotate = Snap.deg(math.acos(cos));
	                if (sin < 0) {
	                    out.rotate = 360 - out.rotate;
	                }
	            } else {
	                out.rotate = Snap.deg(math.asin(sin));
	            }

	            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
	            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
	            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
	            return out;
	        };
	        /*\
	         * Matrix.toTransformString
	         [ method ]
	         **
	         * Returns transform string that represents given matrix
	         = (string) transform string
	        \*/
	        matrixproto.toTransformString = function (shorter) {
	            var s = shorter || this.split();
	            if (!+s.shear.toFixed(9)) {
	                s.scalex = +s.scalex.toFixed(4);
	                s.scaley = +s.scaley.toFixed(4);
	                s.rotate = +s.rotate.toFixed(4);
	                return  (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) + 
	                        (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
	                        (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E);
	            } else {
	                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
	            }
	        };
	    })(Matrix.prototype);
	    /*\
	     * Snap.Matrix
	     [ method ]
	     **
	     * Matrix constructor, extend on your own risk.
	     * To create matrices use @Snap.matrix.
	    \*/
	    Snap.Matrix = Matrix;
	    /*\
	     * Snap.matrix
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns a matrix based on the given parameters
	     - a (number)
	     - b (number)
	     - c (number)
	     - d (number)
	     - e (number)
	     - f (number)
	     * or
	     - svgMatrix (SVGMatrix)
	     = (object) @Matrix
	    \*/
	    Snap.matrix = function (a, b, c, d, e, f) {
	        return new Matrix(a, b, c, d, e, f);
	    };
	});
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var has = "hasOwnProperty",
	        make = Snap._.make,
	        wrap = Snap._.wrap,
	        is = Snap.is,
	        getSomeDefs = Snap._.getSomeDefs,
	        reURLValue = /^url\(#?([^)]+)\)$/,
	        $ = Snap._.$,
	        URL = Snap.url,
	        Str = String,
	        separator = Snap._.separator,
	        E = "";
	    // Attributes event handlers
	    eve.on("snap.util.attr.mask", function (value) {
	        if (value instanceof Element || value instanceof Fragment) {
	            eve.stop();
	            if (value instanceof Fragment && value.node.childNodes.length == 1) {
	                value = value.node.firstChild;
	                getSomeDefs(this).appendChild(value);
	                value = wrap(value);
	            }
	            if (value.type == "mask") {
	                var mask = value;
	            } else {
	                mask = make("mask", getSomeDefs(this));
	                mask.node.appendChild(value.node);
	            }
	            !mask.node.id && $(mask.node, {
	                id: mask.id
	            });
	            $(this.node, {
	                mask: URL(mask.id)
	            });
	        }
	    });
	    (function (clipIt) {
	        eve.on("snap.util.attr.clip", clipIt);
	        eve.on("snap.util.attr.clip-path", clipIt);
	        eve.on("snap.util.attr.clipPath", clipIt);
	    }(function (value) {
	        if (value instanceof Element || value instanceof Fragment) {
	            eve.stop();
	            if (value.type == "clipPath") {
	                var clip = value;
	            } else {
	                clip = make("clipPath", getSomeDefs(this));
	                clip.node.appendChild(value.node);
	                !clip.node.id && $(clip.node, {
	                    id: clip.id
	                });
	            }
	            $(this.node, {
	                "clip-path": URL(clip.node.id || clip.id)
	            });
	        }
	    }));
	    function fillStroke(name) {
	        return function (value) {
	            eve.stop();
	            if (value instanceof Fragment && value.node.childNodes.length == 1 &&
	                (value.node.firstChild.tagName == "radialGradient" ||
	                value.node.firstChild.tagName == "linearGradient" ||
	                value.node.firstChild.tagName == "pattern")) {
	                value = value.node.firstChild;
	                getSomeDefs(this).appendChild(value);
	                value = wrap(value);
	            }
	            if (value instanceof Element) {
	                if (value.type == "radialGradient" || value.type == "linearGradient"
	                   || value.type == "pattern") {
	                    if (!value.node.id) {
	                        $(value.node, {
	                            id: value.id
	                        });
	                    }
	                    var fill = URL(value.node.id);
	                } else {
	                    fill = value.attr(name);
	                }
	            } else {
	                fill = Snap.color(value);
	                if (fill.error) {
	                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);
	                    if (grad) {
	                        if (!grad.node.id) {
	                            $(grad.node, {
	                                id: grad.id
	                            });
	                        }
	                        fill = URL(grad.node.id);
	                    } else {
	                        fill = value;
	                    }
	                } else {
	                    fill = Str(fill);
	                }
	            }
	            var attrs = {};
	            attrs[name] = fill;
	            $(this.node, attrs);
	            this.node.style[name] = E;
	        };
	    }
	    eve.on("snap.util.attr.fill", fillStroke("fill"));
	    eve.on("snap.util.attr.stroke", fillStroke("stroke"));
	    var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
	    eve.on("snap.util.grad.parse", function parseGrad(string) {
	        string = Str(string);
	        var tokens = string.match(gradrg);
	        if (!tokens) {
	            return null;
	        }
	        var type = tokens[1],
	            params = tokens[2],
	            stops = tokens[3];
	        params = params.split(/\s*,\s*/).map(function (el) {
	            return +el == el ? +el : el;
	        });
	        if (params.length == 1 && params[0] == 0) {
	            params = [];
	        }
	        stops = stops.split("-");
	        stops = stops.map(function (el) {
	            el = el.split(":");
	            var out = {
	                color: el[0]
	            };
	            if (el[1]) {
	                out.offset = parseFloat(el[1]);
	            }
	            return out;
	        });
	        return {
	            type: type,
	            params: params,
	            stops: stops
	        };
	    });

	    eve.on("snap.util.attr.d", function (value) {
	        eve.stop();
	        if (is(value, "array") && is(value[0], "array")) {
	            value = Snap.path.toString.call(value);
	        }
	        value = Str(value);
	        if (value.match(/[ruo]/i)) {
	            value = Snap.path.toAbsolute(value);
	        }
	        $(this.node, {d: value});
	    })(-1);
	    eve.on("snap.util.attr.#text", function (value) {
	        eve.stop();
	        value = Str(value);
	        var txt = glob.doc.createTextNode(value);
	        while (this.node.firstChild) {
	            this.node.removeChild(this.node.firstChild);
	        }
	        this.node.appendChild(txt);
	    })(-1);
	    eve.on("snap.util.attr.path", function (value) {
	        eve.stop();
	        this.attr({d: value});
	    })(-1);
	    eve.on("snap.util.attr.class", function (value) {
	        eve.stop();
	        this.node.className.baseVal = value;
	    })(-1);
	    eve.on("snap.util.attr.viewBox", function (value) {
	        var vb;
	        if (is(value, "object") && "x" in value) {
	            vb = [value.x, value.y, value.width, value.height].join(" ");
	        } else if (is(value, "array")) {
	            vb = value.join(" ");
	        } else {
	            vb = value;
	        }
	        $(this.node, {
	            viewBox: vb
	        });
	        eve.stop();
	    })(-1);
	    eve.on("snap.util.attr.transform", function (value) {
	        this.transform(value);
	        eve.stop();
	    })(-1);
	    eve.on("snap.util.attr.r", function (value) {
	        if (this.type == "rect") {
	            eve.stop();
	            $(this.node, {
	                rx: value,
	                ry: value
	            });
	        }
	    })(-1);
	    eve.on("snap.util.attr.textpath", function (value) {
	        eve.stop();
	        if (this.type == "text") {
	            var id, tp, node;
	            if (!value && this.textPath) {
	                tp = this.textPath;
	                while (tp.node.firstChild) {
	                    this.node.appendChild(tp.node.firstChild);
	                }
	                tp.remove();
	                delete this.textPath;
	                return;
	            }
	            if (is(value, "string")) {
	                var defs = getSomeDefs(this),
	                    path = wrap(defs.parentNode).path(value);
	                defs.appendChild(path.node);
	                id = path.id;
	                path.attr({id: id});
	            } else {
	                value = wrap(value);
	                if (value instanceof Element) {
	                    id = value.attr("id");
	                    if (!id) {
	                        id = value.id;
	                        value.attr({id: id});
	                    }
	                }
	            }
	            if (id) {
	                tp = this.textPath;
	                node = this.node;
	                if (tp) {
	                    tp.attr({"xlink:href": "#" + id});
	                } else {
	                    tp = $("textPath", {
	                        "xlink:href": "#" + id
	                    });
	                    while (node.firstChild) {
	                        tp.appendChild(node.firstChild);
	                    }
	                    node.appendChild(tp);
	                    this.textPath = wrap(tp);
	                }
	            }
	        }
	    })(-1);
	    eve.on("snap.util.attr.text", function (value) {
	        if (this.type == "text") {
	            var i = 0,
	                node = this.node,
	                tuner = function (chunk) {
	                    var out = $("tspan");
	                    if (is(chunk, "array")) {
	                        for (var i = 0; i < chunk.length; i++) {
	                            out.appendChild(tuner(chunk[i]));
	                        }
	                    } else {
	                        out.appendChild(glob.doc.createTextNode(chunk));
	                    }
	                    out.normalize && out.normalize();
	                    return out;
	                };
	            while (node.firstChild) {
	                node.removeChild(node.firstChild);
	            }
	            var tuned = tuner(value);
	            while (tuned.firstChild) {
	                node.appendChild(tuned.firstChild);
	            }
	        }
	        eve.stop();
	    })(-1);
	    function setFontSize(value) {
	        eve.stop();
	        if (value == +value) {
	            value += "px";
	        }
	        this.node.style.fontSize = value;
	    }
	    eve.on("snap.util.attr.fontSize", setFontSize)(-1);
	    eve.on("snap.util.attr.font-size", setFontSize)(-1);


	    eve.on("snap.util.getattr.transform", function () {
	        eve.stop();
	        return this.transform();
	    })(-1);
	    eve.on("snap.util.getattr.textpath", function () {
	        eve.stop();
	        return this.textPath;
	    })(-1);
	    // Markers
	    (function () {
	        function getter(end) {
	            return function () {
	                eve.stop();
	                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
	                if (style == "none") {
	                    return style;
	                } else {
	                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
	                }
	            };
	        }
	        function setter(end) {
	            return function (value) {
	                eve.stop();
	                var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
	                if (value == "" || !value) {
	                    this.node.style[name] = "none";
	                    return;
	                }
	                if (value.type == "marker") {
	                    var id = value.node.id;
	                    if (!id) {
	                        $(value.node, {id: value.id});
	                    }
	                    this.node.style[name] = URL(id);
	                    return;
	                }
	            };
	        }
	        eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
	        eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
	        eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
	        eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
	        eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
	        eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
	        eve.on("snap.util.attr.marker-end", setter("end"))(-1);
	        eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
	        eve.on("snap.util.attr.marker-start", setter("start"))(-1);
	        eve.on("snap.util.attr.markerStart", setter("start"))(-1);
	        eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
	        eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
	    }());
	    eve.on("snap.util.getattr.r", function () {
	        if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
	            eve.stop();
	            return $(this.node, "rx");
	        }
	    })(-1);
	    function textExtract(node) {
	        var out = [];
	        var children = node.childNodes;
	        for (var i = 0, ii = children.length; i < ii; i++) {
	            var chi = children[i];
	            if (chi.nodeType == 3) {
	                out.push(chi.nodeValue);
	            }
	            if (chi.tagName == "tspan") {
	                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
	                    out.push(chi.firstChild.nodeValue);
	                } else {
	                    out.push(textExtract(chi));
	                }
	            }
	        }
	        return out;
	    }
	    eve.on("snap.util.getattr.text", function () {
	        if (this.type == "text" || this.type == "tspan") {
	            eve.stop();
	            var out = textExtract(this.node);
	            return out.length == 1 ? out[0] : out;
	        }
	    })(-1);
	    eve.on("snap.util.getattr.#text", function () {
	        return this.node.textContent;
	    })(-1);
	    eve.on("snap.util.getattr.viewBox", function () {
	        eve.stop();
	        var vb = $(this.node, "viewBox");
	        if (vb) {
	            vb = vb.split(separator);
	            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
	        } else {
	            return;
	        }
	    })(-1);
	    eve.on("snap.util.getattr.points", function () {
	        var p = $(this.node, "points");
	        eve.stop();
	        if (p) {
	            return p.split(separator);
	        } else {
	            return;
	        }
	    })(-1);
	    eve.on("snap.util.getattr.path", function () {
	        var p = $(this.node, "d");
	        eve.stop();
	        return p;
	    })(-1);
	    eve.on("snap.util.getattr.class", function () {
	        return this.node.className.baseVal;
	    })(-1);
	    function getFontSize() {
	        eve.stop();
	        return this.node.style.fontSize;
	    }
	    eve.on("snap.util.getattr.fontSize", getFontSize)(-1);
	    eve.on("snap.util.getattr.font-size", getFontSize)(-1);
	});

	// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var rgNotSpace = /\S+/g,
	        rgBadSpace = /[\t\r\n\f]/g,
	        rgTrim = /(^\s+|\s+$)/g,
	        Str = String,
	        elproto = Element.prototype;
	    /*\
	     * Element.addClass
	     [ method ]
	     **
	     * Adds given class name or list of class names to the element.
	     - value (string) class name or space separated list of class names
	     **
	     = (Element) original element.
	    \*/
	    elproto.addClass = function (value) {
	        var classes = Str(value || "").match(rgNotSpace) || [],
	            elem = this.node,
	            className = elem.className.baseVal,
	            curClasses = className.match(rgNotSpace) || [],
	            j,
	            pos,
	            clazz,
	            finalValue;

	        if (classes.length) {
	            j = 0;
	            while ((clazz = classes[j++])) {
	                pos = curClasses.indexOf(clazz);
	                if (!~pos) {
	                    curClasses.push(clazz);
	                }
	            }

	            finalValue = curClasses.join(" ");
	            if (className != finalValue) {
	                elem.className.baseVal = finalValue;
	            }
	        }
	        return this;
	    };
	    /*\
	     * Element.removeClass
	     [ method ]
	     **
	     * Removes given class name or list of class names from the element.
	     - value (string) class name or space separated list of class names
	     **
	     = (Element) original element.
	    \*/
	    elproto.removeClass = function (value) {
	        var classes = Str(value || "").match(rgNotSpace) || [],
	            elem = this.node,
	            className = elem.className.baseVal,
	            curClasses = className.match(rgNotSpace) || [],
	            j,
	            pos,
	            clazz,
	            finalValue;
	        if (curClasses.length) {
	            j = 0;
	            while ((clazz = classes[j++])) {
	                pos = curClasses.indexOf(clazz);
	                if (~pos) {
	                    curClasses.splice(pos, 1);
	                }
	            }

	            finalValue = curClasses.join(" ");
	            if (className != finalValue) {
	                elem.className.baseVal = finalValue;
	            }
	        }
	        return this;
	    };
	    /*\
	     * Element.hasClass
	     [ method ]
	     **
	     * Checks if the element has a given class name in the list of class names applied to it.
	     - value (string) class name
	     **
	     = (boolean) `true` if the element has given class
	    \*/
	    elproto.hasClass = function (value) {
	        var elem = this.node,
	            className = elem.className.baseVal,
	            curClasses = className.match(rgNotSpace) || [];
	        return !!~curClasses.indexOf(value);
	    };
	    /*\
	     * Element.toggleClass
	     [ method ]
	     **
	     * Add or remove one or more classes from the element, depending on either
	     * the class’s presence or the value of the `flag` argument.
	     - value (string) class name or space separated list of class names
	     - flag (boolean) value to determine whether the class should be added or removed
	     **
	     = (Element) original element.
	    \*/
	    elproto.toggleClass = function (value, flag) {
	        if (flag != null) {
	            if (flag) {
	                return this.addClass(value);
	            } else {
	                return this.removeClass(value);
	            }
	        }
	        var classes = (value || "").match(rgNotSpace) || [],
	            elem = this.node,
	            className = elem.className.baseVal,
	            curClasses = className.match(rgNotSpace) || [],
	            j,
	            pos,
	            clazz,
	            finalValue;
	        j = 0;
	        while ((clazz = classes[j++])) {
	            pos = curClasses.indexOf(clazz);
	            if (~pos) {
	                curClasses.splice(pos, 1);
	            } else {
	                curClasses.push(clazz);
	            }
	        }

	        finalValue = curClasses.join(" ");
	        if (className != finalValue) {
	            elem.className.baseVal = finalValue;
	        }
	        return this;
	    };
	});

	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var operators = {
	            "+": function (x, y) {
	                    return x + y;
	                },
	            "-": function (x, y) {
	                    return x - y;
	                },
	            "/": function (x, y) {
	                    return x / y;
	                },
	            "*": function (x, y) {
	                    return x * y;
	                }
	        },
	        Str = String,
	        reUnit = /[a-z]+$/i,
	        reAddon = /^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;
	    function getNumber(val) {
	        return val;
	    }
	    function getUnit(unit) {
	        return function (val) {
	            return +val.toFixed(3) + unit;
	        };
	    }
	    eve.on("snap.util.attr", function (val) {
	        var plus = Str(val).match(reAddon);
	        if (plus) {
	            var evnt = eve.nt(),
	                name = evnt.substring(evnt.lastIndexOf(".") + 1),
	                a = this.attr(name),
	                atr = {};
	            eve.stop();
	            var unit = plus[3] || "",
	                aUnit = a.match(reUnit),
	                op = operators[plus[1]];
	            if (aUnit && aUnit == unit) {
	                val = op(parseFloat(a), +plus[2]);
	            } else {
	                a = this.asPX(name);
	                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));
	            }
	            if (isNaN(a) || isNaN(val)) {
	                return;
	            }
	            atr[name] = val;
	            this.attr(atr);
	        }
	    })(-10);
	    eve.on("snap.util.equal", function (name, b) {
	        var A, B, a = Str(this.attr(name) || ""),
	            el = this,
	            bplus = Str(b).match(reAddon);
	        if (bplus) {
	            eve.stop();
	            var unit = bplus[3] || "",
	                aUnit = a.match(reUnit),
	                op = operators[bplus[1]];
	            if (aUnit && aUnit == unit) {
	                return {
	                    from: parseFloat(a),
	                    to: op(parseFloat(a), +bplus[2]),
	                    f: getUnit(aUnit)
	                };
	            } else {
	                a = this.asPX(name);
	                return {
	                    from: a,
	                    to: op(a, this.asPX(name, bplus[2] + unit)),
	                    f: getNumber
	                };
	            }
	        }
	    })(-10);
	});
	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var proto = Paper.prototype,
	        is = Snap.is;
	    /*\
	     * Paper.rect
	     [ method ]
	     *
	     * Draws a rectangle
	     **
	     - x (number) x coordinate of the top left corner
	     - y (number) y coordinate of the top left corner
	     - width (number) width
	     - height (number) height
	     - rx (number) #optional horizontal radius for rounded corners, default is 0
	     - ry (number) #optional vertical radius for rounded corners, default is rx or 0
	     = (object) the `rect` element
	     **
	     > Usage
	     | // regular rectangle
	     | var c = paper.rect(10, 10, 50, 50);
	     | // rectangle with rounded corners
	     | var c = paper.rect(40, 40, 50, 50, 10);
	    \*/
	    proto.rect = function (x, y, w, h, rx, ry) {
	        var attr;
	        if (ry == null) {
	            ry = rx;
	        }
	        if (is(x, "object") && x == "[object Object]") {
	            attr = x;
	        } else if (x != null) {
	            attr = {
	                x: x,
	                y: y,
	                width: w,
	                height: h
	            };
	            if (rx != null) {
	                attr.rx = rx;
	                attr.ry = ry;
	            }
	        }
	        return this.el("rect", attr);
	    };
	    /*\
	     * Paper.circle
	     [ method ]
	     **
	     * Draws a circle
	     **
	     - x (number) x coordinate of the centre
	     - y (number) y coordinate of the centre
	     - r (number) radius
	     = (object) the `circle` element
	     **
	     > Usage
	     | var c = paper.circle(50, 50, 40);
	    \*/
	    proto.circle = function (cx, cy, r) {
	        var attr;
	        if (is(cx, "object") && cx == "[object Object]") {
	            attr = cx;
	        } else if (cx != null) {
	            attr = {
	                cx: cx,
	                cy: cy,
	                r: r
	            };
	        }
	        return this.el("circle", attr);
	    };

	    var preload = (function () {
	        function onerror() {
	            this.parentNode.removeChild(this);
	        }
	        return function (src, f) {
	            var img = glob.doc.createElement("img"),
	                body = glob.doc.body;
	            img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
	            img.onload = function () {
	                f.call(img);
	                img.onload = img.onerror = null;
	                body.removeChild(img);
	            };
	            img.onerror = onerror;
	            body.appendChild(img);
	            img.src = src;
	        };
	    }());

	    /*\
	     * Paper.image
	     [ method ]
	     **
	     * Places an image on the surface
	     **
	     - src (string) URI of the source image
	     - x (number) x offset position
	     - y (number) y offset position
	     - width (number) width of the image
	     - height (number) height of the image
	     = (object) the `image` element
	     * or
	     = (object) Snap element object with type `image`
	     **
	     > Usage
	     | var c = paper.image("apple.png", 10, 10, 80, 80);
	    \*/
	    proto.image = function (src, x, y, width, height) {
	        var el = this.el("image");
	        if (is(src, "object") && "src" in src) {
	            el.attr(src);
	        } else if (src != null) {
	            var set = {
	                "xlink:href": src,
	                preserveAspectRatio: "none"
	            };
	            if (x != null && y != null) {
	                set.x = x;
	                set.y = y;
	            }
	            if (width != null && height != null) {
	                set.width = width;
	                set.height = height;
	            } else {
	                preload(src, function () {
	                    Snap._.$(el.node, {
	                        width: this.offsetWidth,
	                        height: this.offsetHeight
	                    });
	                });
	            }
	            Snap._.$(el.node, set);
	        }
	        return el;
	    };
	    /*\
	     * Paper.ellipse
	     [ method ]
	     **
	     * Draws an ellipse
	     **
	     - x (number) x coordinate of the centre
	     - y (number) y coordinate of the centre
	     - rx (number) horizontal radius
	     - ry (number) vertical radius
	     = (object) the `ellipse` element
	     **
	     > Usage
	     | var c = paper.ellipse(50, 50, 40, 20);
	    \*/
	    proto.ellipse = function (cx, cy, rx, ry) {
	        var attr;
	        if (is(cx, "object") && cx == "[object Object]") {
	            attr = cx;
	        } else if (cx != null) {
	            attr ={
	                cx: cx,
	                cy: cy,
	                rx: rx,
	                ry: ry
	            };
	        }
	        return this.el("ellipse", attr);
	    };
	    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
	    /*\
	     * Paper.path
	     [ method ]
	     **
	     * Creates a `<path>` element using the given string as the path's definition
	     - pathString (string) #optional path string in SVG format
	     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
	     | "M10,20L30,40"
	     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
	     *
	     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
	     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
	     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
	     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
	     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
	     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
	     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
	     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
	     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
	     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
	     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
	     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
	     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
	     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
	     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.
	     > Usage
	     | var c = paper.path("M10 10L90 90");
	     | // draw a diagonal line:
	     | // move to 10,10, line to 90,90
	    \*/
	    proto.path = function (d) {
	        var attr;
	        if (is(d, "object") && !is(d, "array")) {
	            attr = d;
	        } else if (d) {
	            attr = {d: d};
	        }
	        return this.el("path", attr);
	    };
	    /*\
	     * Paper.g
	     [ method ]
	     **
	     * Creates a group element
	     **
	     - varargs (…) #optional elements to nest within the group
	     = (object) the `g` element
	     **
	     > Usage
	     | var c1 = paper.circle(),
	     |     c2 = paper.rect(),
	     |     g = paper.g(c2, c1); // note that the order of elements is different
	     * or
	     | var c1 = paper.circle(),
	     |     c2 = paper.rect(),
	     |     g = paper.g();
	     | g.add(c2, c1);
	    \*/
	    /*\
	     * Paper.group
	     [ method ]
	     **
	     * See @Paper.g
	    \*/
	    proto.group = proto.g = function (first) {
	        var attr,
	            el = this.el("g");
	        if (arguments.length == 1 && first && !first.type) {
	            el.attr(first);
	        } else if (arguments.length) {
	            el.add(Array.prototype.slice.call(arguments, 0));
	        }
	        return el;
	    };
	    /*\
	     * Paper.svg
	     [ method ]
	     **
	     * Creates a nested SVG element.
	     - x (number) @optional X of the element
	     - y (number) @optional Y of the element
	     - width (number) @optional width of the element
	     - height (number) @optional height of the element
	     - vbx (number) @optional viewbox X
	     - vby (number) @optional viewbox Y
	     - vbw (number) @optional viewbox width
	     - vbh (number) @optional viewbox height
	     **
	     = (object) the `svg` element
	     **
	    \*/
	    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {
	        var attrs = {};
	        if (is(x, "object") && y == null) {
	            attrs = x;
	        } else {
	            if (x != null) {
	                attrs.x = x;
	            }
	            if (y != null) {
	                attrs.y = y;
	            }
	            if (width != null) {
	                attrs.width = width;
	            }
	            if (height != null) {
	                attrs.height = height;
	            }
	            if (vbx != null && vby != null && vbw != null && vbh != null) {
	                attrs.viewBox = [vbx, vby, vbw, vbh];
	            }
	        }
	        return this.el("svg", attrs);
	    };
	    /*\
	     * Paper.mask
	     [ method ]
	     **
	     * Equivalent in behaviour to @Paper.g, except it’s a mask.
	     **
	     = (object) the `mask` element
	     **
	    \*/
	    proto.mask = function (first) {
	        var attr,
	            el = this.el("mask");
	        if (arguments.length == 1 && first && !first.type) {
	            el.attr(first);
	        } else if (arguments.length) {
	            el.add(Array.prototype.slice.call(arguments, 0));
	        }
	        return el;
	    };
	    /*\
	     * Paper.ptrn
	     [ method ]
	     **
	     * Equivalent in behaviour to @Paper.g, except it’s a pattern.
	     - x (number) @optional X of the element
	     - y (number) @optional Y of the element
	     - width (number) @optional width of the element
	     - height (number) @optional height of the element
	     - vbx (number) @optional viewbox X
	     - vby (number) @optional viewbox Y
	     - vbw (number) @optional viewbox width
	     - vbh (number) @optional viewbox height
	     **
	     = (object) the `pattern` element
	     **
	    \*/
	    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {
	        if (is(x, "object")) {
	            var attr = x;
	        } else {
	            attr = {patternUnits: "userSpaceOnUse"};
	            if (x) {
	                attr.x = x;
	            }
	            if (y) {
	                attr.y = y;
	            }
	            if (width != null) {
	                attr.width = width;
	            }
	            if (height != null) {
	                attr.height = height;
	            }
	            if (vx != null && vy != null && vw != null && vh != null) {
	                attr.viewBox = [vx, vy, vw, vh];
	            } else {
	                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];
	            }
	        }
	        return this.el("pattern", attr);
	    };
	    /*\
	     * Paper.use
	     [ method ]
	     **
	     * Creates a <use> element.
	     - id (string) @optional id of element to link
	     * or
	     - id (Element) @optional element to link
	     **
	     = (object) the `use` element
	     **
	    \*/
	    proto.use = function (id) {
	        if (id != null) {
	            if (id instanceof Element) {
	                if (!id.attr("id")) {
	                    id.attr({id: Snap._.id(id)});
	                }
	                id = id.attr("id");
	            }
	            if (String(id).charAt() == "#") {
	                id = id.substring(1);
	            }
	            return this.el("use", {"xlink:href": "#" + id});
	        } else {
	            return Element.prototype.use.call(this);
	        }
	    };
	    /*\
	     * Paper.symbol
	     [ method ]
	     **
	     * Creates a <symbol> element.
	     - vbx (number) @optional viewbox X
	     - vby (number) @optional viewbox Y
	     - vbw (number) @optional viewbox width
	     - vbh (number) @optional viewbox height
	     = (object) the `symbol` element
	     **
	    \*/
	    proto.symbol = function (vx, vy, vw, vh) {
	        var attr = {};
	        if (vx != null && vy != null && vw != null && vh != null) {
	            attr.viewBox = [vx, vy, vw, vh];
	        }

	        return this.el("symbol", attr);
	    };
	    /*\
	     * Paper.text
	     [ method ]
	     **
	     * Draws a text string
	     **
	     - x (number) x coordinate position
	     - y (number) y coordinate position
	     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
	     = (object) the `text` element
	     **
	     > Usage
	     | var t1 = paper.text(50, 50, "Snap");
	     | var t2 = paper.text(50, 50, ["S","n","a","p"]);
	     | // Text path usage
	     | t1.attr({textpath: "M10,10L100,100"});
	     | // or
	     | var pth = paper.path("M10,10L100,100");
	     | t1.attr({textpath: pth});
	    \*/
	    proto.text = function (x, y, text) {
	        var attr = {};
	        if (is(x, "object")) {
	            attr = x;
	        } else if (x != null) {
	            attr = {
	                x: x,
	                y: y,
	                text: text || ""
	            };
	        }
	        return this.el("text", attr);
	    };
	    /*\
	     * Paper.line
	     [ method ]
	     **
	     * Draws a line
	     **
	     - x1 (number) x coordinate position of the start
	     - y1 (number) y coordinate position of the start
	     - x2 (number) x coordinate position of the end
	     - y2 (number) y coordinate position of the end
	     = (object) the `line` element
	     **
	     > Usage
	     | var t1 = paper.line(50, 50, 100, 100);
	    \*/
	    proto.line = function (x1, y1, x2, y2) {
	        var attr = {};
	        if (is(x1, "object")) {
	            attr = x1;
	        } else if (x1 != null) {
	            attr = {
	                x1: x1,
	                x2: x2,
	                y1: y1,
	                y2: y2
	            };
	        }
	        return this.el("line", attr);
	    };
	    /*\
	     * Paper.polyline
	     [ method ]
	     **
	     * Draws a polyline
	     **
	     - points (array) array of points
	     * or
	     - varargs (…) points
	     = (object) the `polyline` element
	     **
	     > Usage
	     | var p1 = paper.polyline([10, 10, 100, 100]);
	     | var p2 = paper.polyline(10, 10, 100, 100);
	    \*/
	    proto.polyline = function (points) {
	        if (arguments.length > 1) {
	            points = Array.prototype.slice.call(arguments, 0);
	        }
	        var attr = {};
	        if (is(points, "object") && !is(points, "array")) {
	            attr = points;
	        } else if (points != null) {
	            attr = {points: points};
	        }
	        return this.el("polyline", attr);
	    };
	    /*\
	     * Paper.polygon
	     [ method ]
	     **
	     * Draws a polygon. See @Paper.polyline
	    \*/
	    proto.polygon = function (points) {
	        if (arguments.length > 1) {
	            points = Array.prototype.slice.call(arguments, 0);
	        }
	        var attr = {};
	        if (is(points, "object") && !is(points, "array")) {
	            attr = points;
	        } else if (points != null) {
	            attr = {points: points};
	        }
	        return this.el("polygon", attr);
	    };
	    // gradients
	    (function () {
	        var $ = Snap._.$;
	        // gradients' helpers
	        function Gstops() {
	            return this.selectAll("stop");
	        }
	        function GaddStop(color, offset) {
	            var stop = $("stop"),
	                attr = {
	                    offset: +offset + "%"
	                };
	            color = Snap.color(color);
	            attr["stop-color"] = color.hex;
	            if (color.opacity < 1) {
	                attr["stop-opacity"] = color.opacity;
	            }
	            $(stop, attr);
	            this.node.appendChild(stop);
	            return this;
	        }
	        function GgetBBox() {
	            if (this.type == "linearGradient") {
	                var x1 = $(this.node, "x1") || 0,
	                    x2 = $(this.node, "x2") || 1,
	                    y1 = $(this.node, "y1") || 0,
	                    y2 = $(this.node, "y2") || 0;
	                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
	            } else {
	                var cx = this.node.cx || .5,
	                    cy = this.node.cy || .5,
	                    r = this.node.r || 0;
	                return Snap._.box(cx - r, cy - r, r * 2, r * 2);
	            }
	        }
	        function gradient(defs, str) {
	            var grad = eve("snap.util.grad.parse", null, str).firstDefined(),
	                el;
	            if (!grad) {
	                return null;
	            }
	            grad.params.unshift(defs);
	            if (grad.type.toLowerCase() == "l") {
	                el = gradientLinear.apply(0, grad.params);
	            } else {
	                el = gradientRadial.apply(0, grad.params);
	            }
	            if (grad.type != grad.type.toLowerCase()) {
	                $(el.node, {
	                    gradientUnits: "userSpaceOnUse"
	                });
	            }
	            var stops = grad.stops,
	                len = stops.length,
	                start = 0,
	                j = 0;
	            function seed(i, end) {
	                var step = (end - start) / (i - j);
	                for (var k = j; k < i; k++) {
	                    stops[k].offset = +(+start + step * (k - j)).toFixed(2);
	                }
	                j = i;
	                start = end;
	            }
	            len--;
	            for (var i = 0; i < len; i++) if ("offset" in stops[i]) {
	                seed(i, stops[i].offset);
	            }
	            stops[len].offset = stops[len].offset || 100;
	            seed(len, stops[len].offset);
	            for (i = 0; i <= len; i++) {
	                var stop = stops[i];
	                el.addStop(stop.color, stop.offset);
	            }
	            return el;
	        }
	        function gradientLinear(defs, x1, y1, x2, y2) {
	            var el = Snap._.make("linearGradient", defs);
	            el.stops = Gstops;
	            el.addStop = GaddStop;
	            el.getBBox = GgetBBox;
	            if (x1 != null) {
	                $(el.node, {
	                    x1: x1,
	                    y1: y1,
	                    x2: x2,
	                    y2: y2
	                });
	            }
	            return el;
	        }
	        function gradientRadial(defs, cx, cy, r, fx, fy) {
	            var el = Snap._.make("radialGradient", defs);
	            el.stops = Gstops;
	            el.addStop = GaddStop;
	            el.getBBox = GgetBBox;
	            if (cx != null) {
	                $(el.node, {
	                    cx: cx,
	                    cy: cy,
	                    r: r
	                });
	            }
	            if (fx != null && fy != null) {
	                $(el.node, {
	                    fx: fx,
	                    fy: fy
	                });
	            }
	            return el;
	        }
	        /*\
	         * Paper.gradient
	         [ method ]
	         **
	         * Creates a gradient element
	         **
	         - gradient (string) gradient descriptor
	         > Gradient Descriptor
	         * The gradient descriptor is an expression formatted as
	         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
	         * either linear or radial.  The uppercase `L` or `R` letters
	         * indicate absolute coordinates offset from the SVG surface.
	         * Lowercase `l` or `r` letters indicate coordinates
	         * calculated relative to the element to which the gradient is
	         * applied.  Coordinates specify a linear gradient vector as
	         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
	         * `r` and optional `fx`, `fy` specifying a focal point away
	         * from the center of the circle. Specify `<colors>` as a list
	         * of dash-separated CSS color values.  Each color may be
	         * followed by a custom offset value, separated with a colon
	         * character.
	         > Examples
	         * Linear gradient, relative from top-left corner to bottom-right
	         * corner, from black through red to white:
	         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
	         * Linear gradient, absolute from (0, 0) to (100, 100), from black
	         * through red at 25% to white:
	         | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25-#fff");
	         * Radial gradient, relative from the center of the element with radius
	         * half the width, from black to white:
	         | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
	         * To apply the gradient:
	         | paper.circle(50, 50, 40).attr({
	         |     fill: g
	         | });
	         = (object) the `gradient` element
	        \*/
	        proto.gradient = function (str) {
	            return gradient(this.defs, str);
	        };
	        proto.gradientLinear = function (x1, y1, x2, y2) {
	            return gradientLinear(this.defs, x1, y1, x2, y2);
	        };
	        proto.gradientRadial = function (cx, cy, r, fx, fy) {
	            return gradientRadial(this.defs, cx, cy, r, fx, fy);
	        };
	        /*\
	         * Paper.toString
	         [ method ]
	         **
	         * Returns SVG code for the @Paper
	         = (string) SVG code for the @Paper
	        \*/
	        proto.toString = function () {
	            var doc = this.node.ownerDocument,
	                f = doc.createDocumentFragment(),
	                d = doc.createElement("div"),
	                svg = this.node.cloneNode(true),
	                res;
	            f.appendChild(d);
	            d.appendChild(svg);
	            Snap._.$(svg, {xmlns: "http://www.w3.org/2000/svg"});
	            res = d.innerHTML;
	            f.removeChild(f.firstChild);
	            return res;
	        };
	        /*\
	         * Paper.toDataURL
	         [ method ]
	         **
	         * Returns SVG code for the @Paper as Data URI string.
	         = (string) Data URI string
	        \*/
	        proto.toDataURL = function () {
	            if (window && window.btoa) {
	                return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(this)));
	            }
	        };
	        /*\
	         * Paper.clear
	         [ method ]
	         **
	         * Removes all child nodes of the paper, except <defs>.
	        \*/
	        proto.clear = function () {
	            var node = this.node.firstChild,
	                next;
	            while (node) {
	                next = node.nextSibling;
	                if (node.tagName != "defs") {
	                    node.parentNode.removeChild(node);
	                } else {
	                    proto.clear.call({node: node});
	                }
	                node = next;
	            }
	        };
	    }());
	});

	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob) {
	    var elproto = Element.prototype,
	        is = Snap.is,
	        clone = Snap._.clone,
	        has = "hasOwnProperty",
	        p2s = /,?([a-z]),?/gi,
	        toFloat = parseFloat,
	        math = Math,
	        PI = math.PI,
	        mmin = math.min,
	        mmax = math.max,
	        pow = math.pow,
	        abs = math.abs;
	    function paths(ps) {
	        var p = paths.ps = paths.ps || {};
	        if (p[ps]) {
	            p[ps].sleep = 100;
	        } else {
	            p[ps] = {
	                sleep: 100
	            };
	        }
	        setTimeout(function () {
	            for (var key in p) if (p[has](key) && key != ps) {
	                p[key].sleep--;
	                !p[key].sleep && delete p[key];
	            }
	        });
	        return p[ps];
	    }
	    function box(x, y, width, height) {
	        if (x == null) {
	            x = y = width = height = 0;
	        }
	        if (y == null) {
	            y = x.y;
	            width = x.width;
	            height = x.height;
	            x = x.x;
	        }
	        return {
	            x: x,
	            y: y,
	            width: width,
	            w: width,
	            height: height,
	            h: height,
	            x2: x + width,
	            y2: y + height,
	            cx: x + width / 2,
	            cy: y + height / 2,
	            r1: math.min(width, height) / 2,
	            r2: math.max(width, height) / 2,
	            r0: math.sqrt(width * width + height * height) / 2,
	            path: rectPath(x, y, width, height),
	            vb: [x, y, width, height].join(" ")
	        };
	    }
	    function toString() {
	        return this.join(",").replace(p2s, "$1");
	    }
	    function pathClone(pathArray) {
	        var res = clone(pathArray);
	        res.toString = toString;
	        return res;
	    }
	    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
	        if (length == null) {
	            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
	        } else {
	            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,
	                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
	        }
	    }
	    function getLengthFactory(istotal, subpath) {
	        function O(val) {
	            return +(+val).toFixed(3);
	        }
	        return Snap._.cacher(function (path, length, onlystart) {
	            if (path instanceof Element) {
	                path = path.attr("d");
	            }
	            path = path2curve(path);
	            var x, y, p, l, sp = "", subpaths = {}, point,
	                len = 0;
	            for (var i = 0, ii = path.length; i < ii; i++) {
	                p = path[i];
	                if (p[0] == "M") {
	                    x = +p[1];
	                    y = +p[2];
	                } else {
	                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
	                    if (len + l > length) {
	                        if (subpath && !subpaths.start) {
	                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
	                            sp += [
	                                "C" + O(point.start.x),
	                                O(point.start.y),
	                                O(point.m.x),
	                                O(point.m.y),
	                                O(point.x),
	                                O(point.y)
	                            ];
	                            if (onlystart) {return sp;}
	                            subpaths.start = sp;
	                            sp = [
	                                "M" + O(point.x),
	                                O(point.y) + "C" + O(point.n.x),
	                                O(point.n.y),
	                                O(point.end.x),
	                                O(point.end.y),
	                                O(p[5]),
	                                O(p[6])
	                            ].join();
	                            len += l;
	                            x = +p[5];
	                            y = +p[6];
	                            continue;
	                        }
	                        if (!istotal && !subpath) {
	                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
	                            return point;
	                        }
	                    }
	                    len += l;
	                    x = +p[5];
	                    y = +p[6];
	                }
	                sp += p.shift() + p;
	            }
	            subpaths.end = sp;
	            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
	            return point;
	        }, null, Snap._.clone);
	    }
	    var getTotalLength = getLengthFactory(1),
	        getPointAtLength = getLengthFactory(),
	        getSubpathsAtLength = getLengthFactory(0, 1);
	    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
	        var t1 = 1 - t,
	            t13 = pow(t1, 3),
	            t12 = pow(t1, 2),
	            t2 = t * t,
	            t3 = t2 * t,
	            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
	            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
	            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
	            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
	            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
	            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
	            ax = t1 * p1x + t * c1x,
	            ay = t1 * p1y + t * c1y,
	            cx = t1 * c2x + t * p2x,
	            cy = t1 * c2y + t * p2y,
	            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
	        // (mx > nx || my < ny) && (alpha += 180);
	        return {
	            x: x,
	            y: y,
	            m: {x: mx, y: my},
	            n: {x: nx, y: ny},
	            start: {x: ax, y: ay},
	            end: {x: cx, y: cy},
	            alpha: alpha
	        };
	    }
	    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
	        if (!Snap.is(p1x, "array")) {
	            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
	        }
	        var bbox = curveDim.apply(null, p1x);
	        return box(
	            bbox.min.x,
	            bbox.min.y,
	            bbox.max.x - bbox.min.x,
	            bbox.max.y - bbox.min.y
	        );
	    }
	    function isPointInsideBBox(bbox, x, y) {
	        return  x >= bbox.x &&
	                x <= bbox.x + bbox.width &&
	                y >= bbox.y &&
	                y <= bbox.y + bbox.height;
	    }
	    function isBBoxIntersect(bbox1, bbox2) {
	        bbox1 = box(bbox1);
	        bbox2 = box(bbox2);
	        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
	            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
	            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
	            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
	            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
	            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
	            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
	            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
	            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
	                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
	            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
	                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
	    }
	    function base3(t, p1, p2, p3, p4) {
	        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
	            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
	        return t * t2 - 3 * p1 + 3 * p2;
	    }
	    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
	        if (z == null) {
	            z = 1;
	        }
	        z = z > 1 ? 1 : z < 0 ? 0 : z;
	        var z2 = z / 2,
	            n = 12,
	            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],
	            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
	            sum = 0;
	        for (var i = 0; i < n; i++) {
	            var ct = z2 * Tvalues[i] + z2,
	                xbase = base3(ct, x1, x2, x3, x4),
	                ybase = base3(ct, y1, y2, y3, y4),
	                comb = xbase * xbase + ybase * ybase;
	            sum += Cvalues[i] * math.sqrt(comb);
	        }
	        return z2 * sum;
	    }
	    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
	        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
	            return;
	        }
	        var t = 1,
	            step = t / 2,
	            t2 = t - step,
	            l,
	            e = .01;
	        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
	        while (abs(l - ll) > e) {
	            step /= 2;
	            t2 += (l < ll ? 1 : -1) * step;
	            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
	        }
	        return t2;
	    }
	    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
	        if (
	            mmax(x1, x2) < mmin(x3, x4) ||
	            mmin(x1, x2) > mmax(x3, x4) ||
	            mmax(y1, y2) < mmin(y3, y4) ||
	            mmin(y1, y2) > mmax(y3, y4)
	        ) {
	            return;
	        }
	        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
	            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
	            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

	        if (!denominator) {
	            return;
	        }
	        var px = nx / denominator,
	            py = ny / denominator,
	            px2 = +px.toFixed(2),
	            py2 = +py.toFixed(2);
	        if (
	            px2 < +mmin(x1, x2).toFixed(2) ||
	            px2 > +mmax(x1, x2).toFixed(2) ||
	            px2 < +mmin(x3, x4).toFixed(2) ||
	            px2 > +mmax(x3, x4).toFixed(2) ||
	            py2 < +mmin(y1, y2).toFixed(2) ||
	            py2 > +mmax(y1, y2).toFixed(2) ||
	            py2 < +mmin(y3, y4).toFixed(2) ||
	            py2 > +mmax(y3, y4).toFixed(2)
	        ) {
	            return;
	        }
	        return {x: px, y: py};
	    }
	    function inter(bez1, bez2) {
	        return interHelper(bez1, bez2);
	    }
	    function interCount(bez1, bez2) {
	        return interHelper(bez1, bez2, 1);
	    }
	    function interHelper(bez1, bez2, justCount) {
	        var bbox1 = bezierBBox(bez1),
	            bbox2 = bezierBBox(bez2);
	        if (!isBBoxIntersect(bbox1, bbox2)) {
	            return justCount ? 0 : [];
	        }
	        var l1 = bezlen.apply(0, bez1),
	            l2 = bezlen.apply(0, bez2),
	            n1 = ~~(l1 / 8),
	            n2 = ~~(l2 / 8),
	            dots1 = [],
	            dots2 = [],
	            xy = {},
	            res = justCount ? 0 : [];
	        for (var i = 0; i < n1 + 1; i++) {
	            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
	            dots1.push({x: p.x, y: p.y, t: i / n1});
	        }
	        for (i = 0; i < n2 + 1; i++) {
	            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
	            dots2.push({x: p.x, y: p.y, t: i / n2});
	        }
	        for (i = 0; i < n1; i++) {
	            for (var j = 0; j < n2; j++) {
	                var di = dots1[i],
	                    di1 = dots1[i + 1],
	                    dj = dots2[j],
	                    dj1 = dots2[j + 1],
	                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
	                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
	                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
	                if (is) {
	                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
	                        continue;
	                    }
	                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
	                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
	                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
	                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
	                        if (justCount) {
	                            res++;
	                        } else {
	                            res.push({
	                                x: is.x,
	                                y: is.y,
	                                t1: t1,
	                                t2: t2
	                            });
	                        }
	                    }
	                }
	            }
	        }
	        return res;
	    }
	    function pathIntersection(path1, path2) {
	        return interPathHelper(path1, path2);
	    }
	    function pathIntersectionNumber(path1, path2) {
	        return interPathHelper(path1, path2, 1);
	    }
	    function interPathHelper(path1, path2, justCount) {
	        path1 = path2curve(path1);
	        path2 = path2curve(path2);
	        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
	            res = justCount ? 0 : [];
	        for (var i = 0, ii = path1.length; i < ii; i++) {
	            var pi = path1[i];
	            if (pi[0] == "M") {
	                x1 = x1m = pi[1];
	                y1 = y1m = pi[2];
	            } else {
	                if (pi[0] == "C") {
	                    bez1 = [x1, y1].concat(pi.slice(1));
	                    x1 = bez1[6];
	                    y1 = bez1[7];
	                } else {
	                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
	                    x1 = x1m;
	                    y1 = y1m;
	                }
	                for (var j = 0, jj = path2.length; j < jj; j++) {
	                    var pj = path2[j];
	                    if (pj[0] == "M") {
	                        x2 = x2m = pj[1];
	                        y2 = y2m = pj[2];
	                    } else {
	                        if (pj[0] == "C") {
	                            bez2 = [x2, y2].concat(pj.slice(1));
	                            x2 = bez2[6];
	                            y2 = bez2[7];
	                        } else {
	                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
	                            x2 = x2m;
	                            y2 = y2m;
	                        }
	                        var intr = interHelper(bez1, bez2, justCount);
	                        if (justCount) {
	                            res += intr;
	                        } else {
	                            for (var k = 0, kk = intr.length; k < kk; k++) {
	                                intr[k].segment1 = i;
	                                intr[k].segment2 = j;
	                                intr[k].bez1 = bez1;
	                                intr[k].bez2 = bez2;
	                            }
	                            res = res.concat(intr);
	                        }
	                    }
	                }
	            }
	        }
	        return res;
	    }
	    function isPointInsidePath(path, x, y) {
	        var bbox = pathBBox(path);
	        return isPointInsideBBox(bbox, x, y) &&
	               interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
	    }
	    function pathBBox(path) {
	        var pth = paths(path);
	        if (pth.bbox) {
	            return clone(pth.bbox);
	        }
	        if (!path) {
	            return box();
	        }
	        path = path2curve(path);
	        var x = 0, 
	            y = 0,
	            X = [],
	            Y = [],
	            p;
	        for (var i = 0, ii = path.length; i < ii; i++) {
	            p = path[i];
	            if (p[0] == "M") {
	                x = p[1];
	                y = p[2];
	                X.push(x);
	                Y.push(y);
	            } else {
	                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
	                X = X.concat(dim.min.x, dim.max.x);
	                Y = Y.concat(dim.min.y, dim.max.y);
	                x = p[5];
	                y = p[6];
	            }
	        }
	        var xmin = mmin.apply(0, X),
	            ymin = mmin.apply(0, Y),
	            xmax = mmax.apply(0, X),
	            ymax = mmax.apply(0, Y),
	            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
	        pth.bbox = clone(bb);
	        return bb;
	    }
	    function rectPath(x, y, w, h, r) {
	        if (r) {
	            return [
	                ["M", +x + (+r), y],
	                ["l", w - r * 2, 0],
	                ["a", r, r, 0, 0, 1, r, r],
	                ["l", 0, h - r * 2],
	                ["a", r, r, 0, 0, 1, -r, r],
	                ["l", r * 2 - w, 0],
	                ["a", r, r, 0, 0, 1, -r, -r],
	                ["l", 0, r * 2 - h],
	                ["a", r, r, 0, 0, 1, r, -r],
	                ["z"]
	            ];
	        }
	        var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
	        res.toString = toString;
	        return res;
	    }
	    function ellipsePath(x, y, rx, ry, a) {
	        if (a == null && ry == null) {
	            ry = rx;
	        }
	        x = +x;
	        y = +y;
	        rx = +rx;
	        ry = +ry;
	        if (a != null) {
	            var rad = Math.PI / 180,
	                x1 = x + rx * Math.cos(-ry * rad),
	                x2 = x + rx * Math.cos(-a * rad),
	                y1 = y + rx * Math.sin(-ry * rad),
	                y2 = y + rx * Math.sin(-a * rad),
	                res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
	        } else {
	            res = [
	                ["M", x, y],
	                ["m", 0, -ry],
	                ["a", rx, ry, 0, 1, 1, 0, 2 * ry],
	                ["a", rx, ry, 0, 1, 1, 0, -2 * ry],
	                ["z"]
	            ];
	        }
	        res.toString = toString;
	        return res;
	    }
	    var unit2px = Snap._unit2px,
	        getPath = {
	        path: function (el) {
	            return el.attr("path");
	        },
	        circle: function (el) {
	            var attr = unit2px(el);
	            return ellipsePath(attr.cx, attr.cy, attr.r);
	        },
	        ellipse: function (el) {
	            var attr = unit2px(el);
	            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);
	        },
	        rect: function (el) {
	            var attr = unit2px(el);
	            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);
	        },
	        image: function (el) {
	            var attr = unit2px(el);
	            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);
	        },
	        line: function (el) {
	            return "M" + [el.attr("x1") || 0, el.attr("y1") || 0, el.attr("x2"), el.attr("y2")];
	        },
	        polyline: function (el) {
	            return "M" + el.attr("points");
	        },
	        polygon: function (el) {
	            return "M" + el.attr("points") + "z";
	        },
	        deflt: function (el) {
	            var bbox = el.node.getBBox();
	            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
	        }
	    };
	    function pathToRelative(pathArray) {
	        var pth = paths(pathArray),
	            lowerCase = String.prototype.toLowerCase;
	        if (pth.rel) {
	            return pathClone(pth.rel);
	        }
	        if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
	            pathArray = Snap.parsePathString(pathArray);
	        }
	        var res = [],
	            x = 0,
	            y = 0,
	            mx = 0,
	            my = 0,
	            start = 0;
	        if (pathArray[0][0] == "M") {
	            x = pathArray[0][1];
	            y = pathArray[0][2];
	            mx = x;
	            my = y;
	            start++;
	            res.push(["M", x, y]);
	        }
	        for (var i = start, ii = pathArray.length; i < ii; i++) {
	            var r = res[i] = [],
	                pa = pathArray[i];
	            if (pa[0] != lowerCase.call(pa[0])) {
	                r[0] = lowerCase.call(pa[0]);
	                switch (r[0]) {
	                    case "a":
	                        r[1] = pa[1];
	                        r[2] = pa[2];
	                        r[3] = pa[3];
	                        r[4] = pa[4];
	                        r[5] = pa[5];
	                        r[6] = +(pa[6] - x).toFixed(3);
	                        r[7] = +(pa[7] - y).toFixed(3);
	                        break;
	                    case "v":
	                        r[1] = +(pa[1] - y).toFixed(3);
	                        break;
	                    case "m":
	                        mx = pa[1];
	                        my = pa[2];
	                    default:
	                        for (var j = 1, jj = pa.length; j < jj; j++) {
	                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
	                        }
	                }
	            } else {
	                r = res[i] = [];
	                if (pa[0] == "m") {
	                    mx = pa[1] + x;
	                    my = pa[2] + y;
	                }
	                for (var k = 0, kk = pa.length; k < kk; k++) {
	                    res[i][k] = pa[k];
	                }
	            }
	            var len = res[i].length;
	            switch (res[i][0]) {
	                case "z":
	                    x = mx;
	                    y = my;
	                    break;
	                case "h":
	                    x += +res[i][len - 1];
	                    break;
	                case "v":
	                    y += +res[i][len - 1];
	                    break;
	                default:
	                    x += +res[i][len - 2];
	                    y += +res[i][len - 1];
	            }
	        }
	        res.toString = toString;
	        pth.rel = pathClone(res);
	        return res;
	    }
	    function pathToAbsolute(pathArray) {
	        var pth = paths(pathArray);
	        if (pth.abs) {
	            return pathClone(pth.abs);
	        }
	        if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) { // rough assumption
	            pathArray = Snap.parsePathString(pathArray);
	        }
	        if (!pathArray || !pathArray.length) {
	            return [["M", 0, 0]];
	        }
	        var res = [],
	            x = 0,
	            y = 0,
	            mx = 0,
	            my = 0,
	            start = 0,
	            pa0;
	        if (pathArray[0][0] == "M") {
	            x = +pathArray[0][1];
	            y = +pathArray[0][2];
	            mx = x;
	            my = y;
	            start++;
	            res[0] = ["M", x, y];
	        }
	        var crz = pathArray.length == 3 &&
	            pathArray[0][0] == "M" &&
	            pathArray[1][0].toUpperCase() == "R" &&
	            pathArray[2][0].toUpperCase() == "Z";
	        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
	            res.push(r = []);
	            pa = pathArray[i];
	            pa0 = pa[0];
	            if (pa0 != pa0.toUpperCase()) {
	                r[0] = pa0.toUpperCase();
	                switch (r[0]) {
	                    case "A":
	                        r[1] = pa[1];
	                        r[2] = pa[2];
	                        r[3] = pa[3];
	                        r[4] = pa[4];
	                        r[5] = pa[5];
	                        r[6] = +pa[6] + x;
	                        r[7] = +pa[7] + y;
	                        break;
	                    case "V":
	                        r[1] = +pa[1] + y;
	                        break;
	                    case "H":
	                        r[1] = +pa[1] + x;
	                        break;
	                    case "R":
	                        var dots = [x, y].concat(pa.slice(1));
	                        for (var j = 2, jj = dots.length; j < jj; j++) {
	                            dots[j] = +dots[j] + x;
	                            dots[++j] = +dots[j] + y;
	                        }
	                        res.pop();
	                        res = res.concat(catmullRom2bezier(dots, crz));
	                        break;
	                    case "O":
	                        res.pop();
	                        dots = ellipsePath(x, y, pa[1], pa[2]);
	                        dots.push(dots[0]);
	                        res = res.concat(dots);
	                        break;
	                    case "U":
	                        res.pop();
	                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
	                        r = ["U"].concat(res[res.length - 1].slice(-2));
	                        break;
	                    case "M":
	                        mx = +pa[1] + x;
	                        my = +pa[2] + y;
	                    default:
	                        for (j = 1, jj = pa.length; j < jj; j++) {
	                            r[j] = +pa[j] + ((j % 2) ? x : y);
	                        }
	                }
	            } else if (pa0 == "R") {
	                dots = [x, y].concat(pa.slice(1));
	                res.pop();
	                res = res.concat(catmullRom2bezier(dots, crz));
	                r = ["R"].concat(pa.slice(-2));
	            } else if (pa0 == "O") {
	                res.pop();
	                dots = ellipsePath(x, y, pa[1], pa[2]);
	                dots.push(dots[0]);
	                res = res.concat(dots);
	            } else if (pa0 == "U") {
	                res.pop();
	                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
	                r = ["U"].concat(res[res.length - 1].slice(-2));
	            } else {
	                for (var k = 0, kk = pa.length; k < kk; k++) {
	                    r[k] = pa[k];
	                }
	            }
	            pa0 = pa0.toUpperCase();
	            if (pa0 != "O") {
	                switch (r[0]) {
	                    case "Z":
	                        x = +mx;
	                        y = +my;
	                        break;
	                    case "H":
	                        x = r[1];
	                        break;
	                    case "V":
	                        y = r[1];
	                        break;
	                    case "M":
	                        mx = r[r.length - 2];
	                        my = r[r.length - 1];
	                    default:
	                        x = r[r.length - 2];
	                        y = r[r.length - 1];
	                }
	            }
	        }
	        res.toString = toString;
	        pth.abs = pathClone(res);
	        return res;
	    }
	    function l2c(x1, y1, x2, y2) {
	        return [x1, y1, x2, y2, x2, y2];
	    }
	    function q2c(x1, y1, ax, ay, x2, y2) {
	        var _13 = 1 / 3,
	            _23 = 2 / 3;
	        return [
	                _13 * x1 + _23 * ax,
	                _13 * y1 + _23 * ay,
	                _13 * x2 + _23 * ax,
	                _13 * y2 + _23 * ay,
	                x2,
	                y2
	            ];
	    }
	    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
	        // for more information of where this math came from visit:
	        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	        var _120 = PI * 120 / 180,
	            rad = PI / 180 * (+angle || 0),
	            res = [],
	            xy,
	            rotate = Snap._.cacher(function (x, y, rad) {
	                var X = x * math.cos(rad) - y * math.sin(rad),
	                    Y = x * math.sin(rad) + y * math.cos(rad);
	                return {x: X, y: Y};
	            });
	        if (!recursive) {
	            xy = rotate(x1, y1, -rad);
	            x1 = xy.x;
	            y1 = xy.y;
	            xy = rotate(x2, y2, -rad);
	            x2 = xy.x;
	            y2 = xy.y;
	            var cos = math.cos(PI / 180 * angle),
	                sin = math.sin(PI / 180 * angle),
	                x = (x1 - x2) / 2,
	                y = (y1 - y2) / 2;
	            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
	            if (h > 1) {
	                h = math.sqrt(h);
	                rx = h * rx;
	                ry = h * ry;
	            }
	            var rx2 = rx * rx,
	                ry2 = ry * ry,
	                k = (large_arc_flag == sweep_flag ? -1 : 1) *
	                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
	                cx = k * rx * y / ry + (x1 + x2) / 2,
	                cy = k * -ry * x / rx + (y1 + y2) / 2,
	                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
	                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

	            f1 = x1 < cx ? PI - f1 : f1;
	            f2 = x2 < cx ? PI - f2 : f2;
	            f1 < 0 && (f1 = PI * 2 + f1);
	            f2 < 0 && (f2 = PI * 2 + f2);
	            if (sweep_flag && f1 > f2) {
	                f1 = f1 - PI * 2;
	            }
	            if (!sweep_flag && f2 > f1) {
	                f2 = f2 - PI * 2;
	            }
	        } else {
	            f1 = recursive[0];
	            f2 = recursive[1];
	            cx = recursive[2];
	            cy = recursive[3];
	        }
	        var df = f2 - f1;
	        if (abs(df) > _120) {
	            var f2old = f2,
	                x2old = x2,
	                y2old = y2;
	            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
	            x2 = cx + rx * math.cos(f2);
	            y2 = cy + ry * math.sin(f2);
	            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
	        }
	        df = f2 - f1;
	        var c1 = math.cos(f1),
	            s1 = math.sin(f1),
	            c2 = math.cos(f2),
	            s2 = math.sin(f2),
	            t = math.tan(df / 4),
	            hx = 4 / 3 * rx * t,
	            hy = 4 / 3 * ry * t,
	            m1 = [x1, y1],
	            m2 = [x1 + hx * s1, y1 - hy * c1],
	            m3 = [x2 + hx * s2, y2 - hy * c2],
	            m4 = [x2, y2];
	        m2[0] = 2 * m1[0] - m2[0];
	        m2[1] = 2 * m1[1] - m2[1];
	        if (recursive) {
	            return [m2, m3, m4].concat(res);
	        } else {
	            res = [m2, m3, m4].concat(res).join().split(",");
	            var newres = [];
	            for (var i = 0, ii = res.length; i < ii; i++) {
	                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
	            }
	            return newres;
	        }
	    }
	    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
	        var t1 = 1 - t;
	        return {
	            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
	            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
	        };
	    }
	    
	    // Returns bounding box of cubic bezier curve.
	    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
	    // Original version: NISHIO Hirokazu
	    // Modifications: https://github.com/timo22345
	    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
	        var tvalues = [],
	            bounds = [[], []],
	            a, b, c, t, t1, t2, b2ac, sqrtb2ac;
	        for (var i = 0; i < 2; ++i) {
	            if (i == 0) {
	                b = 6 * x0 - 12 * x1 + 6 * x2;
	                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
	                c = 3 * x1 - 3 * x0;
	            } else {
	                b = 6 * y0 - 12 * y1 + 6 * y2;
	                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
	                c = 3 * y1 - 3 * y0;
	            }
	            if (abs(a) < 1e-12) {
	                if (abs(b) < 1e-12) {
	                    continue;
	                }
	                t = -c / b;
	                if (0 < t && t < 1) {
	                    tvalues.push(t);
	                }
	                continue;
	            }
	            b2ac = b * b - 4 * c * a;
	            sqrtb2ac = math.sqrt(b2ac);
	            if (b2ac < 0) {
	                continue;
	            }
	            t1 = (-b + sqrtb2ac) / (2 * a);
	            if (0 < t1 && t1 < 1) {
	                tvalues.push(t1);
	            }
	            t2 = (-b - sqrtb2ac) / (2 * a);
	            if (0 < t2 && t2 < 1) {
	                tvalues.push(t2);
	            }
	        }

	        var x, y, j = tvalues.length,
	            jlen = j,
	            mt;
	        while (j--) {
	            t = tvalues[j];
	            mt = 1 - t;
	            bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
	            bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
	        }

	        bounds[0][jlen] = x0;
	        bounds[1][jlen] = y0;
	        bounds[0][jlen + 1] = x3;
	        bounds[1][jlen + 1] = y3;
	        bounds[0].length = bounds[1].length = jlen + 2;


	        return {
	          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},
	          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}
	        };
	    }

	    function path2curve(path, path2) {
	        var pth = !path2 && paths(path);
	        if (!path2 && pth.curve) {
	            return pathClone(pth.curve);
	        }
	        var p = pathToAbsolute(path),
	            p2 = path2 && pathToAbsolute(path2),
	            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
	            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
	            processPath = function (path, d, pcom) {
	                var nx, ny;
	                if (!path) {
	                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
	                }
	                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);
	                switch (path[0]) {
	                    case "M":
	                        d.X = path[1];
	                        d.Y = path[2];
	                        break;
	                    case "A":
	                        path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
	                        break;
	                    case "S":
	                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
	                            nx = d.x * 2 - d.bx;          // And reflect the previous
	                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
	                        }
	                        else {                            // or some else or nothing
	                            nx = d.x;
	                            ny = d.y;
	                        }
	                        path = ["C", nx, ny].concat(path.slice(1));
	                        break;
	                    case "T":
	                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
	                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
	                            d.qy = d.y * 2 - d.qy;        // to case "S".
	                        }
	                        else {                            // or something else or nothing
	                            d.qx = d.x;
	                            d.qy = d.y;
	                        }
	                        path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
	                        break;
	                    case "Q":
	                        d.qx = path[1];
	                        d.qy = path[2];
	                        path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
	                        break;
	                    case "L":
	                        path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
	                        break;
	                    case "H":
	                        path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
	                        break;
	                    case "V":
	                        path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
	                        break;
	                    case "Z":
	                        path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
	                        break;
	                }
	                return path;
	            },
	            fixArc = function (pp, i) {
	                if (pp[i].length > 7) {
	                    pp[i].shift();
	                    var pi = pp[i];
	                    while (pi.length) {
	                        pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
	                        p2 && (pcoms2[i] = "A"); // the same as above
	                        pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
	                    }
	                    pp.splice(i, 1);
	                    ii = mmax(p.length, p2 && p2.length || 0);
	                }
	            },
	            fixM = function (path1, path2, a1, a2, i) {
	                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
	                    path2.splice(i, 0, ["M", a2.x, a2.y]);
	                    a1.bx = 0;
	                    a1.by = 0;
	                    a1.x = path1[i][1];
	                    a1.y = path1[i][2];
	                    ii = mmax(p.length, p2 && p2.length || 0);
	                }
	            },
	            pcoms1 = [], // path commands of original path p
	            pcoms2 = [], // path commands of original path p2
	            pfirst = "", // temporary holder for original path command
	            pcom = ""; // holder for previous path command of original path
	        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
	            p[i] && (pfirst = p[i][0]); // save current path command

	            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
	            {
	                pcoms1[i] = pfirst; // Save current path command
	                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom
	            }
	            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

	            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
	            // which may produce multiple C:s
	            // so we have to make sure that C is also C in original path

	            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

	            if (p2) { // the same procedures is done to p2
	                p2[i] && (pfirst = p2[i][0]);
	                if (pfirst != "C") {
	                    pcoms2[i] = pfirst;
	                    i && (pcom = pcoms2[i - 1]);
	                }
	                p2[i] = processPath(p2[i], attrs2, pcom);

	                if (pcoms2[i] != "A" && pfirst == "C") {
	                    pcoms2[i] = "C";
	                }

	                fixArc(p2, i);
	            }
	            fixM(p, p2, attrs, attrs2, i);
	            fixM(p2, p, attrs2, attrs, i);
	            var seg = p[i],
	                seg2 = p2 && p2[i],
	                seglen = seg.length,
	                seg2len = p2 && seg2.length;
	            attrs.x = seg[seglen - 2];
	            attrs.y = seg[seglen - 1];
	            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
	            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
	            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
	            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
	            attrs2.x = p2 && seg2[seg2len - 2];
	            attrs2.y = p2 && seg2[seg2len - 1];
	        }
	        if (!p2) {
	            pth.curve = pathClone(p);
	        }
	        return p2 ? [p, p2] : p;
	    }
	    function mapPath(path, matrix) {
	        if (!matrix) {
	            return path;
	        }
	        var x, y, i, j, ii, jj, pathi;
	        path = path2curve(path);
	        for (i = 0, ii = path.length; i < ii; i++) {
	            pathi = path[i];
	            for (j = 1, jj = pathi.length; j < jj; j += 2) {
	                x = matrix.x(pathi[j], pathi[j + 1]);
	                y = matrix.y(pathi[j], pathi[j + 1]);
	                pathi[j] = x;
	                pathi[j + 1] = y;
	            }
	        }
	        return path;
	    }

	    // http://schepers.cc/getting-to-the-point
	    function catmullRom2bezier(crp, z) {
	        var d = [];
	        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
	            var p = [
	                        {x: +crp[i - 2], y: +crp[i - 1]},
	                        {x: +crp[i],     y: +crp[i + 1]},
	                        {x: +crp[i + 2], y: +crp[i + 3]},
	                        {x: +crp[i + 4], y: +crp[i + 5]}
	                    ];
	            if (z) {
	                if (!i) {
	                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
	                } else if (iLen - 4 == i) {
	                    p[3] = {x: +crp[0], y: +crp[1]};
	                } else if (iLen - 2 == i) {
	                    p[2] = {x: +crp[0], y: +crp[1]};
	                    p[3] = {x: +crp[2], y: +crp[3]};
	                }
	            } else {
	                if (iLen - 4 == i) {
	                    p[3] = p[2];
	                } else if (!i) {
	                    p[0] = {x: +crp[i], y: +crp[i + 1]};
	                }
	            }
	            d.push(["C",
	                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,
	                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,
	                  (p[1].x + 6 * p[2].x - p[3].x) / 6,
	                  (p[1].y + 6*p[2].y - p[3].y) / 6,
	                  p[2].x,
	                  p[2].y
	            ]);
	        }

	        return d;
	    }

	    // export
	    Snap.path = paths;

	    /*\
	     * Snap.path.getTotalLength
	     [ method ]
	     **
	     * Returns the length of the given path in pixels
	     **
	     - path (string) SVG path string
	     **
	     = (number) length
	    \*/
	    Snap.path.getTotalLength = getTotalLength;
	    /*\
	     * Snap.path.getPointAtLength
	     [ method ]
	     **
	     * Returns the coordinates of the point located at the given length along the given path
	     **
	     - path (string) SVG path string
	     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
	     **
	     = (object) representation of the point:
	     o {
	     o     x: (number) x coordinate,
	     o     y: (number) y coordinate,
	     o     alpha: (number) angle of derivative
	     o }
	    \*/
	    Snap.path.getPointAtLength = getPointAtLength;
	    /*\
	     * Snap.path.getSubpath
	     [ method ]
	     **
	     * Returns the subpath of a given path between given start and end lengths
	     **
	     - path (string) SVG path string
	     - from (number) length, in pixels, from the start of the path to the start of the segment
	     - to (number) length, in pixels, from the start of the path to the end of the segment
	     **
	     = (string) path string definition for the segment
	    \*/
	    Snap.path.getSubpath = function (path, from, to) {
	        if (this.getTotalLength(path) - to < 1e-6) {
	            return getSubpathsAtLength(path, from).end;
	        }
	        var a = getSubpathsAtLength(path, to, 1);
	        return from ? getSubpathsAtLength(a, from).end : a;
	    };
	    /*\
	     * Element.getTotalLength
	     [ method ]
	     **
	     * Returns the length of the path in pixels (only works for `path` elements)
	     = (number) length
	    \*/
	    elproto.getTotalLength = function () {
	        if (this.node.getTotalLength) {
	            return this.node.getTotalLength();
	        }
	    };
	    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
	    /*\
	     * Element.getPointAtLength
	     [ method ]
	     **
	     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
	     **
	     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
	     **
	     = (object) representation of the point:
	     o {
	     o     x: (number) x coordinate,
	     o     y: (number) y coordinate,
	     o     alpha: (number) angle of derivative
	     o }
	    \*/
	    elproto.getPointAtLength = function (length) {
	        return getPointAtLength(this.attr("d"), length);
	    };
	    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
	    /*\
	     * Element.getSubpath
	     [ method ]
	     **
	     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
	     **
	     - from (number) length, in pixels, from the start of the path to the start of the segment
	     - to (number) length, in pixels, from the start of the path to the end of the segment
	     **
	     = (string) path string definition for the segment
	    \*/
	    elproto.getSubpath = function (from, to) {
	        return Snap.path.getSubpath(this.attr("d"), from, to);
	    };
	    Snap._.box = box;
	    /*\
	     * Snap.path.findDotsAtSegment
	     [ method ]
	     **
	     * Utility method
	     **
	     * Finds dot coordinates on the given cubic beziér curve at the given t
	     - p1x (number) x of the first point of the curve
	     - p1y (number) y of the first point of the curve
	     - c1x (number) x of the first anchor of the curve
	     - c1y (number) y of the first anchor of the curve
	     - c2x (number) x of the second anchor of the curve
	     - c2y (number) y of the second anchor of the curve
	     - p2x (number) x of the second point of the curve
	     - p2y (number) y of the second point of the curve
	     - t (number) position on the curve (0..1)
	     = (object) point information in format:
	     o {
	     o     x: (number) x coordinate of the point,
	     o     y: (number) y coordinate of the point,
	     o     m: {
	     o         x: (number) x coordinate of the left anchor,
	     o         y: (number) y coordinate of the left anchor
	     o     },
	     o     n: {
	     o         x: (number) x coordinate of the right anchor,
	     o         y: (number) y coordinate of the right anchor
	     o     },
	     o     start: {
	     o         x: (number) x coordinate of the start of the curve,
	     o         y: (number) y coordinate of the start of the curve
	     o     },
	     o     end: {
	     o         x: (number) x coordinate of the end of the curve,
	     o         y: (number) y coordinate of the end of the curve
	     o     },
	     o     alpha: (number) angle of the curve derivative at the point
	     o }
	    \*/
	    Snap.path.findDotsAtSegment = findDotsAtSegment;
	    /*\
	     * Snap.path.bezierBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns the bounding box of a given cubic beziér curve
	     - p1x (number) x of the first point of the curve
	     - p1y (number) y of the first point of the curve
	     - c1x (number) x of the first anchor of the curve
	     - c1y (number) y of the first anchor of the curve
	     - c2x (number) x of the second anchor of the curve
	     - c2y (number) y of the second anchor of the curve
	     - p2x (number) x of the second point of the curve
	     - p2y (number) y of the second point of the curve
	     * or
	     - bez (array) array of six points for beziér curve
	     = (object) bounding box
	     o {
	     o     x: (number) x coordinate of the left top point of the box,
	     o     y: (number) y coordinate of the left top point of the box,
	     o     x2: (number) x coordinate of the right bottom point of the box,
	     o     y2: (number) y coordinate of the right bottom point of the box,
	     o     width: (number) width of the box,
	     o     height: (number) height of the box
	     o }
	    \*/
	    Snap.path.bezierBBox = bezierBBox;
	    /*\
	     * Snap.path.isPointInsideBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if given point is inside bounding box
	     - bbox (string) bounding box
	     - x (string) x coordinate of the point
	     - y (string) y coordinate of the point
	     = (boolean) `true` if point is inside
	    \*/
	    Snap.path.isPointInsideBBox = isPointInsideBBox;
	    Snap.closest = function (x, y, X, Y) {
	        var r = 100,
	            b = box(x - r / 2, y - r / 2, r, r),
	            inside = [],
	            getter = X[0].hasOwnProperty("x") ? function (i) {
	                return {
	                    x: X[i].x,
	                    y: X[i].y
	                };
	            } : function (i) {
	                return {
	                    x: X[i],
	                    y: Y[i]
	                };
	            },
	            found = 0;
	        while (r <= 1e6 && !found) {
	            for (var i = 0, ii = X.length; i < ii; i++) {
	                var xy = getter(i);
	                if (isPointInsideBBox(b, xy.x, xy.y)) {
	                    found++;
	                    inside.push(xy);
	                    break;
	                }
	            }
	            if (!found) {
	                r *= 2;
	                b = box(x - r / 2, y - r / 2, r, r)
	            }
	        }
	        if (r == 1e6) {
	            return;
	        }
	        var len = Infinity,
	            res;
	        for (i = 0, ii = inside.length; i < ii; i++) {
	            var l = Snap.len(x, y, inside[i].x, inside[i].y);
	            if (len > l) {
	                len = l;
	                inside[i].len = l;
	                res = inside[i];
	            }
	        }
	        return res;
	    };
	    /*\
	     * Snap.path.isBBoxIntersect
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if two bounding boxes intersect
	     - bbox1 (string) first bounding box
	     - bbox2 (string) second bounding box
	     = (boolean) `true` if bounding boxes intersect
	    \*/
	    Snap.path.isBBoxIntersect = isBBoxIntersect;
	    /*\
	     * Snap.path.intersection
	     [ method ]
	     **
	     * Utility method
	     **
	     * Finds intersections of two paths
	     - path1 (string) path string
	     - path2 (string) path string
	     = (array) dots of intersection
	     o [
	     o     {
	     o         x: (number) x coordinate of the point,
	     o         y: (number) y coordinate of the point,
	     o         t1: (number) t value for segment of path1,
	     o         t2: (number) t value for segment of path2,
	     o         segment1: (number) order number for segment of path1,
	     o         segment2: (number) order number for segment of path2,
	     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,
	     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
	     o     }
	     o ]
	    \*/
	    Snap.path.intersection = pathIntersection;
	    Snap.path.intersectionNumber = pathIntersectionNumber;
	    /*\
	     * Snap.path.isPointInside
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns `true` if given point is inside a given closed path.
	     *
	     * Note: fill mode doesn’t affect the result of this method.
	     - path (string) path string
	     - x (number) x of the point
	     - y (number) y of the point
	     = (boolean) `true` if point is inside the path
	    \*/
	    Snap.path.isPointInside = isPointInsidePath;
	    /*\
	     * Snap.path.getBBox
	     [ method ]
	     **
	     * Utility method
	     **
	     * Returns the bounding box of a given path
	     - path (string) path string
	     = (object) bounding box
	     o {
	     o     x: (number) x coordinate of the left top point of the box,
	     o     y: (number) y coordinate of the left top point of the box,
	     o     x2: (number) x coordinate of the right bottom point of the box,
	     o     y2: (number) y coordinate of the right bottom point of the box,
	     o     width: (number) width of the box,
	     o     height: (number) height of the box
	     o }
	    \*/
	    Snap.path.getBBox = pathBBox;
	    Snap.path.get = getPath;
	    /*\
	     * Snap.path.toRelative
	     [ method ]
	     **
	     * Utility method
	     **
	     * Converts path coordinates into relative values
	     - path (string) path string
	     = (array) path string
	    \*/
	    Snap.path.toRelative = pathToRelative;
	    /*\
	     * Snap.path.toAbsolute
	     [ method ]
	     **
	     * Utility method
	     **
	     * Converts path coordinates into absolute values
	     - path (string) path string
	     = (array) path string
	    \*/
	    Snap.path.toAbsolute = pathToAbsolute;
	    /*\
	     * Snap.path.toCubic
	     [ method ]
	     **
	     * Utility method
	     **
	     * Converts path to a new path where all segments are cubic beziér curves
	     - pathString (string|array) path string or array of segments
	     = (array) array of segments
	    \*/
	    Snap.path.toCubic = path2curve;
	    /*\
	     * Snap.path.map
	     [ method ]
	     **
	     * Transform the path string with the given matrix
	     - path (string) path string
	     - matrix (object) see @Matrix
	     = (string) transformed path string
	    \*/
	    Snap.path.map = mapPath;
	    Snap.path.toString = toString;
	    Snap.path.clone = pathClone;
	});

	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob) {
	    var mmax = Math.max,
	        mmin = Math.min;

	    // Set
	    var Set = function (items) {
	        this.items = [];
		this.bindings = {};
	        this.length = 0;
	        this.type = "set";
	        if (items) {
	            for (var i = 0, ii = items.length; i < ii; i++) {
	                if (items[i]) {
	                    this[this.items.length] = this.items[this.items.length] = items[i];
	                    this.length++;
	                }
	            }
	        }
	    },
	    setproto = Set.prototype;
	    /*\
	     * Set.push
	     [ method ]
	     **
	     * Adds each argument to the current set
	     = (object) original element
	    \*/
	    setproto.push = function () {
	        var item,
	            len;
	        for (var i = 0, ii = arguments.length; i < ii; i++) {
	            item = arguments[i];
	            if (item) {
	                len = this.items.length;
	                this[len] = this.items[len] = item;
	                this.length++;
	            }
	        }
	        return this;
	    };
	    /*\
	     * Set.pop
	     [ method ]
	     **
	     * Removes last element and returns it
	     = (object) element
	    \*/
	    setproto.pop = function () {
	        this.length && delete this[this.length--];
	        return this.items.pop();
	    };
	    /*\
	     * Set.forEach
	     [ method ]
	     **
	     * Executes given function for each element in the set
	     *
	     * If the function returns `false`, the loop stops running.
	     **
	     - callback (function) function to run
	     - thisArg (object) context object for the callback
	     = (object) Set object
	    \*/
	    setproto.forEach = function (callback, thisArg) {
	        for (var i = 0, ii = this.items.length; i < ii; i++) {
	            if (callback.call(thisArg, this.items[i], i) === false) {
	                return this;
	            }
	        }
	        return this;
	    };
	    /*\
	     * Set.animate
	     [ method ]
	     **
	     * Animates each element in set in sync.
	     *
	     **
	     - attrs (object) key-value pairs of destination attributes
	     - duration (number) duration of the animation in milliseconds
	     - easing (function) #optional easing function from @mina or custom
	     - callback (function) #optional callback function that executes when the animation ends
	     * or
	     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`
	     > Usage
	     | // animate all elements in set to radius 10
	     | set.animate({r: 10}, 500, mina.easein);
	     | // or
	     | // animate first element to radius 10, but second to radius 20 and in different time
	     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);
	     = (Element) the current element
	    \*/
	    setproto.animate = function (attrs, ms, easing, callback) {
	        if (typeof easing == "function" && !easing.length) {
	            callback = easing;
	            easing = mina.linear;
	        }
	        if (attrs instanceof Snap._.Animation) {
	            callback = attrs.callback;
	            easing = attrs.easing;
	            ms = easing.dur;
	            attrs = attrs.attr;
	        }
	        var args = arguments;
	        if (Snap.is(attrs, "array") && Snap.is(args[args.length - 1], "array")) {
	            var each = true;
	        }
	        var begin,
	            handler = function () {
	                if (begin) {
	                    this.b = begin;
	                } else {
	                    begin = this.b;
	                }
	            },
	            cb = 0,
	            set = this,
	            callbacker = callback && function () {
	                if (++cb == set.length) {
	                    callback.call(this);
	                }
	            };
	        return this.forEach(function (el, i) {
	            eve.once("snap.animcreated." + el.id, handler);
	            if (each) {
	                args[i] && el.animate.apply(el, args[i]);
	            } else {
	                el.animate(attrs, ms, easing, callbacker);
	            }
	        });
	    };
	    setproto.remove = function () {
	        while (this.length) {
	            this.pop().remove();
	        }
	        return this;
	    };
	    /*\
	     * Set.bind
	     [ method ]
	     **
	     * Specifies how to handle a specific attribute when applied
	     * to a set.
	     *
	     **
	     - attr (string) attribute name
	     - callback (function) function to run
	     * or
	     - attr (string) attribute name
	     - element (Element) specific element in the set to apply the attribute to
	     * or
	     - attr (string) attribute name
	     - element (Element) specific element in the set to apply the attribute to
	     - eattr (string) attribute on the element to bind the attribute to
	     = (object) Set object
	    \*/
	    setproto.bind = function (attr, a, b) {
	        var data = {};
	        if (typeof a == "function") {
	            this.bindings[attr] = a;
	        } else {
	            var aname = b || attr;
	            this.bindings[attr] = function (v) {
	                data[aname] = v;
	                a.attr(data);
	            };
	        }
	        return this;
	    };
	    setproto.attr = function (value) {
	        var unbound = {};
	        for (var k in value) {
	            if (this.bindings[k]) {
	                this.bindings[k](value[k]);
	            } else {
	                unbound[k] = value[k];
	            }
	        }
	        for (var i = 0, ii = this.items.length; i < ii; i++) {
	            this.items[i].attr(unbound);
	        }
	        return this;
	    };
	    /*\
	     * Set.clear
	     [ method ]
	     **
	     * Removes all elements from the set
	    \*/
	    setproto.clear = function () {
	        while (this.length) {
	            this.pop();
	        }
	    };
	    /*\
	     * Set.splice
	     [ method ]
	     **
	     * Removes range of elements from the set
	     **
	     - index (number) position of the deletion
	     - count (number) number of element to remove
	     - insertion… (object) #optional elements to insert
	     = (object) set elements that were deleted
	    \*/
	    setproto.splice = function (index, count, insertion) {
	        index = index < 0 ? mmax(this.length + index, 0) : index;
	        count = mmax(0, mmin(this.length - index, count));
	        var tail = [],
	            todel = [],
	            args = [],
	            i;
	        for (i = 2; i < arguments.length; i++) {
	            args.push(arguments[i]);
	        }
	        for (i = 0; i < count; i++) {
	            todel.push(this[index + i]);
	        }
	        for (; i < this.length - index; i++) {
	            tail.push(this[index + i]);
	        }
	        var arglen = args.length;
	        for (i = 0; i < arglen + tail.length; i++) {
	            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
	        }
	        i = this.items.length = this.length -= count - arglen;
	        while (this[i]) {
	            delete this[i++];
	        }
	        return new Set(todel);
	    };
	    /*\
	     * Set.exclude
	     [ method ]
	     **
	     * Removes given element from the set
	     **
	     - element (object) element to remove
	     = (boolean) `true` if object was found and removed from the set
	    \*/
	    setproto.exclude = function (el) {
	        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
	            this.splice(i, 1);
	            return true;
	        }
	        return false;
	    };
	    setproto.insertAfter = function (el) {
	        var i = this.items.length;
	        while (i--) {
	            this.items[i].insertAfter(el);
	        }
	        return this;
	    };
	    setproto.getBBox = function () {
	        var x = [],
	            y = [],
	            x2 = [],
	            y2 = [];
	        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
	            var box = this.items[i].getBBox();
	            x.push(box.x);
	            y.push(box.y);
	            x2.push(box.x + box.width);
	            y2.push(box.y + box.height);
	        }
	        x = mmin.apply(0, x);
	        y = mmin.apply(0, y);
	        x2 = mmax.apply(0, x2);
	        y2 = mmax.apply(0, y2);
	        return {
	            x: x,
	            y: y,
	            x2: x2,
	            y2: y2,
	            width: x2 - x,
	            height: y2 - y,
	            cx: x + (x2 - x) / 2,
	            cy: y + (y2 - y) / 2
	        };
	    };
	    setproto.clone = function (s) {
	        s = new Set;
	        for (var i = 0, ii = this.items.length; i < ii; i++) {
	            s.push(this.items[i].clone());
	        }
	        return s;
	    };
	    setproto.toString = function () {
	        return "Snap\u2018s set";
	    };
	    setproto.type = "set";
	    // export
	    Snap.Set = Set;
	    Snap.set = function () {
	        var set = new Set;
	        if (arguments.length) {
	            set.push.apply(set, Array.prototype.slice.call(arguments, 0));
	        }
	        return set;
	    };
	});

	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob) {
	    var names = {},
	        reUnit = /[a-z]+$/i,
	        Str = String;
	    names.stroke = names.fill = "colour";
	    function getEmpty(item) {
	        var l = item[0];
	        switch (l.toLowerCase()) {
	            case "t": return [l, 0, 0];
	            case "m": return [l, 1, 0, 0, 1, 0, 0];
	            case "r": if (item.length == 4) {
	                return [l, 0, item[2], item[3]];
	            } else {
	                return [l, 0];
	            }
	            case "s": if (item.length == 5) {
	                return [l, 1, 1, item[3], item[4]];
	            } else if (item.length == 3) {
	                return [l, 1, 1];
	            } else {
	                return [l, 1];
	            }
	        }
	    }
	    function equaliseTransform(t1, t2, getBBox) {
	        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
	        t1 = Snap.parseTransformString(t1) || [];
	        t2 = Snap.parseTransformString(t2) || [];
	        var maxlength = Math.max(t1.length, t2.length),
	            from = [],
	            to = [],
	            i = 0, j, jj,
	            tt1, tt2;
	        for (; i < maxlength; i++) {
	            tt1 = t1[i] || getEmpty(t2[i]);
	            tt2 = t2[i] || getEmpty(tt1);
	            if ((tt1[0] != tt2[0]) ||
	                (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
	                (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
	                ) {
	                    t1 = Snap._.transform2matrix(t1, getBBox());
	                    t2 = Snap._.transform2matrix(t2, getBBox());
	                    from = [["m", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];
	                    to = [["m", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];
	                    break;
	            }
	            from[i] = [];
	            to[i] = [];
	            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {
	                j in tt1 && (from[i][j] = tt1[j]);
	                j in tt2 && (to[i][j] = tt2[j]);
	            }
	        }
	        return {
	            from: path2array(from),
	            to: path2array(to),
	            f: getPath(from)
	        };
	    }
	    function getNumber(val) {
	        return val;
	    }
	    function getUnit(unit) {
	        return function (val) {
	            return +val.toFixed(3) + unit;
	        };
	    }
	    function getViewBox(val) {
	        return val.join(" ");
	    }
	    function getColour(clr) {
	        return Snap.rgb(clr[0], clr[1], clr[2]);
	    }
	    function getPath(path) {
	        var k = 0, i, ii, j, jj, out, a, b = [];
	        for (i = 0, ii = path.length; i < ii; i++) {
	            out = "[";
	            a = ['"' + path[i][0] + '"'];
	            for (j = 1, jj = path[i].length; j < jj; j++) {
	                a[j] = "val[" + (k++) + "]";
	            }
	            out += a + "]";
	            b[i] = out;
	        }
	        return Function("val", "return Snap.path.toString.call([" + b + "])");
	    }
	    function path2array(path) {
	        var out = [];
	        for (var i = 0, ii = path.length; i < ii; i++) {
	            for (var j = 1, jj = path[i].length; j < jj; j++) {
	                out.push(path[i][j]);
	            }
	        }
	        return out;
	    }
	    function isNumeric(obj) {
	        return isFinite(parseFloat(obj));
	    }
	    function arrayEqual(arr1, arr2) {
	        if (!Snap.is(arr1, "array") || !Snap.is(arr2, "array")) {
	            return false;
	        }
	        return arr1.toString() == arr2.toString();
	    }
	    Element.prototype.equal = function (name, b) {
	        return eve("snap.util.equal", this, name, b).firstDefined();
	    };
	    eve.on("snap.util.equal", function (name, b) {
	        var A, B, a = Str(this.attr(name) || ""),
	            el = this;
	        if (isNumeric(a) && isNumeric(b)) {
	            return {
	                from: parseFloat(a),
	                to: parseFloat(b),
	                f: getNumber
	            };
	        }
	        if (names[name] == "colour") {
	            A = Snap.color(a);
	            B = Snap.color(b);
	            return {
	                from: [A.r, A.g, A.b, A.opacity],
	                to: [B.r, B.g, B.b, B.opacity],
	                f: getColour
	            };
	        }
	        if (name == "viewBox") {
	            A = this.attr(name).vb.split(" ").map(Number);
	            B = b.split(" ").map(Number);
	            return {
	                from: A,
	                to: B,
	                f: getViewBox
	            };
	        }
	        if (name == "transform" || name == "gradientTransform" || name == "patternTransform") {
	            if (b instanceof Snap.Matrix) {
	                b = b.toTransformString();
	            }
	            if (!Snap._.rgTransform.test(b)) {
	                b = Snap._.svgTransform2string(b);
	            }
	            return equaliseTransform(a, b, function () {
	                return el.getBBox(1);
	            });
	        }
	        if (name == "d" || name == "path") {
	            A = Snap.path.toCubic(a, b);
	            return {
	                from: path2array(A[0]),
	                to: path2array(A[1]),
	                f: getPath(A[0])
	            };
	        }
	        if (name == "points") {
	            A = Str(a).split(Snap._.separator);
	            B = Str(b).split(Snap._.separator);
	            return {
	                from: A,
	                to: B,
	                f: function (val) { return val; }
	            };
	        }
	        var aUnit = a.match(reUnit),
	            bUnit = Str(b).match(reUnit);
	        if (aUnit && arrayEqual(aUnit, bUnit)) {
	            return {
	                from: parseFloat(a),
	                to: parseFloat(b),
	                f: getUnit(aUnit)
	            };
	        } else {
	            return {
	                from: this.asPX(name),
	                to: this.asPX(name, b),
	                f: getNumber
	            };
	        }
	    });
	});

	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob) {
	    var elproto = Element.prototype,
	    has = "hasOwnProperty",
	    supportsTouch = "createTouch" in glob.doc,
	    events = [
	        "click", "dblclick", "mousedown", "mousemove", "mouseout",
	        "mouseover", "mouseup", "touchstart", "touchmove", "touchend",
	        "touchcancel"
	    ],
	    touchMap = {
	        mousedown: "touchstart",
	        mousemove: "touchmove",
	        mouseup: "touchend"
	    },
	    getScroll = function (xy, el) {
	        var name = xy == "y" ? "scrollTop" : "scrollLeft",
	            doc = el && el.node ? el.node.ownerDocument : glob.doc;
	        return doc[name in doc.documentElement ? "documentElement" : "body"][name];
	    },
	    preventDefault = function () {
	        this.returnValue = false;
	    },
	    preventTouch = function () {
	        return this.originalEvent.preventDefault();
	    },
	    stopPropagation = function () {
	        this.cancelBubble = true;
	    },
	    stopTouch = function () {
	        return this.originalEvent.stopPropagation();
	    },
	    addEvent = function (obj, type, fn, element) {
	        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
	            f = function (e) {
	                var scrollY = getScroll("y", element),
	                    scrollX = getScroll("x", element);
	                if (supportsTouch && touchMap[has](type)) {
	                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
	                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
	                            var olde = e;
	                            e = e.targetTouches[i];
	                            e.originalEvent = olde;
	                            e.preventDefault = preventTouch;
	                            e.stopPropagation = stopTouch;
	                            break;
	                        }
	                    }
	                }
	                var x = e.clientX + scrollX,
	                    y = e.clientY + scrollY;
	                return fn.call(element, e, x, y);
	            };

	        if (type !== realName) {
	            obj.addEventListener(type, f, false);
	        }

	        obj.addEventListener(realName, f, false);

	        return function () {
	            if (type !== realName) {
	                obj.removeEventListener(type, f, false);
	            }

	            obj.removeEventListener(realName, f, false);
	            return true;
	        };
	    },
	    drag = [],
	    dragMove = function (e) {
	        var x = e.clientX,
	            y = e.clientY,
	            scrollY = getScroll("y"),
	            scrollX = getScroll("x"),
	            dragi,
	            j = drag.length;
	        while (j--) {
	            dragi = drag[j];
	            if (supportsTouch) {
	                var i = e.touches && e.touches.length,
	                    touch;
	                while (i--) {
	                    touch = e.touches[i];
	                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
	                        x = touch.clientX;
	                        y = touch.clientY;
	                        (e.originalEvent ? e.originalEvent : e).preventDefault();
	                        break;
	                    }
	                }
	            } else {
	                e.preventDefault();
	            }
	            var node = dragi.el.node,
	                o,
	                next = node.nextSibling,
	                parent = node.parentNode,
	                display = node.style.display;
	            // glob.win.opera && parent.removeChild(node);
	            // node.style.display = "none";
	            // o = dragi.el.paper.getElementByPoint(x, y);
	            // node.style.display = display;
	            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
	            // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
	            x += scrollX;
	            y += scrollY;
	            eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
	        }
	    },
	    dragUp = function (e) {
	        Snap.unmousemove(dragMove).unmouseup(dragUp);
	        var i = drag.length,
	            dragi;
	        while (i--) {
	            dragi = drag[i];
	            dragi.el._drag = {};
	            eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
	            eve.off("snap.drag.*." + dragi.el.id);
	        }
	        drag = [];
	    };
	    /*\
	     * Element.click
	     [ method ]
	     **
	     * Adds a click event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unclick
	     [ method ]
	     **
	     * Removes a click event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    
	    /*\
	     * Element.dblclick
	     [ method ]
	     **
	     * Adds a double click event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.undblclick
	     [ method ]
	     **
	     * Removes a double click event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    
	    /*\
	     * Element.mousedown
	     [ method ]
	     **
	     * Adds a mousedown event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unmousedown
	     [ method ]
	     **
	     * Removes a mousedown event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    
	    /*\
	     * Element.mousemove
	     [ method ]
	     **
	     * Adds a mousemove event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unmousemove
	     [ method ]
	     **
	     * Removes a mousemove event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    
	    /*\
	     * Element.mouseout
	     [ method ]
	     **
	     * Adds a mouseout event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unmouseout
	     [ method ]
	     **
	     * Removes a mouseout event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    
	    /*\
	     * Element.mouseover
	     [ method ]
	     **
	     * Adds a mouseover event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unmouseover
	     [ method ]
	     **
	     * Removes a mouseover event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    
	    /*\
	     * Element.mouseup
	     [ method ]
	     **
	     * Adds a mouseup event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.unmouseup
	     [ method ]
	     **
	     * Removes a mouseup event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    
	    /*\
	     * Element.touchstart
	     [ method ]
	     **
	     * Adds a touchstart event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.untouchstart
	     [ method ]
	     **
	     * Removes a touchstart event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    
	    /*\
	     * Element.touchmove
	     [ method ]
	     **
	     * Adds a touchmove event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.untouchmove
	     [ method ]
	     **
	     * Removes a touchmove event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    
	    /*\
	     * Element.touchend
	     [ method ]
	     **
	     * Adds a touchend event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.untouchend
	     [ method ]
	     **
	     * Removes a touchend event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    
	    /*\
	     * Element.touchcancel
	     [ method ]
	     **
	     * Adds a touchcancel event handler to the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    /*\
	     * Element.untouchcancel
	     [ method ]
	     **
	     * Removes a touchcancel event handler from the element
	     - handler (function) handler for the event
	     = (object) @Element
	    \*/
	    for (var i = events.length; i--;) {
	        (function (eventName) {
	            Snap[eventName] = elproto[eventName] = function (fn, scope) {
	                if (Snap.is(fn, "function")) {
	                    this.events = this.events || [];
	                    this.events.push({
	                        name: eventName,
	                        f: fn,
	                        unbind: addEvent(this.node || document, eventName, fn, scope || this)
	                    });
	                } else {
	                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {
	                        try {
	                            this.events[i].f.call(this);
	                        } catch (e) {}
	                    }
	                }
	                return this;
	            };
	            Snap["un" + eventName] =
	            elproto["un" + eventName] = function (fn) {
	                var events = this.events || [],
	                    l = events.length;
	                while (l--) if (events[l].name == eventName &&
	                               (events[l].f == fn || !fn)) {
	                    events[l].unbind();
	                    events.splice(l, 1);
	                    !events.length && delete this.events;
	                    return this;
	                }
	                return this;
	            };
	        })(events[i]);
	    }
	    /*\
	     * Element.hover
	     [ method ]
	     **
	     * Adds hover event handlers to the element
	     - f_in (function) handler for hover in
	     - f_out (function) handler for hover out
	     - icontext (object) #optional context for hover in handler
	     - ocontext (object) #optional context for hover out handler
	     = (object) @Element
	    \*/
	    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
	        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
	    };
	    /*\
	     * Element.unhover
	     [ method ]
	     **
	     * Removes hover event handlers from the element
	     - f_in (function) handler for hover in
	     - f_out (function) handler for hover out
	     = (object) @Element
	    \*/
	    elproto.unhover = function (f_in, f_out) {
	        return this.unmouseover(f_in).unmouseout(f_out);
	    };
	    var draggable = [];
	    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
	    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
	    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
	    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
	    /*\
	     * Element.drag
	     [ method ]
	     **
	     * Adds event handlers for an element's drag gesture
	     **
	     - onmove (function) handler for moving
	     - onstart (function) handler for drag start
	     - onend (function) handler for drag end
	     - mcontext (object) #optional context for moving handler
	     - scontext (object) #optional context for drag start handler
	     - econtext (object) #optional context for drag end handler
	     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, 
	     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element 
	     * `drag.over.<id>` fires as well.
	     *
	     * Start event and start handler are called in specified context or in context of the element with following parameters:
	     o x (number) x position of the mouse
	     o y (number) y position of the mouse
	     o event (object) DOM event object
	     * Move event and move handler are called in specified context or in context of the element with following parameters:
	     o dx (number) shift by x from the start point
	     o dy (number) shift by y from the start point
	     o x (number) x position of the mouse
	     o y (number) y position of the mouse
	     o event (object) DOM event object
	     * End event and end handler are called in specified context or in context of the element with following parameters:
	     o event (object) DOM event object
	     = (object) @Element
	    \*/
	    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
	        var el = this;
	        if (!arguments.length) {
	            var origTransform;
	            return el.drag(function (dx, dy) {
	                this.attr({
	                    transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
	                });
	            }, function () {
	                origTransform = this.transform().local;
	            });
	        }
	        function start(e, x, y) {
	            (e.originalEvent || e).preventDefault();
	            el._drag.x = x;
	            el._drag.y = y;
	            el._drag.id = e.identifier;
	            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
	            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
	            onstart && eve.on("snap.drag.start." + el.id, onstart);
	            onmove && eve.on("snap.drag.move." + el.id, onmove);
	            onend && eve.on("snap.drag.end." + el.id, onend);
	            eve("snap.drag.start." + el.id, start_scope || move_scope || el, x, y, e);
	        }
	        function init(e, x, y) {
	            eve("snap.draginit." + el.id, el, e, x, y);
	        }
	        eve.on("snap.draginit." + el.id, start);
	        el._drag = {};
	        draggable.push({el: el, start: start, init: init});
	        el.mousedown(init);
	        return el;
	    };
	    /*
	     * Element.onDragOver
	     [ method ]
	     **
	     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
	     - f (function) handler for event, first argument would be the element you are dragging over
	    \*/
	    // elproto.onDragOver = function (f) {
	    //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
	    // };
	    /*\
	     * Element.undrag
	     [ method ]
	     **
	     * Removes all drag event handlers from the given element
	    \*/
	    elproto.undrag = function () {
	        var i = draggable.length;
	        while (i--) if (draggable[i].el == this) {
	            this.unmousedown(draggable[i].init);
	            draggable.splice(i, 1);
	            eve.unbind("snap.drag.*." + this.id);
	            eve.unbind("snap.draginit." + this.id);
	        }
	        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
	        return this;
	    };
	});

	// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
	// 
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	// 
	// http://www.apache.org/licenses/LICENSE-2.0
	// 
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob) {
	    var elproto = Element.prototype,
	        pproto = Paper.prototype,
	        rgurl = /^\s*url\((.+)\)/,
	        Str = String,
	        $ = Snap._.$;
	    Snap.filter = {};
	    /*\
	     * Paper.filter
	     [ method ]
	     **
	     * Creates a `<filter>` element
	     **
	     - filstr (string) SVG fragment of filter provided as a string
	     = (object) @Element
	     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
	     > Usage
	     | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
	     |     c = paper.circle(10, 10, 10).attr({
	     |         filter: f
	     |     });
	    \*/
	    pproto.filter = function (filstr) {
	        var paper = this;
	        if (paper.type != "svg") {
	            paper = paper.paper;
	        }
	        var f = Snap.parse(Str(filstr)),
	            id = Snap._.id(),
	            width = paper.node.offsetWidth,
	            height = paper.node.offsetHeight,
	            filter = $("filter");
	        $(filter, {
	            id: id,
	            filterUnits: "userSpaceOnUse"
	        });
	        filter.appendChild(f.node);
	        paper.defs.appendChild(filter);
	        return new Element(filter);
	    };
	    
	    eve.on("snap.util.getattr.filter", function () {
	        eve.stop();
	        var p = $(this.node, "filter");
	        if (p) {
	            var match = Str(p).match(rgurl);
	            return match && Snap.select(match[1]);
	        }
	    });
	    eve.on("snap.util.attr.filter", function (value) {
	        if (value instanceof Element && value.type == "filter") {
	            eve.stop();
	            var id = value.node.id;
	            if (!id) {
	                $(value.node, {id: value.id});
	                id = value.id;
	            }
	            $(this.node, {
	                filter: Snap.url(id)
	            });
	        }
	        if (!value || value == "none") {
	            eve.stop();
	            this.node.removeAttribute("filter");
	        }
	    });
	    /*\
	     * Snap.filter.blur
	     [ method ]
	     **
	     * Returns an SVG markup string for the blur filter
	     **
	     - x (number) amount of horizontal blur, in pixels
	     - y (number) #optional amount of vertical blur, in pixels
	     = (string) filter representation
	     > Usage
	     | var f = paper.filter(Snap.filter.blur(5, 10)),
	     |     c = paper.circle(10, 10, 10).attr({
	     |         filter: f
	     |     });
	    \*/
	    Snap.filter.blur = function (x, y) {
	        if (x == null) {
	            x = 2;
	        }
	        var def = y == null ? x : [x, y];
	        return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
	            def: def
	        });
	    };
	    Snap.filter.blur.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.shadow
	     [ method ]
	     **
	     * Returns an SVG markup string for the shadow filter
	     **
	     - dx (number) #optional horizontal shift of the shadow, in pixels
	     - dy (number) #optional vertical shift of the shadow, in pixels
	     - blur (number) #optional amount of blur
	     - color (string) #optional color of the shadow
	     - opacity (number) #optional `0..1` opacity of the shadow
	     * or
	     - dx (number) #optional horizontal shift of the shadow, in pixels
	     - dy (number) #optional vertical shift of the shadow, in pixels
	     - color (string) #optional color of the shadow
	     - opacity (number) #optional `0..1` opacity of the shadow
	     * which makes blur default to `4`. Or
	     - dx (number) #optional horizontal shift of the shadow, in pixels
	     - dy (number) #optional vertical shift of the shadow, in pixels
	     - opacity (number) #optional `0..1` opacity of the shadow
	     = (string) filter representation
	     > Usage
	     | var f = paper.filter(Snap.filter.shadow(0, 2, 3)),
	     |     c = paper.circle(10, 10, 10).attr({
	     |         filter: f
	     |     });
	    \*/
	    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {
	        if (typeof blur == "string") {
	            color = blur;
	            opacity = color;
	            blur = 4;
	        }
	        if (typeof color != "string") {
	            opacity = color;
	            color = "#000";
	        }
	        color = color || "#000";
	        if (blur == null) {
	            blur = 4;
	        }
	        if (opacity == null) {
	            opacity = 1;
	        }
	        if (dx == null) {
	            dx = 0;
	            dy = 2;
	        }
	        if (dy == null) {
	            dy = dx;
	        }
	        color = Snap.color(color);
	        return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
	            color: color,
	            dx: dx,
	            dy: dy,
	            blur: blur,
	            opacity: opacity
	        });
	    };
	    Snap.filter.shadow.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.grayscale
	     [ method ]
	     **
	     * Returns an SVG markup string for the grayscale filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.grayscale = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
	            a: 0.2126 + 0.7874 * (1 - amount),
	            b: 0.7152 - 0.7152 * (1 - amount),
	            c: 0.0722 - 0.0722 * (1 - amount),
	            d: 0.2126 - 0.2126 * (1 - amount),
	            e: 0.7152 + 0.2848 * (1 - amount),
	            f: 0.0722 - 0.0722 * (1 - amount),
	            g: 0.2126 - 0.2126 * (1 - amount),
	            h: 0.0722 + 0.9278 * (1 - amount)
	        });
	    };
	    Snap.filter.grayscale.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.sepia
	     [ method ]
	     **
	     * Returns an SVG markup string for the sepia filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.sepia = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
	            a: 0.393 + 0.607 * (1 - amount),
	            b: 0.769 - 0.769 * (1 - amount),
	            c: 0.189 - 0.189 * (1 - amount),
	            d: 0.349 - 0.349 * (1 - amount),
	            e: 0.686 + 0.314 * (1 - amount),
	            f: 0.168 - 0.168 * (1 - amount),
	            g: 0.272 - 0.272 * (1 - amount),
	            h: 0.534 - 0.534 * (1 - amount),
	            i: 0.131 + 0.869 * (1 - amount)
	        });
	    };
	    Snap.filter.sepia.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.saturate
	     [ method ]
	     **
	     * Returns an SVG markup string for the saturate filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.saturate = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	        return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
	            amount: 1 - amount
	        });
	    };
	    Snap.filter.saturate.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.hueRotate
	     [ method ]
	     **
	     * Returns an SVG markup string for the hue-rotate filter
	     **
	     - angle (number) angle of rotation
	     = (string) filter representation
	    \*/
	    Snap.filter.hueRotate = function (angle) {
	        angle = angle || 0;
	        return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
	            angle: angle
	        });
	    };
	    Snap.filter.hueRotate.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.invert
	     [ method ]
	     **
	     * Returns an SVG markup string for the invert filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.invert = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	//        <feColorMatrix type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0" color-interpolation-filters="sRGB"/>
	        return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
	            amount: amount,
	            amount2: 1 - amount
	        });
	    };
	    Snap.filter.invert.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.brightness
	     [ method ]
	     **
	     * Returns an SVG markup string for the brightness filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.brightness = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
	            amount: amount
	        });
	    };
	    Snap.filter.brightness.toString = function () {
	        return this();
	    };
	    /*\
	     * Snap.filter.contrast
	     [ method ]
	     **
	     * Returns an SVG markup string for the contrast filter
	     **
	     - amount (number) amount of filter (`0..1`)
	     = (string) filter representation
	    \*/
	    Snap.filter.contrast = function (amount) {
	        if (amount == null) {
	            amount = 1;
	        }
	        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
	            amount: amount,
	            amount2: .5 - amount / 2
	        });
	    };
	    Snap.filter.contrast.toString = function () {
	        return this();
	    };
	});

	// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
	//
	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	// http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
	    var box = Snap._.box,
	        is = Snap.is,
	        firstLetter = /^[^a-z]*([tbmlrc])/i,
	        toString = function () {
	            return "T" + this.dx + "," + this.dy;
	        };
	    /*\
	     * Element.getAlign
	     [ method ]
	     **
	     * Returns shift needed to align the element relatively to given element.
	     * If no elements specified, parent `<svg>` container will be used.
	     - el (object) @optional alignment element
	     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
	     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string
	     > Usage
	     | el.transform(el.getAlign(el2, "top"));
	     * or
	     | var dy = el.getAlign(el2, "top").dy;
	    \*/
	    Element.prototype.getAlign = function (el, way) {
	        if (way == null && is(el, "string")) {
	            way = el;
	            el = null;
	        }
	        el = el || this.paper;
	        var bx = el.getBBox ? el.getBBox() : box(el),
	            bb = this.getBBox(),
	            out = {};
	        way = way && way.match(firstLetter);
	        way = way ? way[1].toLowerCase() : "c";
	        switch (way) {
	            case "t":
	                out.dx = 0;
	                out.dy = bx.y - bb.y;
	            break;
	            case "b":
	                out.dx = 0;
	                out.dy = bx.y2 - bb.y2;
	            break;
	            case "m":
	                out.dx = 0;
	                out.dy = bx.cy - bb.cy;
	            break;
	            case "l":
	                out.dx = bx.x - bb.x;
	                out.dy = 0;
	            break;
	            case "r":
	                out.dx = bx.x2 - bb.x2;
	                out.dy = 0;
	            break;
	            default:
	                out.dx = bx.cx - bb.cx;
	                out.dy = 0;
	            break;
	        }
	        out.toString = toString;
	        return out;
	    };
	    /*\
	     * Element.align
	     [ method ]
	     **
	     * Aligns the element relatively to given one via transformation.
	     * If no elements specified, parent `<svg>` container will be used.
	     - el (object) @optional alignment element
	     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
	     = (object) this element
	     > Usage
	     | el.align(el2, "top");
	     * or
	     | el.align("middle");
	    \*/
	    Element.prototype.align = function (el, way) {
	        return this.transform("..." + this.getAlign(el, way));
	    };
	});

	return Snap;
	}));
	}.call(window));

/***/ },
/* 616 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(139);
	var ResolvePathToIcon = __webpack_require__(617).ResolvePathToIcon;
	__webpack_require__(669);

	var SelectionIcon = React.createClass({
	    displayName: "SelectionIcon",

	    propTypes: {
	        pathToFolderWithBundledResources: React.PropTypes.string.isRequired,
	        anatomogramType: React.PropTypes.oneOf(["brain", "female", "male", "whole_plant", "flower_parts"]).isRequired,
	        selected: React.PropTypes.bool.isRequired,
	        onClick: React.PropTypes.func.isRequired
	    },

	    render: function render() {
	        return React.createElement("img", { className: "selection-icon", onClick: this.props.onClick,
	            src: ResolvePathToIcon(this.props.pathToFolderWithBundledResources, this.props.anatomogramType, this.props.selected) });
	    },
	    shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	        return this.props.selected !== nextProps.selected;
	    }
	});

	module.exports = SelectionIcon;

/***/ },
/* 617 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Url = __webpack_require__(618);
	var Path = __webpack_require__(623);
	var SvgsForSpecies = __webpack_require__(624);
	var IdsForSvgs = __webpack_require__(625);

	var ResolvePathToIcon = function ResolvePathToIcon(pathToFolderWithBundledResources, type, selected) {
	    return Url.resolve(pathToFolderWithBundledResources, Path.basename(__webpack_require__(626)("./" + type + "_" + (selected ? "" : "un") + "selected.png")));
	};

	var ResolvePathToSvg = function ResolvePathToSvg(pathToFolderWithBundledResources, svg) {
	    return Url.resolve(pathToFolderWithBundledResources, Path.basename(__webpack_require__(637)("./" + svg)));
	};

	var GetSvgsForSpecies = function GetSvgsForSpecies(pathToFolderWithBundledResources, species) {
	    var svgEntry = SvgsForSpecies[species];
	    if (typeof svgEntry === "object") {
	        return Object.keys(svgEntry).map(function (anatomogramType) {
	            return {
	                type: anatomogramType,
	                path: ResolvePathToSvg(pathToFolderWithBundledResources, svgEntry[anatomogramType]),
	                ids: IdsForSvgs[svgEntry[anatomogramType]]
	            };
	        });
	    } else if (typeof svgEntry === "string") {
	        return [{
	            type: "svg",
	            path: ResolvePathToSvg(pathToFolderWithBundledResources, svgEntry),
	            ids: IdsForSvgs[svgEntry]
	        }];
	    } else {
	        return [];
	    }
	};

	module.exports = { GetSvgsForSpecies: GetSvgsForSpecies, ResolvePathToIcon: ResolvePathToIcon };

/***/ },
/* 618 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(619);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(620);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 619 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)(module), (function() { return this; }())))

/***/ },
/* 620 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(621);
	exports.encode = exports.stringify = __webpack_require__(622);


/***/ },
/* 621 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 622 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 623 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29)))

/***/ },
/* 624 */
/***/ function(module, exports) {

	module.exports = {
		"anolis carolinensis": "anolis_carolinensis.svg",
		"arabidopsis thaliana": "arabidopsis_thaliana_whole_plant.svg",
		"bos taurus": "cow.svg",
		"brachypodium distachyon": {
			"whole_plant": "brachypodium_distachyon_whole_plant.svg",
			"flower_parts": "brachypodium_distachyon_flower_parts.svg"
		},
		"gallus gallus": "chicken.svg",
		"homo sapiens": {
			"male": "human_male.svg",
			"female": "human_female.svg",
			"brain": "human_brain.svg"
		},
		"hordeum vulgare": {
			"whole_plant": "hordeum_vulgare_whole_plant.svg",
			"flower_parts": "hordeum_vulgare_flower_parts.svg"
		},
		"hordeum vulgare subsp. vulgare": {
			"whole_plant": "hordeum_vulgare_whole_plant.svg",
			"flower_parts": "hordeum_vulgare_flower_parts.svg"
		},
		"macaca mulatta": "macaca_mulatta.svg",
		"monodelphis domestica": "monodelphis_domestica.svg",
		"mus musculus": {
			"male": "mouse_male.svg",
			"female": "mouse_female.svg",
			"brain": "mouse_brain.svg"
		},
		"oryza sativa": {
			"whole_plant": "oryza_sativa_whole_plant.svg",
			"flower_parts": "oryza_sativa_flower_parts.svg"
		},
		"oryza sativa japonica group": {
			"whole_plant": "oryza_sativa_whole_plant.svg",
			"flower_parts": "oryza_sativa_flower_parts.svg"
		},
		"papio anubis": "papio_anubis.svg",
		"rattus norvegicus": "rat.svg",
		"solanum lycopersicum": {
			"whole_plant": "solanum_lycopersicum_whole_plant.svg",
			"flower_parts": "solanum_lycopersicum_flower_parts.svg"
		},
		"sorghum bicolor": {
			"whole_plant": "sorghum_bicolor_whole_plant.svg",
			"flower_parts": "sorghum_bicolor_flower_parts.svg"
		},
		"triticum aestivum": {
			"whole_plant": "triticum_aestivum_whole_plant.svg",
			"flower_parts": "triticum_aestivum_flower_parts.svg"
		},
		"tetraodon nigrovirdis": "tetraodon_nigroviridis.svg",
		"xenopus tropicalis": "xenopus_tropicalis.svg",
		"zea mays": {
			"whole_plant": "zea_mays_whole_plant.svg",
			"flower_parts": "zea_mays_flower_parts.svg"
		}
	};

/***/ },
/* 625 */
/***/ function(module, exports) {

	module.exports = {
		"mouse_female.svg": [
			"UBERON_0000010",
			"UBERON_0000014",
			"UBERON_0000029",
			"UBERON_0000945",
			"UBERON_0000947",
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0000970",
			"UBERON_0000981",
			"UBERON_0000990",
			"UBERON_0000995",
			"UBERON_0000996",
			"UBERON_0001009",
			"UBERON_0001043",
			"UBERON_0001103",
			"UBERON_0001132",
			"UBERON_0001153",
			"UBERON_0001155",
			"UBERON_0001211",
			"UBERON_0001242",
			"UBERON_0001255",
			"UBERON_0001264",
			"UBERON_0001322",
			"UBERON_0001347",
			"UBERON_0001348",
			"UBERON_0001377",
			"UBERON_0001645",
			"UBERON_0001723",
			"UBERON_0001736",
			"UBERON_0001831",
			"UBERON_0001911",
			"UBERON_0001981",
			"UBERON_0002046",
			"UBERON_0002048",
			"UBERON_0002103",
			"UBERON_0002106",
			"UBERON_0002107",
			"UBERON_0002108",
			"UBERON_0002110",
			"UBERON_0002113",
			"UBERON_0002114",
			"UBERON_0002115",
			"UBERON_0002116",
			"UBERON_0002240",
			"UBERON_0002369",
			"UBERON_0002370",
			"UBERON_0002371",
			"UBERON_0003126",
			"UBERON_0003134",
			"UBERON_0007844",
			"UBERON_0014892"
		],
		"brachypodium_distachyon_flower_parts.svg": [
			"PO_0009001",
			"PO_0009009",
			"PO_0009030",
			"PO_0009066",
			"PO_0009089"
		],
		"mouse_male.svg": [
			"UBERON_0000010",
			"UBERON_0000014",
			"UBERON_0000029",
			"UBERON_0000473",
			"UBERON_0000945",
			"UBERON_0000947",
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0000970",
			"UBERON_0000981",
			"UBERON_0000989",
			"UBERON_0000998",
			"UBERON_0001000",
			"UBERON_0001009",
			"UBERON_0001043",
			"UBERON_0001103",
			"UBERON_0001132",
			"UBERON_0001153",
			"UBERON_0001155",
			"UBERON_0001211",
			"UBERON_0001242",
			"UBERON_0001255",
			"UBERON_0001264",
			"UBERON_0001301",
			"UBERON_0001322",
			"UBERON_0001347",
			"UBERON_0001348",
			"UBERON_0001377",
			"UBERON_0001645",
			"UBERON_0001723",
			"UBERON_0001736",
			"UBERON_0001831",
			"UBERON_0001981",
			"UBERON_0002048",
			"UBERON_0002103",
			"UBERON_0002106",
			"UBERON_0002107",
			"UBERON_0002108",
			"UBERON_0002110",
			"UBERON_0002113",
			"UBERON_0002114",
			"UBERON_0002115",
			"UBERON_0002116",
			"UBERON_0002240",
			"UBERON_0002367",
			"UBERON_0002369",
			"UBERON_0002370",
			"UBERON_0002371",
			"UBERON_0003126",
			"UBERON_0007844",
			"UBERON_0014892"
		],
		"cow.svg": [
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0001013",
			"UBERON_0001155",
			"UBERON_0001898",
			"UBERON_0002016",
			"UBERON_0002048",
			"UBERON_0002107",
			"UBERON_0002113",
			"UBERON_0002114",
			"UBERON_0014892"
		],
		"human_male.svg": [
			"CL_0000084",
			"CL_0000233",
			"CL_0000236",
			"CL_0000576",
			"CL_0000623",
			"CL_0000738",
			"UBERON_0000004",
			"UBERON_0000007",
			"UBERON_0000014",
			"UBERON_0000029",
			"UBERON_0000167",
			"UBERON_0000178",
			"UBERON_0000310",
			"UBERON_0000341",
			"UBERON_0000451",
			"UBERON_0000473",
			"UBERON_0000945",
			"UBERON_0000947",
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0000956",
			"UBERON_0000966",
			"UBERON_0000970",
			"UBERON_0000977",
			"UBERON_0000989",
			"UBERON_0000998",
			"UBERON_0001000",
			"UBERON_0001013",
			"UBERON_0001021",
			"UBERON_0001043",
			"UBERON_0001044",
			"UBERON_0001052",
			"UBERON_0001103",
			"UBERON_0001134",
			"UBERON_0001135",
			"UBERON_0001153",
			"UBERON_0001154",
			"UBERON_0001155",
			"UBERON_0001225",
			"UBERON_0001255",
			"UBERON_0001264",
			"UBERON_0001301",
			"UBERON_0001621",
			"UBERON_0001637",
			"UBERON_0001706",
			"UBERON_0001723",
			"UBERON_0001728",
			"UBERON_0001736",
			"UBERON_0001831",
			"UBERON_0001870",
			"UBERON_0001871",
			"UBERON_0001876",
			"UBERON_0001954",
			"UBERON_0001981",
			"UBERON_0002037",
			"UBERON_0002046",
			"UBERON_0002048",
			"UBERON_0002079",
			"UBERON_0002084",
			"UBERON_0002106",
			"UBERON_0002107",
			"UBERON_0002108",
			"UBERON_0002110",
			"UBERON_0002113",
			"UBERON_0002114",
			"UBERON_0002116",
			"UBERON_0002134",
			"UBERON_0002135",
			"UBERON_0002146",
			"UBERON_0002185",
			"UBERON_0002240",
			"UBERON_0002245",
			"UBERON_0002367",
			"UBERON_0002369",
			"UBERON_0002371",
			"UBERON_0002372",
			"UBERON_0002421",
			"UBERON_00024818",
			"UBERON_0003126",
			"UBERON_0006618",
			"UBERON_0007650",
			"UBERON_0007844"
		],
		"human_brain.svg": [
			"UBERON_0000451",
			"UBERON_0000956",
			"UBERON_0001870",
			"UBERON_0001871",
			"UBERON_0001872",
			"UBERON_0001873",
			"UBERON_0001874",
			"UBERON_0001875",
			"UBERON_0001876",
			"UBERON_0001882",
			"UBERON_0001894",
			"UBERON_0001896",
			"UBERON_0001897",
			"UBERON_0001898",
			"UBERON_0001905",
			"UBERON_0001954",
			"UBERON_0002021",
			"UBERON_0002037",
			"UBERON_0002038",
			"UBERON_0002148",
			"UBERON_0002245",
			"UBERON_0002285",
			"UBERON_0002360",
			"UBERON_0002363",
			"UBERON_0002421",
			"UBERON_0002702",
			"UBERON_0002771",
			"UBERON_0003027"
		],
		"mouse_brain.svg": [
			"EFO_0000530",
			"UBERON_0000004",
			"UBERON_0000007",
			"UBERON_0000369",
			"UBERON_0000956",
			"UBERON_0001891",
			"UBERON_0001894",
			"UBERON_0001896",
			"UBERON_0001897",
			"UBERON_0001898",
			"UBERON_0002037",
			"UBERON_0002259",
			"UBERON_0002298"
		],
		"triticum_aestivum_flower_parts.svg": [
			"PO_0009001",
			"PO_0009009",
			"PO_0009030",
			"PO_0009066",
			"PO_0009084",
			"PO_0009085",
			"PO_0009086",
			"PO_0009088",
			"PO_0009089",
			"PO_0020031",
			"PO_0020033"
		],
		"rat.svg": [
			"CL_0000336",
			"UBERON_0000473",
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0000995",
			"UBERON_0001155",
			"UBERON_0001388",
			"UBERON_0002048",
			"UBERON_0002106",
			"UBERON_0002107",
			"UBERON_0002113",
			"UBERON_0002370"
		],
		"tetraodon_nigroviridis.svg": [
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0002113",
			"UBERON_0014892"
		],
		"xenopus_tropicalis.svg": [
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0002107",
			"UBERON_0002113",
			"UBERON_0014892"
		],
		"oryza_sativa_whole_plant.svg": [
			"PO_0005052",
			"PO_0009005",
			"PO_0009006",
			"PO_0009049",
			"PO_0025034"
		],
		"brachypodium_distachyon_whole_plant.svg": [
			"PO_0009010",
			"PO_0009049",
			"PO_0025034"
		],
		"oryza_sativa_flower_parts.svg": [
			"PO_0009009",
			"PO_0009010",
			"PO_0009030",
			"PO_0009066",
			"PO_0009089"
		],
		"sorghum_bicolor_whole_plant.svg": [
			"PO_0000230",
			"PO_0006079",
			"PO_0009005",
			"PO_0009006",
			"PO_0009047",
			"PO_0009049",
			"PO_0025034"
		],
		"hordeum_vulgare_flower_parts.svg": [
			"PO_0009001",
			"PO_0009009",
			"PO_0009030",
			"PO_0009066",
			"PO_0009072",
			"PO_0009073"
		],
		"anolis_carolinensis.svg": [
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0002113",
			"UBERON_0014892"
		],
		"zea_mays_flower_parts.svg": [
			"PO_0009001",
			"PO_0009009",
			"PO_0009066",
			"PO_0009084",
			"PO_0009089",
			"PO_0020031",
			"PO_0020033",
			"PO_0020136",
			"PO_0025597"
		],
		"solanum_lycopersicum_whole_plant.svg": [
			"PO_0000056",
			"PO_0009001",
			"PO_0009005",
			"PO_0009046",
			"PO_0025034"
		],
		"monodelphis_domestica.svg": [
			"UBERON_0000473",
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0002037",
			"UBERON_0002107",
			"UBERON_0002113"
		],
		"sorghum_bicolor_flower_parts.svg": [
			"PO_0009001",
			"PO_0009009",
			"PO_0009030",
			"PO_0009049",
			"PO_0009051",
			"PO_0009066",
			"PO_0009089"
		],
		"zea_mays_whole_plant.svg": [
			"PO_0009005",
			"PO_0009074",
			"PO_0020126",
			"PO_0020127",
			"PO_0020136",
			"PO_0020142",
			"PO_0025034"
		],
		"chicken.svg": [
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0001155",
			"UBERON_0002048",
			"UBERON_0002106",
			"UBERON_0002107",
			"UBERON_0002113",
			"UBERON_0014892"
		],
		"human_female.svg": [
			"CL_0000084",
			"CL_0000233",
			"CL_0000236",
			"CL_0000576",
			"CL_0000623",
			"CL_0000738",
			"UBERON_0000002",
			"UBERON_0000004",
			"UBERON_0000007",
			"UBERON_0000029",
			"UBERON_0000167",
			"UBERON_0000178",
			"UBERON_0000310",
			"UBERON_0000341",
			"UBERON_0000451",
			"UBERON_0000945",
			"UBERON_0000947",
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0000956",
			"UBERON_0000966",
			"UBERON_0000970",
			"UBERON_0000977",
			"UBERON_0000992",
			"UBERON_0000995",
			"UBERON_0000996",
			"UBERON_0001013",
			"UBERON_0001021",
			"UBERON_0001043",
			"UBERON_0001044",
			"UBERON_0001052",
			"UBERON_0001103",
			"UBERON_0001134",
			"UBERON_0001135",
			"UBERON_0001153",
			"UBERON_0001154",
			"UBERON_0001155",
			"UBERON_0001225",
			"UBERON_0001255",
			"UBERON_0001264",
			"UBERON_0001295",
			"UBERON_0001621",
			"UBERON_0001621",
			"UBERON_0001637",
			"UBERON_0001706",
			"UBERON_0001723",
			"UBERON_0001728",
			"UBERON_0001736",
			"UBERON_0001870",
			"UBERON_0001871",
			"UBERON_0001876",
			"UBERON_0001981",
			"UBERON_0001987",
			"UBERON_0002037",
			"UBERON_0002046",
			"UBERON_0002048",
			"UBERON_0002079",
			"UBERON_0002084",
			"UBERON_0002106",
			"UBERON_0002107",
			"UBERON_0002108",
			"UBERON_0002110",
			"UBERON_0002113",
			"UBERON_0002114",
			"UBERON_0002116",
			"UBERON_0002134",
			"UBERON_0002135",
			"UBERON_0002146",
			"UBERON_0002185",
			"UBERON_0002245",
			"UBERON_0002369",
			"UBERON_0002371",
			"UBERON_0002372",
			"UBERON_0002421",
			"UBERON_0002481",
			"UBERON_0003889",
			"UBERON_0006618",
			"UBERON_0007650",
			"UBERON_0007844",
			"UBERON_0012249"
		],
		"triticum_aestivum_whole_plant.svg": [
			"PO_0009005",
			"PO_0009047",
			"PO_0009049",
			"PO_0025034"
		],
		"macaca_mulatta.svg": [
			"UBERON_0000451",
			"UBERON_0000473",
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0002037",
			"UBERON_0002107",
			"UBERON_0002113"
		],
		"papio_anubis.svg": [
			"UBERON_0000007",
			"UBERON_0000029",
			"UBERON_0000945",
			"UBERON_0000948",
			"UBERON_0000955",
			"UBERON_0001155",
			"UBERON_0001870",
			"UBERON_0001871",
			"UBERON_0002037",
			"UBERON_0002048",
			"UBERON_0002106",
			"UBERON_0002107",
			"UBERON_0002113",
			"UBERON_0002371",
			"UBERON_0014892"
		],
		"hordeum_vulgare_whole_plant.svg": [
			"PO_0009005",
			"PO_0009006",
			"PO_0009049",
			"PO_0020142",
			"PO_0025034"
		],
		"solanum_tuberosum_whole_plant.svg": [],
		"arabidopsis_thaliana_whole_plant.svg": [
			"PO_0009001",
			"PO_0009005",
			"PO_0009046",
			"PO_0025034"
		],
		"solanum_lycopersicum_flower_parts.svg": [
			"PO_0009010",
			"PO_0009030",
			"PO_0009066",
			"PO_0009072",
			"PO_0009073",
			"PO_0009074",
			"PO_0009084"
		]
	};

/***/ },
/* 626 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./brain_selected.png": 627,
		"./brain_unselected.png": 628,
		"./female_selected.png": 629,
		"./female_unselected.png": 630,
		"./flower_parts_selected.png": 631,
		"./flower_parts_unselected.png": 632,
		"./male_selected.png": 633,
		"./male_unselected.png": 634,
		"./whole_plant_selected.png": 635,
		"./whole_plant_unselected.png": 636
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 626;


/***/ },
/* 627 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "cbe297d1ea7bf5aac3cfcd540c8be570.png";

/***/ },
/* 628 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "bc6cb140072af5b41e6dc150228f8735.png";

/***/ },
/* 629 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "3661376bad0ed63dd397d20227943739.png";

/***/ },
/* 630 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "f1a4ab676c0362ce2f16c8f25bd4f863.png";

/***/ },
/* 631 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0a8a46f3670c36c03bc15a90db754a19.png";

/***/ },
/* 632 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ad3370345bfd3369763a3f106f57dcb5.png";

/***/ },
/* 633 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "bc6d754760910043bb887ade6e598cd3.png";

/***/ },
/* 634 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8c0597cbe1b70b385479fc347d5b83fa.png";

/***/ },
/* 635 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "130a3f15fc96a7fa5e9ac4db73d9aa37.png";

/***/ },
/* 636 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "568a8e809ccaac58b013552d275965f8.png";

/***/ },
/* 637 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./anolis_carolinensis.svg": 638,
		"./arabidopsis_thaliana_whole_plant.svg": 639,
		"./brachypodium_distachyon_flower_parts.svg": 640,
		"./brachypodium_distachyon_whole_plant.svg": 641,
		"./chicken.svg": 642,
		"./cow.svg": 643,
		"./hordeum_vulgare_flower_parts.svg": 644,
		"./hordeum_vulgare_whole_plant.svg": 645,
		"./human_brain.svg": 646,
		"./human_female.svg": 647,
		"./human_male.svg": 648,
		"./macaca_mulatta.svg": 649,
		"./monodelphis_domestica.svg": 650,
		"./mouse_brain.svg": 651,
		"./mouse_female.svg": 652,
		"./mouse_male.svg": 653,
		"./oryza_sativa_flower_parts.svg": 654,
		"./oryza_sativa_whole_plant.svg": 655,
		"./papio_anubis.svg": 656,
		"./rat.svg": 657,
		"./solanum_lycopersicum_flower_parts.svg": 658,
		"./solanum_lycopersicum_whole_plant.svg": 659,
		"./solanum_tuberosum_whole_plant.svg": 660,
		"./sorghum_bicolor_flower_parts.svg": 661,
		"./sorghum_bicolor_whole_plant.svg": 662,
		"./tetraodon_nigroviridis.svg": 663,
		"./triticum_aestivum_flower_parts.svg": 664,
		"./triticum_aestivum_whole_plant.svg": 665,
		"./xenopus_tropicalis.svg": 666,
		"./zea_mays_flower_parts.svg": 667,
		"./zea_mays_whole_plant.svg": 668
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 637;


/***/ },
/* 638 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "15e3c69b67d92ca008087978d6b8448e.svg";

/***/ },
/* 639 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "98c06a5c7a59b3bab435902524ffe7d8.svg";

/***/ },
/* 640 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "cb470d533c62706f829d5f4f38aa425e.svg";

/***/ },
/* 641 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8483707aa435eba64fda951ff49ccb11.svg";

/***/ },
/* 642 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "2a49f7c1bbfd4ce9943dd967b6565d97.svg";

/***/ },
/* 643 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "6a792bb3d4f6b7ab4c4e13b2511b17f2.svg";

/***/ },
/* 644 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "173fddfa0293be721333dd0488441bad.svg";

/***/ },
/* 645 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a5a63a356c3d5b0ebd4c72044eafa587.svg";

/***/ },
/* 646 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "b4d4749ed2f9a3523a77749d41159a59.svg";

/***/ },
/* 647 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ab77c41fd83e3ac7b59824eedcc7c5a7.svg";

/***/ },
/* 648 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "f75018cb835783dfc8cba05679925db6.svg";

/***/ },
/* 649 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "66214fa72aa58ed3471cf5db8dcfb73c.svg";

/***/ },
/* 650 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "6e931c35578a6f5cd2631a8035edc6c4.svg";

/***/ },
/* 651 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ca7eed0e443dfbb1778393a05ff98533.svg";

/***/ },
/* 652 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "b798241c027f3433267b5fd2c7e162f4.svg";

/***/ },
/* 653 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "7227aa2d41f33d2dda795451b732f606.svg";

/***/ },
/* 654 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "731e1923bcc41297de5b17335c6a088b.svg";

/***/ },
/* 655 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "6fd77ccb71c445a69ecda1d7f2acf3be.svg";

/***/ },
/* 656 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "d0808ee85e6f2aa9923a2c02c855d3aa.svg";

/***/ },
/* 657 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e8a6d2add179be4126a5236f96b2af5b.svg";

/***/ },
/* 658 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "65e77feca458643bf95b5c5e13148726.svg";

/***/ },
/* 659 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "2406acaef2f238d3504430eb7bcb9d95.svg";

/***/ },
/* 660 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8ab8f4f9840301eff71e1b84c08f1fda.svg";

/***/ },
/* 661 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "35cac077905e5c012fb5502a2acf0407.svg";

/***/ },
/* 662 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "6d7f6fa1372c8c9c27c2b2d6d0ecdb87.svg";

/***/ },
/* 663 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "99203386ec5edc719c3a8f3c790aedec.svg";

/***/ },
/* 664 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ccb6040d000ff031a35680692a0c6521.svg";

/***/ },
/* 665 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "30d9d46ebd8ed96acef4182f0e5dea5d.svg";

/***/ },
/* 666 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "01aa50632e4ce254ff1abf10f815b2fa.svg";

/***/ },
/* 667 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "514455ffe1d2fc47050b3448b6c47304.svg";

/***/ },
/* 668 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8d6532733a5ffa657ae1df67a81fda1a.svg";

/***/ },
/* 669 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(670);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(672)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./../../less-loader/index.js!./SelectionIcon.less", function() {
				var newContent = require("!!./../../css-loader/index.js!./../../less-loader/index.js!./SelectionIcon.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 670 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(671)();
	// imports


	// module
	exports.push([module.id, ".selection-icon {\n  display: block;\n  position: relative;\n  padding: 0;\n  line-height: normal;\n  margin-right: .1em;\n  cursor: pointer;\n  vertical-align: middle;\n  text-align: center;\n  overflow: visible;\n  border: 1px solid #ccc;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  width: 24px;\n  height: 24px;\n  padding: 2px;\n}\n.selection-icon:hover {\n  border: 1px solid #fbcb09;\n  background: #fdf5ce 50% 50% repeat-x;\n  font-weight: bold;\n  color: #c77405;\n}\n.jquery-ui-like-button {\n  display: block;\n  position: relative;\n  padding: 0;\n  line-height: normal;\n  margin-right: .1em;\n  cursor: pointer;\n  vertical-align: middle;\n  text-align: center;\n  overflow: visible;\n}\n.rounded-corners {\n  border: 1px solid #ccc;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n.right-dimensions {\n  width: 24px;\n  height: 24px;\n  padding: 2px;\n}\n", ""]);

	// exports


/***/ },
/* 671 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 672 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 673 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(674);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(672)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./../../less-loader/index.js!./ContainerLayout.less", function() {
				var newContent = require("!!./../../css-loader/index.js!./../../less-loader/index.js!./ContainerLayout.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 674 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(671)();
	// imports


	// module
	exports.push([module.id, "#gxaAnatomogramWrapper {\n  display: block;\n  zoom: 1;\n  position: relative;\n  overflow: hidden;\n  marginLeft: 270px;\n}\n#gxaAnatomogramWrapper:after {\n  content: \" \";\n  display: block;\n  font-size: 0;\n  height: 0;\n  clear: both;\n  visibility: hidden;\n}\n#gxaAnatomogramAside {\n  float: left;\n  max-width: 270px;\n}\n.clearfix {\n  display: block;\n  zoom: 1;\n}\n.clearfix:after {\n  content: \" \";\n  display: block;\n  font-size: 0;\n  height: 0;\n  clear: both;\n  visibility: hidden;\n}\n", ""]);

	// exports


/***/ },
/* 675 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	//*------------------------------------------------------------------*

	var Config = __webpack_require__(676);
	var Orderings = __webpack_require__(677);
	var ColorAxis = __webpack_require__(678);
	var Data = __webpack_require__(679);
	//*------------------------------------------------------------------*

	var _allRows = function _allRows(data) {
	  return [].concat.apply(data.profiles.rows, (data.jsonCoexpressions || []).map(function (coex) {
	    return (coex.jsonProfiles && coex.jsonProfiles.rows ? coex.jsonProfiles.rows : []).map(function (row, ix) {
	      return Object.assign(row, {
	        coexpressionOfGene: {
	          id: coex.geneId,
	          name: coex.geneName,
	          index: ix
	        }
	      });
	    });
	  }));
	};
	var get = function get(setupConfig, payload) {
	  var config = Config(setupConfig, payload);
	  var rows = _allRows(payload);
	  var columnHeaders = payload.columnHeaders;

	  var data = Data(config, rows, columnHeaders, payload.columnGroupings);

	  return {
	    heatmapConfig: config,
	    colorAxis: ColorAxis(config, data.dataSeries),
	    orderings: Orderings(config, rows, columnHeaders),
	    heatmapData: data
	  };
	};

	module.exports = get;

/***/ },
/* 676 */
/***/ function(module, exports) {

	"use strict";

	// const genomeBrowserTemplate = require('./genomeBrowserTemplate.js');

	var capitalizeFirstLetter = function capitalizeFirstLetter(str) {
	    return !str ? str : str.charAt(0).toUpperCase() + str.substr(1);
	};

	var _introductoryMessage = function _introductoryMessage(isMultiExperiment, profiles) {
	    var shownRows = profiles.rows.length;
	    var totalRows = profiles.searchResultTotal;

	    var what = (isMultiExperiment ? "experiment" : "gene") + (totalRows > 1 ? "" : "");

	    return "Showing " + shownRows + " " + (totalRows === shownRows ? what + ":" : "of " + totalRows + " " + what + " found:");
	};

	var geneURL = function geneURL(config) {
	    return config.atlasBaseURL + "/query?geneQuery=" + (config.geneQuery || "") + "&conditionQuery=" + (config.conditionQuery || "") + "&organism=" + (config.species || "");
	};

	var _coexpressions = function _coexpressions(jsonCoexpressions) {
	    return (
	        /*
	         The backend code and the feature in the old heatmap were written to support coexpressions of multiple genes.
	         It doesn't seem necessary, so this assumes zero or one coexpressions.
	         */
	        jsonCoexpressions[0] ? {
	            coexpressedGene: jsonCoexpressions[0].geneName,
	            numCoexpressionsAvailable: jsonCoexpressions[0].jsonProfiles ? jsonCoexpressions[0].jsonProfiles.rows.length : 0
	        } : ""
	    );
	};

	var coexpressions = function coexpressions(setupConfig, data) {
	    return setupConfig.isExperimentPage && data.jsonCoexpressions && Array.isArray(data.jsonCoexpressions) ? _coexpressions(data.jsonCoexpressions) : "";
	};

	var getConfig = function getConfig(setupConfig, data) {
	    var config = {
	        geneQuery: data.config.geneQuery,
	        atlasBaseURL: setupConfig.atlasBaseURL,
	        proxyPrefix: setupConfig.proxyPrefix,
	        pathToFolderWithBundledResources: setupConfig.pathToFolderWithBundledResources,
	        isExperimentPage: setupConfig.isExperimentPage,
	        isMultiExperiment: setupConfig.isMultiExperiment,
	        isReferenceExperiment: setupConfig.isReferenceExperiment,
	        isDifferential: setupConfig.isDifferential,
	        introductoryMessage: _introductoryMessage(setupConfig.isMultiExperiment, data.profiles),
	        description: setupConfig.isExperimentPage && data.experiment && data.experiment.description ? data.experiment.description : "",
	        xAxisLegendName: capitalizeFirstLetter(data.config.columnType) || "Experimental condition",
	        yAxisLegendName: setupConfig.isExperimentPage ? "Gene name" : "Experiment",
	        coexpressions: coexpressions(setupConfig, data)
	    };

	    var description = "";
	    if (data.jsonExperiment) {
	        if (data.jsonExperiment.description && setupConfig.isExperimentPage) {
	            description = data.jsonExperiment.description;
	        } else if (setupConfig.isReferenceExperiment && data.jsonExperiment.URL) {
	            description = "Reference experiment: " + setupConfig.atlasBaseURL + data.jsonExperiment.URL;
	        }
	    } else if (config.description) {
	        description = config.description;
	    } else if (setupConfig.isMultiExperiment) {
	        description = "Query results for: " + decodeURIComponent(config.geneQuery);
	        if (config.conditionQuery && decodeURIComponent(config.conditionQuery).length > 2) {
	            description = description + ", in conditions: " + decodeURIComponent(config.conditionQuery);
	        }
	        description = description + ", in species: " + config.species;
	    }

	    var shortDescription = "";
	    if (config.experimentAccession) {
	        if (setupConfig.isReferenceExperiment) {
	            shortDescription = "ReferenceExp";
	        }
	        shortDescription = "" + shortDescription + config.experimentAccession;
	    } else {
	        shortDescription = "expression-atlas-" + data.config.species.replace(/ +/, "-");
	    }

	    Object.assign(config, data.config, { moreInformationLink: setupConfig.isMultiExperiment ? geneURL(config) : data.jsonExperiment ? data.jsonExperiment.URL : setupConfig.atlasBaseURL
	    }, { genomeBrowserTemplate: setupConfig.isExperimentPage ? "" : "" }, { description: description }, { shortDescription: shortDescription });

	    return Object.freeze(config);
	};

	module.exports = getConfig;

/***/ },
/* 677 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	//*------------------------------------------------------------------*

	var _ = __webpack_require__(19);

	//*------------------------------------------------------------------*

	//apply rank first,use comparator to resolve ties
	var createOrdering = function createOrdering(rank, comparator, arr) {
	  return arr.map(function (e, ix) {
	    return [e, ix];
	  }).sort(function (e_ixLeft, e_ixRight) {
	    return (//lower ranks go to the beginning of series
	      rank[e_ixLeft[1]] - rank[e_ixRight[1]] || comparator(e_ixLeft[0], e_ixRight[0])
	    );
	  }).map(function (e_ix) {
	    return e_ix[1];
	  });
	};

	var createAlphabeticalOrdering = function createAlphabeticalOrdering(property, arr) {
	  return createOrdering(arr.map(_.constant(0)), comparatorByProperty(property), arr);
	};

	var comparatorByProperty = _.curry(function (property, e1, e2) {
	  return e1[property].localeCompare(e2[property]);
	});

	var rankColumnsByWhereTheyAppearFirst = function rankColumnsByWhereTheyAppearFirst(expressions) {
	  return _.chain(expressions).map(function (row) {
	    return row.map(function (e) {
	      return +e.hasOwnProperty("value");
	    });
	  }).thru(_.spread(_.zip)).map(function (column) {
	    return column.map(function (e, ix) {
	      return e * (ix + 1);
	    }).filter(_.identity);
	  }).map(_.min).value();
	};

	var highestColumnRankPossible = function highestColumnRankPossible(expressions) {
	  return expressions.length ? expressions[0].length : Number.MAX_VALUE;
	};

	var thresholdColumnsByExpressionAboveCutoff = function thresholdColumnsByExpressionAboveCutoff(expressions) {
	  return rankColumnsByExpression(expressions, 0).map(function (e) {
	    //check if the function assigned the rank value corresponding to everything filtered off
	    return e === highestColumnRankPossible(expressions) ? 1 : 0;
	  });
	};

	var rankColumnsByExpression = function rankColumnsByExpression(expressions, minimalExpression) {
	  var includeInRanking = typeof minimalExpression === 'number' ? function (e) {
	    return e.hasOwnProperty("value") && !isNaN(e.value) && Math.abs(e.value) > minimalExpression;
	  } : function (e) {
	    return e.hasOwnProperty("value") && !isNaN(e.value);
	  };
	  return _.chain(expressions).map(function (row) {
	    var valuesInRow = row.filter(includeInRanking).map(function (e) {
	      return e.value;
	    }).sort(function (l, r) {
	      return r - l;
	    }).filter(function (e, ix, self) {
	      return self.indexOf(e) === ix;
	    });
	    return row.map(function (e) {
	      return includeInRanking(e) ? valuesInRow.indexOf(e.value) : "missing";
	    });
	  }).thru(_.spread(_.zip)).map(function (ranks) {
	    return ranks.filter(_.negate(isNaN));
	  }).map(function (ranks) {
	    return ranks.length ? _.sum(ranks) / ranks.length : highestColumnRankPossible(expressions);
	  }).value();
	};

	var rankColumnsByThreshold = function rankColumnsByThreshold(threshold, expressions) {
	  return expressions.map(function (row) {
	    return row.map(function (point) {
	      return +(point.hasOwnProperty("value") && point.value !== 0);
	    });
	  }).reduce(function (r1, r2) {
	    return r1.map(function (el, ix) {
	      return el + r2[ix];
	    }, _.fill(Array(expressions.length ? expressions[0].length : 0), 0));
	  }).map(function (countOfExperimentsWhereTissueExpressedAboveCutoff) {
	    return countOfExperimentsWhereTissueExpressedAboveCutoff > expressions.length * threshold ? 0 : 1;
	  });
	};

	var noOrdering = function noOrdering(arr) {
	  return arr.map(function (el, ix) {
	    return ix;
	  });
	};

	var combineRanks = function combineRanks(ranksAndTheirWeighings) {
	  return _.chain(ranksAndTheirWeighings).map(_.spread(function (ranks, weighing) {
	    return ranks.map(_.curry(_.multiply, 2)(weighing));
	  })).thru(_.spread(_.zip)).map(_.sum).value();
	};

	var createOrderings = function createOrderings(expressions, columnHeaders, rows, config) {
	  var transposed = _.zip.apply(_, expressions);
	  return config.isMultiExperiment || config.isReferenceExperiment ? {
	    "Default": {
	      columns: createAlphabeticalOrdering("factorValue", columnHeaders),
	      rows: noOrdering(rows)
	    },
	    "Alphabetical order": {
	      columns: createAlphabeticalOrdering("factorValue", columnHeaders),
	      rows: createAlphabeticalOrdering("name", rows)
	    },
	    "Gene expression rank": {
	      columns: createOrdering(combineRanks([[rankColumnsByWhereTheyAppearFirst(expressions), 1], [rankColumnsByExpression(expressions), 1e3], [rankColumnsByThreshold(0.05 + 0.4 / Math.pow(1 + transposed.length / 8, 0.4), expressions), 1e6], [thresholdColumnsByExpressionAboveCutoff(expressions), 1e7]]), comparatorByProperty("factorValue"), columnHeaders),
	      rows: createOrdering(combineRanks([[rankColumnsByExpression(transposed), 1e3], [rankColumnsByThreshold(0.05 + 0.4 / (1 + expressions.length / 5), transposed), 1e6]]), comparatorByProperty("name"), rows)
	    }
	  } : {
	    "Default": {
	      columns: noOrdering(columnHeaders),
	      rows: noOrdering(rows)
	    }
	  };
	};

	var extractExpressionValues = function extractExpressionValues(rows, isDifferential) {
	  var _valueFieldExtractor = function _valueFieldExtractor(valueField) {
	    return function (expression) {
	      return expression.hasOwnProperty(valueField) ? { value: +expression[valueField] } : {};
	    };
	  };
	  return rows.map(function (row) {
	    return row.expressions.map(_valueFieldExtractor(isDifferential ? "foldChange" : "value"));
	  });
	};

	var createOrderingsForData = function createOrderingsForData(config, rows, columnHeaders) {
	  return createOrderings(extractExpressionValues(rows, config.isDifferential), columnHeaders, rows, config);
	};

	//*------------------------------------------------------------------*

	module.exports = createOrderingsForData;

/***/ },
/* 678 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(139);
	// var validateDataSeries = require('../PropTypes.js').validateDataSeries;
	var Colour = __webpack_require__(1);

	var highlightColour = function highlightColour(c) {
	  return c.light() ? c.clone().lighten(0.5) : c.clone().saturate(0.3).darken(0.5);
	};

	var dataClassesFromSeries = function dataClassesFromSeries(dataSeries) {
	  // PropTypes should only be used with proper React components
	  // https://facebook.github.io/react/warnings/dont-call-proptypes.html
	  // validateDataSeries(dataSeries);
	  var xs = dataSeries.map(function (series) {
	    return series.data.length === 0 && series.info.name === "Below cutoff" ? {
	      data: [{ value: 0.0 }],
	      colour: series.info.colour
	    } : {
	      data: series.data,
	      colour: series.info.colour
	    };
	  }).filter(function (series) {
	    return series.data.length > 0;
	  }).map(function (series, ix, self) {
	    var theseSeriesValuesSorted = series.data.map(function (point) {
	      return point.value;
	    });
	    theseSeriesValuesSorted.sort(function (l, r) {
	      return l - r;
	    });
	    return {
	      min: theseSeriesValuesSorted[0],
	      minColour: ix == 0 ? highlightColour(Colour(self[ix].colour)) : Colour(self[ix].colour).mix(Colour(self[ix - 1].colour)),
	      max: theseSeriesValuesSorted[theseSeriesValuesSorted.length - 1],
	      maxColour: ix == self.length - 1 ? highlightColour(Colour(self[ix].colour)) : Colour(self[ix].colour).mix(Colour(self[ix + 1].colour)),
	      median: theseSeriesValuesSorted[Math.floor(series.data.length / 2)],
	      medianColour: Colour(self[ix].colour),
	      sortedValues: theseSeriesValuesSorted
	    };
	  });
	  var needToSplit = function needToSplit(x) {
	    return x.sortedValues.length > 3 && x.sortedValues[0] != x.sortedValues[x.sortedValues.length - 1] && x.minColour.rgbString() !== x.maxColour.rgbString();
	  };

	  var splitInHalf = function splitInHalf(x) {
	    return [{
	      min: x.min,
	      minColour: x.minColour,
	      max: x.median,
	      maxColour: x.medianColour,
	      median: x.sortedValues[Math.floor(x.sortedValues.length / 4)],
	      medianColour: x.minColour.clone().mix(x.medianColour),
	      sortedValues: x.sortedValues.slice(0, Math.floor(x.sortedValues.length / 2))
	    }, {
	      min: x.median,
	      minColour: x.medianColour,
	      max: x.max,
	      maxColour: x.maxColour,
	      median: x.sortedValues[Math.floor(3 * x.sortedValues.length / 4)],
	      medianColour: x.medianColour.clone().mix(x.maxColour),
	      sortedValues: x.sortedValues.slice(Math.floor(x.sortedValues.length / 2))
	    }];
	  };
	  var l = Number.MIN_VALUE;
	  var L = xs.length;
	  while (l < L) {
	    xs = [].concat.apply([], xs.map(function (x) {
	      if (needToSplit(x)) {
	        return splitInHalf(x);
	      } else {
	        return [x];
	      }
	    }));
	    l = L;
	    L = xs.length;
	  }

	  return xs.map(function (x) {
	    return {
	      from: x.min,
	      to: x.max,
	      color: x.medianColour.hexString()
	    };
	  });
	};

	var getColorAxisFromDataSeries = function getColorAxisFromDataSeries(config, dataSeries) {
	  return config.isExperimentPage ? {
	    dataClasses: dataClassesFromSeries(dataSeries)
	  } : null;
	};

	module.exports = getColorAxisFromDataSeries;

/***/ },
/* 679 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	//*------------------------------------------------------------------*

	var _ = __webpack_require__(19);
	var Url = __webpack_require__(618);
	var Path = __webpack_require__(623);

	//*------------------------------------------------------------------*

	var _columnGroupings = function _columnGroupings(columnGroupings, id) {
	  return columnGroupings.map(function (grouping) {
	    var values = grouping.groups.filter(function (group) {
	      return group.values.indexOf(id) > -1;
	    }).map(function (group) {
	      return {
	        label: group.name,
	        id: group.id
	      };
	    });
	    return {
	      name: grouping.name,
	      memberName: grouping.memberName,
	      values: values.length ? values : [{
	        label: "Unmapped",
	        id: ""
	      }]
	    };
	  });
	};

	var getXAxisCategories = function getXAxisCategories(columnHeaders, columnGroupings, config) {
	  return columnHeaders.map(config.isExperimentPage ? config.isDifferential ? function (columnHeader) {
	    return { "label": columnHeader.displayName,
	      "id": columnHeader.id,
	      "info": {
	        trackId: columnHeader.id,
	        tooltip: Object.assign({ resources: (columnHeader.resources || []).map(function (resource) {
	            return {
	              type: resource.type,
	              uri: config.atlasBaseURL + resource.uri,
	              icon: Url.resolve(config.pathToFolderWithBundledResources, Path.basename(__webpack_require__(680)("./" + resource.type + "-icon.png")))
	            };
	          })
	        }, columnHeader.contrastSummary),
	        groupings: []
	      } };
	  } : function (columnHeader) {
	    return { "label": columnHeader.factorValue,
	      "id": columnHeader.factorValueOntologyTermId || "",
	      "info": {
	        trackId: columnHeader.assayGroupId,
	        tooltip: columnHeader.assayGroupSummary,
	        groupings: _columnGroupings(columnGroupings, columnHeader.factorValueOntologyTermId || "")
	      } };
	  } : function (columnHeader) {
	    return { "label": columnHeader.factorValue,
	      "id": columnHeader.factorValueOntologyTermId || "",
	      "info": {
	        trackId: "",
	        tooltip: {},
	        groupings: _columnGroupings(columnGroupings, columnHeader.factorValueOntologyTermId || "")
	      } };
	  });
	};

	var getYAxisCategories = function getYAxisCategories(rows, config) {
	  return rows.map(config.isExperimentPage ? function (profile) {
	    return { "label": profile.name,
	      "id": profile.uri || profile.id,
	      "info": {
	        trackId: profile.id,
	        designElement: profile.designElement || ""
	      } };
	  } : function (profile) {
	    return { "label": profile.name,
	      "id": profile.uri || profile.id + "?geneQuery=" + config.geneQuery + (profile.serializedFilterFactors ? "&serializedFilterFactors=" + encodeURIComponent(profile.serializedFilterFactors) : ""),
	      "info": {
	        trackId: "",
	        designElement: ""
	      } };
	  });
	};

	var __dataPointFromExpression = function __dataPointFromExpression(infoCommonForTheRow, columnNumber, expression, rowNumber) {
	  //TODO make this function more complicated and determine the info to pass about each point here.
	  return expression.hasOwnProperty("value") ? { x: rowNumber, y: columnNumber, value: expression.value, info: infoCommonForTheRow } : expression.hasOwnProperty("foldChange") ? {
	    x: rowNumber,
	    y: columnNumber,
	    value: +expression.foldChange,
	    info: Object.assign({
	      pValue: expression.pValue,
	      foldChange: expression.foldChange,
	      tStat: expression.tStat || "" }, infoCommonForTheRow)
	  } : null;
	};

	var _commonPropertiesForRow = function _commonPropertiesForRow(row, config) {
	  return Object.assign({}, { unit: unitForThisRowOfData(row, config) }, { index: row.coexpressionOfGene ? row.coexpressionOfGene.index + 1 : 0 });
	};

	var _dataPointsFromRow = _.curry(function (config, row, columnNumber) {
	  return row.expressions.map(_.curry(__dataPointFromExpression, 4)(_commonPropertiesForRow(row, config), columnNumber)).filter(function (el) {
	    return el;
	  });
	}, 3);

	var unitForThisRowOfData = function unitForThisRowOfData(row, config) {
	  return config.isDifferential ? "Log2Fold change" //this is what we use for point.value, but we don't actually use this unit for display. See Formatters.jsx.
	  : config.isMultiExperiment ? row.experimentType === "RNASEQ_MRNA_BASELINE" ? row.name.indexOf("FANTOM") > -1 ? "TPM" : "FPKM" : "" : config.experimentAccession.indexOf("PROT") > -1 ? "" : config.description.toUpperCase().indexOf("FANTOM") > -1 ? "TPM" : "FPKM";
	};

	var _groupByExperimentType = function _groupByExperimentType(chain, config) {
	  return chain.map(function (row, columnNumber) {
	    return [row.experimentType, _dataPointsFromRow(config, row, columnNumber)];
	  }).groupBy(function (experimentTypeAndRow) {
	    return experimentTypeAndRow[0];
	  }).mapValues(function (rows) {
	    return rows.map(function (experimentTypeAndRow) {
	      return experimentTypeAndRow[1];
	    });
	  }).mapValues(_.flatten).toPairs();
	};

	var _experimentsIntoDataSeriesByThresholds = function _experimentsIntoDataSeriesByThresholds(thresholds) {
	  return function (experimentType, dataPoints) {
	    return dataPoints.map(function (dataPoint) {
	      return [_.sortedIndex(thresholds[experimentType] || thresholds.DEFAULT, dataPoint.value), dataPoint];
	    }.bind(this));
	  };
	};

	var getDataSeries = function getDataSeries(profilesRows, config) {
	  var _fns = [_.lt, _.eq, _.gt].map(function (f) {
	    return function (point) {
	      return f(point.value, 0);
	    };
	  });
	  var _belowCutoff = _fns[1];
	  return config.isMultiExperiment ? _dataSplitByThresholds({
	    RNASEQ_MRNA_BASELINE: [0, 10, 1000],
	    PROTEOMICS_BASELINE: [0, 0.001, 8],
	    DEFAULT: [0, 10, 1000]
	  }, ["Below cutoff", "Low", "Medium", "High"], ["#eaeaea", "#45affd", "#1E74CA", "#024990"], profilesRows, config) : config.isDifferential ? _dataProportionallyInEachSeries(profilesRows, config, _fns, [["High down", "Down"], ["Below cutoff"], ["Up", "High up"]], [["#0000ff", "#8cc6ff"], ["gainsboro"], ["#e9967a", "#b22222"]]) : _dataProportionallyInEachSeries(profilesRows, config, [_belowCutoff, _.negate(_belowCutoff)], [["Below cutoff"], ["Low", "Medium", "High"]], [["gainsboro"], ["#8cc6ff", "#0000ff", "#0000b3"]]);
	};
	var _splitDataSetByProportion = function _splitDataSetByProportion(data, names, colours) {
	  var sortedValues = data.map(function (point) {
	    return point.value;
	  }).sort(function (l, r) {
	    return l - r;
	  });
	  var howManyPointsInTotal = data.length;
	  var howManyDataSetsToSplitIn = names.length;
	  return _bucketsIntoSeries(names, colours)(_.chain(data).map(function (point) {
	    return [Math.floor(_.sortedIndex(sortedValues, point.value) / howManyPointsInTotal * howManyDataSetsToSplitIn), point];
	  })).value();
	};

	var _dataProportionallyInEachSeries = function _dataProportionallyInEachSeries(profilesRows, config, filters, names, colors) {
	  var points = _.flatten(profilesRows.map(_dataPointsFromRow(config)));
	  return _.flatten(_.range(filters.length).map(function (i) {
	    return _splitDataSetByProportion(points.filter(filters[i]), names[i], colors[i]);
	  }));
	};

	var _bucketsIntoSeries = _.curry(function (names, colours, chain) {
	  return chain.groupBy(_.spread(function (dataSeriesAssigned, point) {
	    return dataSeriesAssigned;
	  })).mapValues(function (bucket) {
	    return bucket.map(_.spread(function (dataSeriesAssigned, point) {
	      return point;
	    }));
	  }).transform(function (result, bucket, bucketNumber) {
	    result[bucketNumber].data = bucket;
	  }, _.range(names.length).map(function (i) {
	    return {
	      info: {
	        name: names[i],
	        colour: colours[i]
	      },
	      data: []
	    };
	  }));
	}, 3);

	var _dataSplitByThresholds = function _dataSplitByThresholds(thresholds, names, colours, profilesRows, config) {
	  return _bucketsIntoSeries(names, colours)(_groupByExperimentType(_.chain(profilesRows), config).map(_.spread(_experimentsIntoDataSeriesByThresholds(thresholds))).flatten()).value();
	};

	var getTheWholeDataObject = function getTheWholeDataObject(config, rows, columnHeaders, columnGroupings) {
	  return {
	    xAxisCategories: getXAxisCategories(columnHeaders, columnGroupings || [], config),
	    yAxisCategories: getYAxisCategories(rows, config),
	    dataSeries: getDataSeries(rows, config)
	  };
	};

	//*------------------------------------------------------------------*
	module.exports = getTheWholeDataObject;

/***/ },
/* 680 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./gsea_go-icon.png": 681,
		"./gsea_interpro-icon.png": 682,
		"./gsea_reactome-icon.png": 683,
		"./ma-plot-icon.png": 684
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 680;


/***/ },
/* 681 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "5faee84bd1cf86bc62432d4065523c39.png";

/***/ },
/* 682 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e5bd8b95955895136e36bc4722d71cf0.png";

/***/ },
/* 683 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4d9b25a425f08c8f240a14045f694819.png";

/***/ },
/* 684 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "6b3ed826d015fcfafd268718f1d4d39c.png";

/***/ },
/* 685 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(139);
	var FormattersFactory = __webpack_require__(686);
	var TooltipsFactory = __webpack_require__(691);
	var PropTypes = __webpack_require__(697);
	var Show = __webpack_require__(698);
	var _ = __webpack_require__(19);

	module.exports = React.createClass({
	    displayName: "Heatmap with settings",

	    propTypes: {
	        loadResult: PropTypes.LoadResult,
	        googleAnalyticsCallback: React.PropTypes.func.isRequired,
	        ontologyIdsToHighlight: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	        onOntologyIdIsUnderFocus: React.PropTypes.func.isRequired
	    },

	    getInitialState: function getInitialState() {
	        return {
	            ordering: "Default",
	            filtersSelection: this._filtersInitially(),
	            coexpressionsShown: 0,
	            zoom: false
	        };
	    },
	    _getFilterSelection: function _getFilterSelection(name) {
	        return (this.state.filtersSelection.find(function (f) {
	            return f.name == name;
	        }) || { selected: [] }).selected;
	    },
	    _onUserZoom: function _onUserZoom(zoomedIn) {
	        this.setState({ zoom: zoomedIn });
	    },
	    _heatmapDataToPresent: function _heatmapDataToPresent() {
	        var _this = this;

	        return __webpack_require__(816).manipulate({
	            keepSeries: function keepSeries(series) {
	                return _this._getFilterSelection(_this._expressionLevelInSelectedBucketFilter().name).includes(series.info.name);
	            },
	            keepRow: function keepRow(row) {
	                return !row.info.index || row.info.index <= _this.state.coexpressionsShown;
	            },
	            keepColumn: function keepColumn(columnHeader) {
	                return _this._columnHeadersThatColumnGroupingFiltersSayWeCanInclude().length == 0 || _this._columnHeadersThatColumnGroupingFiltersSayWeCanInclude().includes(columnHeader.label);
	            },
	            ordering: this.props.loadResult.orderings[this.state.ordering],
	            allowEmptyColumns: this.props.loadResult.heatmapConfig.isExperimentPage && _.isEqual(this._filtersInitially(), this._filtersCurrently())
	        }, this.props.loadResult.heatmapData);
	    },
	    _columnHeadersThatColumnGroupingFiltersSayWeCanInclude: function _columnHeadersThatColumnGroupingFiltersSayWeCanInclude() {
	        var _this2 = this;

	        return this._columnBelongsToGroupingFilterPerGrouping().map(function (groupingFilter) {
	            return groupingFilter.name;
	        }).map(function (name) {
	            return _this2._getFilterSelection(name);
	        }).reduce(function (l, r) {
	            return l.concat(r);
	        }, []);
	    },
	    _labels: function _labels() {
	        return this.props.loadResult.heatmapData.dataSeries.map(function (e) {
	            return {
	                colour: e.info.colour,
	                name: e.info.name
	            };
	        });
	    },
	    _orderings: function _orderings() {
	        var _this3 = this;

	        return {
	            available: Object.keys(this.props.loadResult.orderings),
	            selected: this.state.ordering,
	            onSelect: function onSelect(orderingChosen) {
	                _this3.setState({ ordering: orderingChosen });
	            }
	        };
	    },
	    __filters__: function __filters__() {
	        return [this._expressionLevelInSelectedBucketFilter()].concat(this._columnBelongsToGroupingFilterPerGrouping());
	    },
	    _filtersInitially: function _filtersInitially() {
	        return this.__filters__().map(function (filter) {
	            return {
	                name: filter.name,
	                selected: filter.values
	            };
	        });
	    },
	    _filtersCurrently: function _filtersCurrently() {
	        var _this4 = this;

	        return this.__filters__().map(function (_filter) {
	            return Object.assign({}, _filter, { selected: _this4._getFilterSelection(_filter.name) });
	        });
	    },
	    _expressionLevelInSelectedBucketFilter: function _expressionLevelInSelectedBucketFilter() {
	        return {
	            name: "Expression Value" + (this.props.loadResult.heatmapConfig.isExperimentPage ? " \u2013 relative" : ""),
	            values: this.props.loadResult.heatmapData.dataSeries.map(function (e) {
	                return e.info.name;
	            })
	        };
	    },
	    _columnBelongsToGroupingFilterPerGrouping: function _columnBelongsToGroupingFilterPerGrouping() {
	        var groupingTriplets = _.flattenDeep(this.props.loadResult.heatmapData.xAxisCategories.reduce(function (acc, columnHeader) {
	            var groupingTriplets = columnHeader.info.groupings.map(function (grouping) {
	                return grouping.values.map(function (groupingValue) {
	                    return {
	                        name: grouping.name,
	                        groupingLabel: groupingValue.label,
	                        columnLabel: columnHeader.label
	                    };
	                });
	            });
	            acc.push(groupingTriplets);

	            return acc;
	        }, []));

	        var groupingNames = _.uniq(groupingTriplets.map(function (groupingTriplet) {
	            return groupingTriplet.name;
	        }));

	        return groupingNames.map(function (groupingName) {
	            var columnLabels = _.uniq(groupingTriplets.filter(function (groupingTriplet) {
	                return groupingTriplet.name === groupingName;
	            }).map(function (groupingTriplet) {
	                return groupingTriplet.columnLabel;
	            }));

	            return {
	                name: groupingName,
	                values: columnLabels,
	                valueGroupings: _.uniq(groupingTriplets.map(function (groupingTriplet) {
	                    return groupingTriplet.groupingLabel;
	                })).sort().map(function (groupingLabel) {
	                    return [groupingLabel, _.sortedUniq(groupingTriplets.filter(function (groupingTriplet) {
	                        return groupingTriplet.name === groupingName && groupingTriplet.groupingLabel === groupingLabel;
	                    }).map(function (groupingTriplet) {
	                        return groupingTriplet.columnLabel;
	                    }))];
	                })
	            };
	        });
	    },
	    _onFilterChange: function _onFilterChange(newFiltersSelection) {
	        this.setState({ filtersSelection: newFiltersSelection });
	    },
	    _legend: function _legend() {
	        var _this5 = this;

	        //See properties required for HeatmapLegendBox
	        return this.props.loadResult.heatmapConfig.isExperimentPage ? null : this.props.loadResult.heatmapData.dataSeries.map(function (e, ix) {
	            return {
	                key: e.info.name,
	                name: e.info.name,
	                colour: e.info.colour,
	                on: _this5._getFilterSelection(_this5._expressionLevelInSelectedBucketFilter().name).includes(e.info.name)
	            };
	        });
	    },
	    _coexpressionOption: function _coexpressionOption() {
	        var _this6 = this;

	        return this.props.loadResult.heatmapConfig.coexpressions && {
	            geneName: this.props.loadResult.heatmapConfig.coexpressions.coexpressedGene,
	            numCoexpressionsVisible: this.state.coexpressionsShown,
	            numCoexpressionsAvailable: this.props.loadResult.heatmapConfig.coexpressions.numCoexpressionsAvailable,
	            showCoexpressionsCallback: function showCoexpressionsCallback(e) {
	                _this6.setState({ coexpressionsShown: e });
	            }
	        };
	    },
	    render: function render() {
	        var heatmapDataToPresent = this._heatmapDataToPresent();
	        return Show(heatmapDataToPresent, this._orderings(), this._filtersCurrently(), this._onFilterChange, this.state.zoom, this._onUserZoom, this.props.loadResult.colorAxis || undefined, FormattersFactory(this.props.loadResult.heatmapConfig), TooltipsFactory(this.props.loadResult.heatmapConfig, heatmapDataToPresent.xAxisCategories, heatmapDataToPresent.yAxisCategories), this._legend(), this._coexpressionOption(), this.props);
	    }
	});

/***/ },
/* 686 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(139);

	var _react2 = _interopRequireDefault(_react);

	var _server = __webpack_require__(687);

	var _server2 = _interopRequireDefault(_server);

	var _expressionAtlasNumberFormat = __webpack_require__(688);

	var _expressionAtlasNumberFormat2 = _interopRequireDefault(_expressionAtlasNumberFormat);

	var _he = __webpack_require__(14);

	var _he2 = _interopRequireDefault(_he);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var outwardLink = __webpack_require__(690);

	var scientificNotation = function scientificNotation(value) {
	  return _expressionAtlasNumberFormat2.default.scientificNotation(value, { fontWeight: 'bold' });
	};

	var Tooltip = _react2.default.createClass({
	  displayName: 'Tooltip',

	  propTypes: {
	    config: _react2.default.PropTypes.shape({
	      isDifferential: _react2.default.PropTypes.bool.isRequired,
	      xAxisLegendName: _react2.default.PropTypes.string.isRequired,
	      yAxisLegendName: _react2.default.PropTypes.string.isRequired,
	      genomeBrowserTemplate: _react2.default.PropTypes.string.isRequired
	    }).isRequired,
	    colour: _react2.default.PropTypes.string.isRequired,
	    xLabel: _react2.default.PropTypes.string.isRequired,
	    yLabel: _react2.default.PropTypes.string.isRequired,
	    value: _react2.default.PropTypes.number.isRequired,
	    unit: _react2.default.PropTypes.string,
	    foldChange: _react2.default.PropTypes.number,
	    pValue: _react2.default.PropTypes.string,
	    tStat: _react2.default.PropTypes.string,
	    xAxisLegendName: _react2.default.PropTypes.string
	  }, //TODO extend this prop checker.Props for this component are created dynamically so it's important. If differential, expect p-values and fold changes, etc.

	  render: function render() {
	    return _react2.default.createElement(
	      'div',
	      { style: { whiteSpace: "pre" } },
	      this._div(this.props.config.yAxisLegendName, this.props.yLabel),
	      this._div(this.props.xAxisLegendName || this.props.config.xAxisLegendName, this.props.xLabel),
	      this.props.config.isDifferential ? [_react2.default.createElement(
	        'div',
	        { key: "" },
	        this._tinySquare(),
	        this._span("Fold change", this.props.foldChange)
	      ), this._div("P-value", this.props.pValue, scientificNotation), this._div("T-statistic", this.props.tStat)] : _react2.default.createElement(
	        'div',
	        null,
	        [this._tinySquare(), this._span("Expression level", this.props.value ? this.props.value + " " + (this.props.unit || "") : "Below cutoff")]
	      ),
	      !!this.props.config.genomeBrowserTemplate ? this._info("Click on the cell to show expression in the Genome Browser") : null
	    );
	  },
	  _tinySquare: function _tinySquare() {
	    return _react2.default.createElement('span', { key: "Tiny " + this.props.colour + " square",
	      style: {
	        border: "1px rgb(192, 192, 192) solid",
	        marginRight: "2px",
	        width: "6px",
	        height: "6px",
	        display: "inline-block",
	        backgroundColor: this.props.colour
	      } });
	  },
	  _info: function _info(text) {
	    return _react2.default.createElement(
	      'div',
	      null,
	      _react2.default.createElement(
	        'i',
	        null,
	        text
	      )
	    );
	  },
	  _div: function _div(name, value, format) {
	    return name && value ? _react2.default.createElement(
	      'div',
	      { key: name + " " + value },
	      name + ": ",
	      value.length > 50 ? _react2.default.createElement('br', null) : null,
	      (format || this._bold)(value)
	    ) : null;
	  },
	  _span: function _span(name, value) {
	    return _react2.default.createElement(
	      'span',
	      { key: name + " " + value },
	      name + ": ",
	      value.length > 50 ? _react2.default.createElement('br', null) : null,
	      this._bold(value)
	    );
	  },
	  _bold: function _bold(value) {
	    return _react2.default.createElement(
	      'b',
	      null,
	      value
	    );
	  }
	});

	var YAxisLabel = _react2.default.createClass({
	  displayName: 'YAxisLabel',

	  propTypes: {
	    config: _react2.default.PropTypes.shape({
	      atlasBaseURL: _react2.default.PropTypes.string.isRequired,
	      proxyPrefix: _react2.default.PropTypes.string.isRequired,
	      isMultiExperiment: _react2.default.PropTypes.bool.isRequired
	    }).isRequired,
	    labelText: _react2.default.PropTypes.string.isRequired,
	    resourceId: _react2.default.PropTypes.string.isRequired,
	    extra: _react2.default.PropTypes.string
	  },
	  //TODO: remove the "otherwise" branch when production Atlas supplies URIs for labels (expected: early 2017)
	  render: function render() {
	    var geneNameWithLink = _react2.default.createElement(
	      'a',
	      { href: outwardLink(this.props.config.proxyPrefix, this.props.resourceId.startsWith("http") ? this.props.resourceId : this.props.config.atlasBaseURL + (this.props.config.isMultiExperiment ? "/experiments/" : "/genes/") + this.props.resourceId) },
	      this.props.labelText
	    );
	    return this.props.extra ? _react2.default.createElement(
	      'span',
	      null,
	      geneNameWithLink,
	      _react2.default.createElement(
	        'i',
	        { style: { color: "black" } },
	        "\t" + this.props.extra
	      )
	    ) : geneNameWithLink;
	  }
	});

	var reactToHtml = function reactToHtml(component) {
	  return _he2.default.decode(_server2.default.renderToStaticMarkup(component));
	};

	var makeFormatter = function makeFormatter(config) {
	  return {
	    xAxis: function Formatter(value) {
	      return value.label;
	    },
	    xAxisStyle: {
	      fontSize: '9px',
	      cursor: config.isExperimentPage && config.isDifferential ? 'pointer' : 'default',
	      textOverflow: config.isExperimentPage ? 'none' : 'ellipsis'
	    },
	    yAxis: function Formatter(value) {
	      return reactToHtml(_react2.default.createElement(YAxisLabel, {
	        config: config,
	        labelText: value.label,
	        resourceId: value.id,
	        extra: value.info.designElement || "" }));
	    },
	    yAxisStyle: {
	      fontSize: '10px',
	      color: '#148ff3'
	    },
	    tooltip: function Formatter(series, point) {
	      var o = {
	        colour: point.color,
	        xLabel: point.options.info.xLabel || series.xAxis.categories[point.x].label,
	        yLabel: series.yAxis.categories[point.y].label,
	        value: point.value
	      };
	      for (var key in point.options.info) {
	        if (point.options.info.hasOwnProperty(key)) {
	          o[key] = point.options.info[key];
	        }
	      }
	      return reactToHtml(_react2.default.createElement(Tooltip, _extends({}, o, { config: config })));
	    }
	  };
	};

	module.exports = makeFormatter;

/***/ },
/* 687 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(285);


/***/ },
/* 688 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	//*------------------------------------------------------------------*

	module.exports = __webpack_require__(689);

/***/ },
/* 689 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(139); // React is called in the transpiled JS files in the return statements

	//*------------------------------------------------------------------*

	function formatBaselineExpression(expressionLevel) {
	    var numberExpressionLevel = +expressionLevel;
	    return numberExpressionLevel >= 100000 || numberExpressionLevel < 0.1 ? formatScientificNotation(expressionLevel, 1) : '' + numberExpressionLevel;
	}

	// expects number in the format #E# and displays exponent in superscript
	function formatScientificNotation(value, accuracy) {
	    var scientificNotationString = (+value).toExponential(accuracy || 4);

	    var formatParts = scientificNotationString.split(/[Ee]/);

	    if (formatParts.length == 1) {
	        return React.createElement(
	            'span',
	            null,
	            value
	        );
	    }

	    var mantissa = formatParts[0].replace(/([^\.])0+$/, "$1");
	    var exponent = formatParts[1].replace("+", "");

	    if (+exponent == 0) {
	        return React.createElement(
	            'span',
	            null,
	            mantissa
	        );
	    }

	    return React.createElement(
	        'span',
	        null,
	        mantissa !== "1" ? mantissa + ' \xD7 ' : '',
	        '10',
	        React.createElement(
	            'span',
	            { style: { 'verticalAlign': 'super' } },
	            exponent
	        )
	    );
	}

	//*------------------------------------------------------------------*

	exports.baselineExpression = formatBaselineExpression;
	exports.scientificNotation = formatScientificNotation;

/***/ },
/* 690 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (proxyPrefix, url) {
	    return proxyPrefix.endsWith("http://") || proxyPrefix.endsWith("https://") ? proxyPrefix + url.replace(/^https?:\/\//, "") : proxyPrefix + url;
	};

/***/ },
/* 691 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	This module returns functions that take in labels of rows/columns,
	and return content as it should appear in tooltip.
	*/
	//*------------------------------------------------------------------*

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var React = __webpack_require__(139);

	var GeneTooltip = __webpack_require__(692);
	__webpack_require__(693);

	//*------------------------------------------------------------------*

	var createColumnLabelTooltipRenderer = function createColumnLabelTooltipRenderer(heatmapConfig, xAxisCategories) {
	  if (!heatmapConfig.isExperimentPage) {
	    return function () {
	      return null;
	    };
	  }

	  var tooltipDataPerHeader = {};
	  for (var i = 0; i < xAxisCategories.length; i++) {
	    if (xAxisCategories[i].info.tooltip) {
	      tooltipDataPerHeader[xAxisCategories[i].label] = xAxisCategories[i].info.tooltip;
	    }
	  }
	  Object.freeze(tooltipDataPerHeader);

	  var Tooltip = heatmapConfig.isDifferential ? __webpack_require__(695) : __webpack_require__(696);

	  return function (columnLabel) {
	    return tooltipDataPerHeader.hasOwnProperty(columnLabel) ? React.createElement(Tooltip, tooltipDataPerHeader[columnLabel]) : null;
	  };
	};
	var createRowLabelTooltipRenderer = function createRowLabelTooltipRenderer(heatmapConfig, yAxisCategories) {
	  //We have the labels, but we need the indentifiers to do lookups
	  var rowHeaderPerLabel = {};
	  for (var i = 0; i < yAxisCategories.length; i++) {
	    rowHeaderPerLabel[yAxisCategories[i].label] = yAxisCategories[i];
	  }
	  Object.freeze(rowHeaderPerLabel);

	  var resultCache = {};
	  return function (rowLabel) {
	    if (!rowHeaderPerLabel.hasOwnProperty(rowLabel)) {
	      return null;
	    }
	    var bioentityIdentifier = rowHeaderPerLabel[rowLabel].id;
	    return React.createElement(GeneTooltip, _extends({
	      key: bioentityIdentifier,
	      atlasBaseURL: heatmapConfig.atlasBaseURL,
	      label: rowLabel,
	      id: bioentityIdentifier,
	      designElement: rowHeaderPerLabel[rowLabel].info.designElement || ""
	    }, resultCache.hasOwnProperty(bioentityIdentifier) ? { data: resultCache[bioentityIdentifier] } : { onAjaxSuccessfulCacheResult: function onAjaxSuccessfulCacheResult(result) {
	        resultCache[bioentityIdentifier] = result;
	      } }));
	  };
	};

	//TODO consider what the interface of this function should be.
	module.exports = function (heatmapConfig, xAxisCategories, yAxisCategories) {
	  return {
	    row: createRowLabelTooltipRenderer(heatmapConfig, yAxisCategories),
	    column: createColumnLabelTooltipRenderer(heatmapConfig, xAxisCategories),
	    point: function point() {}
	  };
	};

/***/ },
/* 692 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	//*------------------------------------------------------------------*

	var React = __webpack_require__(139);

	//*------------------------------------------------------------------*

	var GeneTooltip = React.createClass({
	  displayName: 'GeneTooltip',

	  propTypes: {
	    atlasBaseURL: React.PropTypes.string.isRequired,
	    label: React.PropTypes.string.isRequired,
	    id: React.PropTypes.string.isRequired,
	    designElement: React.PropTypes.string,
	    data: React.PropTypes.shape({
	      synonyms: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	      goterms: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	      interproterms: React.PropTypes.arrayOf(React.PropTypes.string).isRequired
	    }),
	    onAjaxSuccessfulCacheResult: React.PropTypes.func
	  },
	  getInitialState: function getInitialState(props) {
	    return {
	      loaded: !!this.props.data,
	      error: false,
	      data: this.props.data || {
	        synonyms: [],
	        goterms: [],
	        interproterms: []
	      }
	    };
	  },
	  componentDidMount: function componentDidMount() {
	    if (this.state.loaded) {
	      return;
	    }
	    //https://www.sitepoint.com/guide-vanilla-ajax-without-jquery/
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', this.props.atlasBaseURL + "/json/genename-tooltip?identifier=" + this.props.id, true);
	    xhr.onreadystatechange = function () {
	      if (xhr.readyState === 4) {
	        //request done
	        if (xhr.status === 200) {
	          var result = JSON.parse(xhr.responseText);
	          this.setState({ data: result, loaded: true });
	          this.props.onAjaxSuccessfulCacheResult && this.props.onAjaxSuccessfulCacheResult(result);
	        } else {
	          this.setState({ error: xhr.status, loaded: true });
	        }
	      }
	    }.bind(this);
	    xhr.send();
	  },
	  _row: function _row(name, values) {
	    return React.createElement(
	      'div',
	      null,
	      React.createElement(
	        'span',
	        { className: 'propertyName' },
	        name
	      ),
	      React.createElement(
	        'span',
	        { className: 'propertyValues' },
	        values
	      )
	    );
	  },

	  _propertyValueList: function _propertyValueList(values) {
	    return values.map(function (value) {
	      return React.createElement(
	        'span',
	        { className: 'propertyValue', key: value },
	        value
	      );
	    });
	  },
	  _bracketedList: function _bracketedList(values) {
	    return values.length ? [React.createElement(
	      'span',
	      { key: '(' },
	      "("
	    )].concat(this._propertyValueList(values)).concat([React.createElement(
	      'span',
	      { key: ')' },
	      ")"
	    )]) : [];
	  },


	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'gxaGeneTooltip' },
	      this._row(this.props.label, this._bracketedList([].concat.apply([], [this.props.label].concat(this.state.data.synonyms).indexOf(this.props.id) == -1 ? [this.props.id] : [], this.state.data.synonyms))),
	      this.props.designElement ? this._row("Design element:", this._propertyValueList([this.props.designElement])) : null,
	      this.state.data.goterms.length ? this._row("Gene ontology terms:", this._propertyValueList(this.state.data.goterms)) : null,
	      this.state.data.interproterms.length ? this._row("Interpro terms:", this._propertyValueList(this.state.data.interproterms)) : null,
	      this.state.loading ? React.createElement(
	        'div',
	        null,
	        '...'
	      ) : null,
	      this.state.error ? React.createElement(
	        'div',
	        null,
	        "Error: " + this.state.error
	      ) : null
	    );
	  }
	});

	module.exports = GeneTooltip;

/***/ },
/* 693 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(694);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(672)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/less-loader/index.js!./Tooltips.less", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/less-loader/index.js!./Tooltips.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 694 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(671)();
	// imports


	// module
	exports.push([module.id, ".gxaTooltip {\n  border: solid transparent;\n  color: darkslategray;\n  padding: 2px;\n  font: 10px Verdana, Helvetica, Arial, sans-serif;\n  background-color: floralwhite;\n}\n.gxaTooltip table {\n  margin: 0;\n  /* overrides ebi-visual.css:134 */\n  background-color: white;\n  border: 1px solid lightgrey;\n  border-collapse: collapse;\n}\n.gxaTooltip th {\n  border-bottom: 1px solid lightgrey;\n  background-color: floralwhite;\n}\n.gxaTooltip td {\n  border: 1px solid lightgrey;\n}\n.gxaTooltip td,\n.gxaTooltip .gxaTooltip th {\n  vertical-align: middle;\n  padding: 8px;\n}\n.gxaGeneTooltip {\n  border: solid transparent;\n  color: darkslategray;\n  padding: 2px;\n  font: 10px Verdana, Helvetica, Arial, sans-serif;\n  background-color: floralwhite;\n  max-width: 250px;\n  text-align: justify;\n}\n.gxaGeneTooltip table {\n  margin: 0;\n  /* overrides ebi-visual.css:134 */\n  background-color: white;\n  border: 1px solid lightgrey;\n  border-collapse: collapse;\n}\n.gxaGeneTooltip th {\n  border-bottom: 1px solid lightgrey;\n  background-color: floralwhite;\n}\n.gxaGeneTooltip td {\n  border: 1px solid lightgrey;\n}\n.gxaGeneTooltip td,\n.gxaGeneTooltip .gxaTooltip th {\n  vertical-align: middle;\n  padding: 8px;\n}\n.gxaGeneTooltip .propertyName {\n  color: brown;\n  font-weight: bold;\n  display: inline-block;\n  text-align: left;\n  margin-right: 5px;\n}\n.gxaGeneTooltip .propertyValue {\n  display: inline-block;\n  text-align: center;\n  background-color: #dfd5d5;\n}\n.gxaGeneTooltip .propertyValue:first-child {\n  margin-left: 5px;\n}\n.gxaGeneTooltip .propertyValue + .propertyValue {\n  margin-left: 5px;\n}\n.gxaContrastTooltip {\n  border: solid transparent;\n  color: darkslategray;\n  padding: 2px;\n  font: 10px Verdana, Helvetica, Arial, sans-serif;\n  background-color: floralwhite;\n  max-width: 500px;\n  display: inline-block;\n}\n.gxaContrastTooltip table {\n  margin: 0;\n  /* overrides ebi-visual.css:134 */\n  background-color: white;\n  border: 1px solid lightgrey;\n  border-collapse: collapse;\n}\n.gxaContrastTooltip th {\n  border-bottom: 1px solid lightgrey;\n  background-color: floralwhite;\n}\n.gxaContrastTooltip td {\n  border: 1px solid lightgrey;\n}\n.gxaContrastTooltip td,\n.gxaContrastTooltip .gxaTooltip th {\n  vertical-align: middle;\n  padding: 8px;\n}\n.gxaContrastTooltip .contrastPlots .info {\n  font-style: italic;\n  font-size: xsmall;\n  align-content: right;\n  text-align: right;\n}\n.gxaFactorTooltip {\n  border: solid transparent;\n  color: darkslategray;\n  padding: 2px;\n  font: 10px Verdana, Helvetica, Arial, sans-serif;\n  background-color: floralwhite;\n  max-width: 600px;\n}\n.gxaFactorTooltip table {\n  margin: 0;\n  /* overrides ebi-visual.css:134 */\n  background-color: white;\n  border: 1px solid lightgrey;\n  border-collapse: collapse;\n}\n.gxaFactorTooltip th {\n  border-bottom: 1px solid lightgrey;\n  background-color: floralwhite;\n}\n.gxaFactorTooltip td {\n  border: 1px solid lightgrey;\n}\n.gxaFactorTooltip td,\n.gxaFactorTooltip .gxaTooltip th {\n  vertical-align: middle;\n  padding: 8px;\n}\n", ""]);

	// exports


/***/ },
/* 695 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	//*------------------------------------------------------------------*

	var React = __webpack_require__(139);

	//*------------------------------------------------------------------*

	var contrastTablePropTypes = {
	    experimentDescription: React.PropTypes.string.isRequired,
	    contrastDescription: React.PropTypes.string.isRequired,
	    testReplicates: React.PropTypes.number.isRequired,
	    referenceReplicates: React.PropTypes.number.isRequired,
	    properties: React.PropTypes.arrayOf(React.PropTypes.shape({
	        contrastPropertyType: React.PropTypes.string,
	        propertyName: React.PropTypes.string.isRequired,
	        referenceValue: React.PropTypes.string.isRequired,
	        testValue: React.PropTypes.string.isRequired
	    }))
	};

	var ContrastTooltipTable = React.createClass({
	    displayName: "ContrastTooltipTable",

	    propTypes: contrastTablePropTypes,

	    propertyRow: function propertyRow(property) {
	        if (!property.testValue && !property.referenceValue) {
	            return null;
	        }

	        function isFactor(property) {
	            return property.contrastPropertyType === "FACTOR";
	        }

	        var style = { whiteSpace: "normal" };

	        if (isFactor(property)) {
	            style.fontWeight = "bold";
	        } else {
	            style.color = "gray";
	        }

	        return React.createElement(
	            "tr",
	            { key: property.contrastPropertyType + "-" + property.propertyName },
	            React.createElement(
	                "td",
	                { style: style },
	                property.propertyName
	            ),
	            React.createElement(
	                "td",
	                { style: style },
	                property.testValue
	            ),
	            React.createElement(
	                "td",
	                { style: style },
	                property.referenceValue
	            )
	        );
	    },

	    render: function render() {
	        return React.createElement(
	            "div",
	            null,
	            React.createElement(
	                "div",
	                { id: "contrastExperimentDescription", style: { fontWeight: "bold", color: "blue", textAlign: "center" } },
	                this.props.experimentDescription
	            ),
	            React.createElement(
	                "div",
	                { id: "contrastDescription", style: { textAlign: "center" } },
	                this.props.contrastDescription
	            ),
	            React.createElement(
	                "table",
	                { style: { padding: "0px", margin: "0px", width: "100%" } },
	                React.createElement(
	                    "thead",
	                    null,
	                    React.createElement(
	                        "tr",
	                        null,
	                        React.createElement(
	                            "th",
	                            null,
	                            "Property"
	                        ),
	                        React.createElement(
	                            "th",
	                            null,
	                            "Test value (N=",
	                            this.props.testReplicates,
	                            ")"
	                        ),
	                        React.createElement(
	                            "th",
	                            null,
	                            "Reference value (N=",
	                            this.props.referenceReplicates,
	                            ")"
	                        )
	                    )
	                ),
	                React.createElement(
	                    "tbody",
	                    null,
	                    this.props.properties.map(this.propertyRow)
	                )
	            )
	        );
	    }
	});

	var ContrastTooltip = React.createClass({
	    displayName: "ContrastTooltip",

	    propTypes: Object.assign({
	        resources: React.PropTypes.arrayOf(React.PropTypes.shape({
	            type: React.PropTypes.oneOf(["gsea_go", "gsea_interpro", "gsea_reactome", "ma-plot"]).isRequired,
	            uri: React.PropTypes.string.isRequired
	        })).isRequired
	    }, contrastTablePropTypes),

	    render: function render() {
	        var descriptions = {
	            "gsea_go": "Click to view GO terms enrichment analysis plot",
	            "gsea_interpro": "Click to view Interpro domains enrichment analysis plot",
	            "gsea_reactome": "Click to view Reactome pathways enrichment analysis plot",
	            "ma-plot": "Click to view MA plot for the contrast across all genes"
	        };
	        return React.createElement(
	            "div",
	            { className: "gxaContrastTooltip" },
	            React.createElement(ContrastTooltipTable, this.props),
	            React.createElement(
	                "div",
	                { className: "contrastPlots" },
	                React.createElement(
	                    "span",
	                    null,
	                    this.props.resources.length && React.createElement(
	                        "span",
	                        null,
	                        " Available plots: "
	                    ),
	                    this.props.resources.map(function (resource) {
	                        return React.createElement(
	                            "a",
	                            {
	                                href: resource.uri,
	                                key: resource.type,
	                                title: descriptions[resource.type],
	                                style: { textDecoration: "none" },
	                                target: "_blank" },
	                            React.createElement("img", { src: resource.icon })
	                        );
	                    })
	                ),
	                React.createElement(
	                    "div",
	                    { className: "info" },
	                    " Click label to interact with tooltip"
	                )
	            )
	        );
	    }
	});

	//*------------------------------------------------------------------*

	module.exports = ContrastTooltip;

/***/ },
/* 696 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	//*------------------------------------------------------------------*

	var React = __webpack_require__(139);

	//*------------------------------------------------------------------*

	var FactorTooltip = React.createClass({
	  displayName: 'FactorTooltip',


	  propertyRow: function propertyRow(property) {
	    if (!property.testValue) {
	      return null;
	    }

	    function isFactor(property) {
	      return property.contrastPropertyType === 'FACTOR';
	    }

	    var style = { 'whiteSpace': 'normal' };

	    if (isFactor(property)) {
	      style['fontWeight'] = 'bold';
	    } else {
	      style['color'] = 'gray';
	    }

	    return React.createElement(
	      'tr',
	      { key: property.propertyName },
	      React.createElement(
	        'td',
	        { style: style },
	        property.propertyName
	      ),
	      React.createElement(
	        'td',
	        { style: style },
	        property.testValue
	      )
	    );
	  },

	  render: function render() {
	    var _this = this;

	    var propertyNames = this.props.properties.map(function (e) {
	      return e.propertyName;
	    }).filter(function (e, ix, self) {
	      return self.indexOf(e) == ix;
	    });

	    return React.createElement(
	      'div',
	      { className: 'gxaFactorTooltip' },
	      React.createElement(
	        'table',
	        null,
	        React.createElement(
	          'thead',
	          null,
	          React.createElement(
	            'tr',
	            null,
	            React.createElement(
	              'th',
	              null,
	              'Property'
	            ),
	            React.createElement(
	              'th',
	              null,
	              'Value',
	              this.props.replicates ? " (N=" + this.props.replicates + ")" : ""
	            )
	          )
	        ),
	        React.createElement(
	          'tbody',
	          null,
	          propertyNames.map(function (propertyName) {
	            var values = _this.props.properties.filter(function (e) {
	              return e.propertyName == propertyName;
	            }).map(function (e) {
	              return e.testValue;
	            }).filter(function (e, ix, self) {
	              return self.indexOf(e) == ix;
	            });
	            return {
	              propertyName: propertyName,
	              testValue: values.length ? values.reduce(function (l, r) {
	                return l + ", " + r;
	              }) : ""
	            };
	          }).map(this.propertyRow)
	        )
	      )
	    );
	  }
	});

	//*------------------------------------------------------------------*

	module.exports = FactorTooltip;

/***/ },
/* 697 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(139);
	// const validate = require(`react-prop-types-check`);


	var PointPropType = React.PropTypes.shape({
	    x: React.PropTypes.number.isRequired,
	    y: React.PropTypes.number.isRequired,
	    value: React.PropTypes.number.isRequired,
	    info: React.PropTypes.object.isRequired
	});

	var PointsInDataSeriesPropType = React.PropTypes.arrayOf(React.PropTypes.arrayOf(PointPropType));

	var DataSeriesProps = {
	    info: React.PropTypes.shape({
	        colour: React.PropTypes.string.isRequired,
	        name: React.PropTypes.string.isRequired
	    }),
	    data: React.PropTypes.arrayOf(PointPropType).isRequired
	};

	// PropTypes should only be used with proper React components
	// https://facebook.github.io/react/warnings/dont-call-proptypes.html
	// const ValidateDataSeries = dataSeries => {
	//     dataSeries.forEach(series => {
	//         validate(series, DataSeriesProps);
	//     });
	// };


	var AxisCategoriesPropType = React.PropTypes.arrayOf(React.PropTypes.shape({
	    id: React.PropTypes.string, // ontology ID can be missing for x axis
	    label: React.PropTypes.string.isRequired,
	    info: React.PropTypes.shape({
	        trackId: React.PropTypes.string,
	        tooltip: React.PropTypes.object
	    }).isRequired
	})).isRequired;

	var OrderingsPropType = function OrderingsPropType(props, propName) {
	    var orderings = props[propName];

	    var isPermutation = function isPermutation(arr) {
	        return [].concat(arr).sort(function (a, b) {
	            return a - b;
	        }).map(function (el, ix) {
	            return el === ix;
	        }).reduce(function (l, r) {
	            return l && r;
	        });
	    };

	    if (!orderings.hasOwnProperty("Default")) {
	        return new Error("Default ordering missing");
	    }

	    Object.keys(orderings).forEach(function (orderingName) {
	        var ordering = orderings[orderingName];

	        if (!isPermutation(ordering.columns)) {
	            return new Error("Column ordering invalid in " + orderingName);
	        }
	        if (!isPermutation(ordering.rows)) {
	            return new Error("Row ordering invalid in " + orderingName);
	        }
	    });
	};

	var HeatmapDataPropType = function HeatmapDataPropType(props, propName) {
	    var heatmapData = props[propName];
	    // const possiblyError = ValidateDataSeries(heatmapData.dataSeries);
	    // if (possiblyError !== undefined) {
	    //     return possiblyError;
	    // }

	    var width = heatmapData.xAxisCategories.length;
	    var height = heatmapData.yAxisCategories.length;

	    for (var i = 0; i < heatmapData.dataSeries.length; i++) {
	        for (var j = 0; j < heatmapData.dataSeries[i].data.length; j++) {
	            var point = heatmapData.dataSeries[i].data[j];
	            var x = point.x;
	            var y = point.y;
	            if (x < 0 || y < 0 || x >= width || y >= height) {
	                return new Error("Point with coordinates outside range: " + x + ", " + y);
	            }
	        }
	    }
	};

	var LoadResultPropType = React.PropTypes.shape({
	    heatmapConfig: React.PropTypes.object.isRequired,
	    colorAxis: React.PropTypes.object,
	    orderings: OrderingsPropType,
	    heatmapData: HeatmapDataPropType
	});

	var FormatterPropType = function FormatterPropType(props, propName) {
	    var f = props[propName];
	    if (f === undefined) {
	        return new Error(propName + " formatter missing");
	    } else if (typeof f !== "function" || f.name !== "Formatter") {
	        return new Error(propName + " formatter not correctly created. See the main method of TooltipFormatter.jsx.");
	    }
	};

	var OrderingsPropTypes = React.PropTypes.shape({
	    available: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	    selected: React.PropTypes.string.isRequired,
	    onSelect: React.PropTypes.func.isRequired
	}).isRequired;

	/*
	selected should be a subset of values
	valueGroupings should be two element arrays, one the name of the grouping and the second a subset of values
	*/
	var FilterProps = {
	    name: React.PropTypes.string.isRequired,
	    values: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	    selected: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	    valueGroupings: React.PropTypes.arrayOf(function (props, propName) {
	        var prop = props[propName];

	        if (prop === undefined) {
	            return new Error(propName + " missing in " + props);
	        } else if (!Array.isArray(prop) || prop.length !== 2) {
	            return new Error(prop + " invalid: expected array of length two");
	        } else if (typeof prop[0] !== "string") {
	            return new Error(prop[0] + " should be a string representing name of the grouping");
	        } else if (!Array.isArray(prop[1])) {
	            return new Error(prop[1] + " should be an array with members of the grouping ");
	        }
	    })
	};

	module.exports = {
	    // validateDataSeries : ValidateDataSeries,
	    PointsInDataSeries: PointsInDataSeriesPropType,
	    Point: PointPropType,
	    HeatmapData: HeatmapDataPropType,
	    LoadResult: LoadResultPropType,
	    AxisCategories: AxisCategoriesPropType,
	    Formatter: FormatterPropType,
	    Orderings: OrderingsPropTypes,
	    Filter: React.PropTypes.shape(FilterProps).isRequired,
	    FilterProps: FilterProps
	};

/***/ },
/* 698 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var React = __webpack_require__(139);
	var PropTypes = __webpack_require__(697);
	var DownloadProfilesButton = __webpack_require__(699);
	var HeatmapCanvas = __webpack_require__(722);
	var OrderingsDropdown = __webpack_require__(723);
	var SettingsModal = __webpack_require__(724);
	var TooltipStateManager = __webpack_require__(795);
	var CoexpressionOption = __webpack_require__(809);

	__webpack_require__(814);

	var HeatmapLegendBox = React.createClass({
	    displayName: "HeatmapLegendBox",

	    propTypes: {
	        name: React.PropTypes.string.isRequired,
	        colour: React.PropTypes.string.isRequired,
	        on: React.PropTypes.bool.isRequired
	    },

	    render: function render() {
	        return React.createElement(
	            "div",
	            { className: "legend-item" + (this.props.on ? "" : " legend-item-off") },
	            React.createElement("div", { style: { background: this.props.colour }, className: "legend-rectangle" }),
	            React.createElement(
	                "span",
	                { style: { verticalAlign: "middle" } },
	                this.props.name
	            )
	        );
	    }
	});

	var HeatmapOptions = React.createClass({
	    displayName: "HeatmapOptions",

	    propTypes: {
	        marginRight: React.PropTypes.number.isRequired,
	        downloadOptions: React.PropTypes.object.isRequired,
	        googleAnalyticsCallback: React.PropTypes.func.isRequired,
	        showUsageMessage: React.PropTypes.bool.isRequired,
	        orderings: React.PropTypes.shape(PropTypes.Orderings),
	        filters: React.PropTypes.arrayOf(PropTypes.Filter).isRequired,
	        filtersSelect: React.PropTypes.func.isRequired,
	        disableSettings: React.PropTypes.bool.isRequired
	    },

	    render: function render() {
	        var _this = this;

	        return React.createElement(
	            "div",
	            { className: "gxaHeatmapCountAndLegend", style: { paddingBottom: "15px", position: "sticky", zIndex: "1" } },
	            React.createElement(
	                "div",
	                { style: { display: "inline-block", verticalAlign: "top" } },
	                this.props.introductoryMessage
	            ),
	            React.createElement(
	                "div",
	                { style: { display: "inline-block", verticalAlign: "top", float: "right", marginRight: this.props.marginRight } },
	                React.createElement(
	                    "div",
	                    { style: { display: "inline-block" } },
	                    React.createElement(OrderingsDropdown, {
	                        orderings: this.props.orderings,
	                        disabled: this.props.disableSettings
	                    })
	                ),
	                React.createElement(
	                    "div",
	                    { style: { display: "inline-block", paddingLeft: "10px" } },
	                    React.createElement(SettingsModal, {
	                        filters: this.props.filters,
	                        orderings: this.props.orderings,
	                        propagateChosenFilterSelection: this.props.filtersSelect,
	                        disabled: this.props.disableSettings
	                    })
	                ),
	                React.createElement(
	                    "div",
	                    { style: { display: "inline-block", paddingLeft: "10px" } },
	                    React.createElement(DownloadProfilesButton, _extends({}, this.props.downloadOptions, {
	                        onDownloadCallbackForAnalytics: function onDownloadCallbackForAnalytics() {
	                            _this.props.googleAnalyticsCallback("send", "event", "HeatmapHighcharts", "downloadData");
	                        }
	                    }))
	                )
	            ),
	            this.props.showUsageMessage ? React.createElement(
	                "div",
	                { style: { fontSize: "small", color: "grey" } },
	                "Select a section of the heatmap to zoom in"
	            ) : null
	        );
	    }
	});

	var HeatmapCanvasWithTooltips = React.createClass({
	    displayName: "HeatmapCanvasWithTooltips",
	    render: function render() {
	        return React.createElement(TooltipStateManager, {
	            managedComponent: HeatmapCanvas,
	            managedComponentProps: this.props.heatmapProps,
	            tooltips: this.props.tooltips,
	            onUserSelectsColumn: this.props.anatomogramCallbacks.onUserSelectsColumn,
	            onUserSelectsRow: this.props.anatomogramCallbacks.onUserSelectsRow,
	            onUserSelectsPoint: this.props.anatomogramCallbacks.onUserSelectsPoint,
	            enableFreeze: this.props.enableFreeze
	        });
	    }
	});

	var __heatmapCanvas = function __heatmapCanvas(tooltips, anatomogramCallbacks, heatmapProps, interactiveColumnTooltips) {
	    return !tooltips ? React.createElement(HeatmapCanvas, _extends({}, heatmapProps, anatomogramCallbacks)) : React.createElement(HeatmapCanvasWithTooltips, {
	        heatmapProps: heatmapProps,
	        tooltips: tooltips,
	        anatomogramCallbacks: anatomogramCallbacks,
	        enableFreeze: interactiveColumnTooltips
	    });
	};

	var heatmapCanvas = function heatmapCanvas(heatmapConfig, tooltips, anatomogramCallbacks, heatmapProps) {
	    return __heatmapCanvas(heatmapConfig.isExperimentPage && tooltips, anatomogramCallbacks, heatmapProps, heatmapConfig.isExperimentPage && heatmapConfig.isDifferential);
	};

	var anatomogramCallbacks = function anatomogramCallbacks(heatmapDataToPresent, highlightOntologyIds) {
	    return {
	        onUserSelectsRow: function onUserSelectsRow(rowLabel) {
	            var y = heatmapDataToPresent.yAxisCategories.findIndex(function (e) {
	                return e.label === rowLabel;
	            });

	            highlightOntologyIds([].concat.apply([], [].concat.apply([], heatmapDataToPresent.dataSeries.map(function (series) {
	                return series.data;
	            })).filter(function (point) {
	                return point.y === y;
	            }).map(function (point) {
	                return point.info.xId || heatmapDataToPresent.xAxisCategories[point.x].id;
	            }).map(function (e) {
	                return Array.isArray(e) ? e : [e];
	            })).filter(function (e, ix, self) {
	                return self.indexOf(e) === ix;
	            }));
	        },
	        onUserSelectsColumn: function onUserSelectsColumn(columnLabel) {
	            highlightOntologyIds(heatmapDataToPresent.xAxisCategories.filter(function (e) {
	                return e.label === columnLabel;
	            }).map(function (e) {
	                return e.id;
	            }).concat([""])[0]);
	        },
	        onUserSelectsPoint: function onUserSelectsPoint(columnId) {
	            //Column ids are, in fact, factorValueOntologyTermId's
	            highlightOntologyIds(columnId || "");
	        }
	    };
	};

	var show = function show(heatmapDataToPresent, orderings, filters, filtersSelect, zoom, zoomCallback, colorAxis, formatters, tooltips, legend, coexpressions, properties) {
	    var marginRight = 60;
	    var heatmapConfig = properties.loadResult.heatmapConfig;
	    return React.createElement(
	        "div",
	        null,
	        React.createElement(HeatmapOptions, { marginRight: marginRight,
	            introductoryMessage: heatmapConfig.introductoryMessage,
	            downloadOptions: {
	                download: {
	                    name: heatmapConfig.shortDescription || "download",
	                    descriptionLines: [].concat.apply([], [heatmapConfig.description, orderings.selected != "Default" ? ["Ordering: " + orderings.selected] : [], filters.filter(function (_filter) {
	                        return _filter.selected.length < _filter.values.length;
	                    }).map(function (_filter) {
	                        return "Filter By " + _filter.name + ": " + (_filter.selected.length < 5 ? _filter.selected.join(", ") : _filter.selected.length) + " selected out of " + (_filter.values.length < 5 ? _filter.values.join(", ") : _filter.values.length + " filter values");
	                    }), coexpressions ? "Including " + coexpressions.numCoexpressionsVisible + " genes with similar expression pattern" : []]),
	                    heatmapData: heatmapDataToPresent
	                },
	                disclaimer: heatmapConfig.disclaimer
	            },
	            orderings: orderings,
	            filters: filters,
	            filtersSelect: filtersSelect,
	            disableSettings: zoom,
	            googleAnalyticsCallback: properties.googleAnalyticsCallback,
	            showUsageMessage: heatmapDataToPresent.xAxisCategories.length > 100
	        }),
	        React.createElement(
	            "div",
	            null,
	            heatmapDataToPresent.dataSeries.map(function (e) {
	                return e.data;
	            }).reduce(function (l, r) {
	                return l.concat(r);
	            }, []).length ? heatmapCanvas(heatmapConfig, tooltips, anatomogramCallbacks(heatmapDataToPresent, properties.onOntologyIdIsUnderFocus), {
	                marginRight: marginRight,
	                ontologyIdsToHighlight: properties.ontologyIdsToHighlight,
	                heatmapData: heatmapDataToPresent,
	                colorAxis: colorAxis,
	                onHeatmapRedrawn: properties.onHeatmapRedrawn,
	                formatters: formatters,
	                genomeBrowserTemplate: heatmapConfig.genomeBrowserTemplate,
	                onZoom: zoomCallback
	            }) : React.createElement(
	                "p",
	                null,
	                " No data in the series currently selected. "
	            )
	        ),
	        legend ? React.createElement(
	            "div",
	            { className: "gxaHeatmapLegend" },
	            legend.map(function (legendItemProps) {
	                return React.createElement(HeatmapLegendBox, legendItemProps);
	            }),
	            React.createElement(
	                "div",
	                { className: "legend-item" },
	                React.createElement("span", { className: "icon icon-generic", "data-icon": "i", "data-toggle": "tooltip", "data-placement": "bottom",
	                    title: "Baseline expression levels in RNA-seq experiments are in FPKM or TPM. Low: 0.5-10, Medium: 11-1000,  High: >1000. Proteomics expression levels are mapped to low, medium, high on per experiment basis." })
	            ),
	            React.createElement(HeatmapLegendBox, { key: "No data available",
	                name: "No data available",
	                colour: "white",
	                on: true
	            })
	        ) : null,
	        coexpressions ? React.createElement(CoexpressionOption, coexpressions) : null
	    );
	};

	module.exports = show;

/***/ },
/* 699 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(139);
	var Modal = __webpack_require__(537);
	var Button = __webpack_require__(390);
	var Glyphicon = __webpack_require__(396);
	var Disclaimers = __webpack_require__(700);
	var PropTypes = __webpack_require__(697);

	var Download = __webpack_require__(701).CommenceDownload;
	var DownloadProfilesButton = React.createClass({
	    displayName: 'DownloadProfilesButton',

	    propTypes: {
	        download: React.PropTypes.shape({
	            name: React.PropTypes.string.isRequired,
	            descriptionLines: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	            heatmapData: PropTypes.HeatmapData
	        }),
	        disclaimer: React.PropTypes.string.isRequired,
	        onDownloadCallbackForAnalytics: React.PropTypes.func.isRequired
	    },

	    getInitialState: function getInitialState() {
	        return { showModal: false };
	    },
	    _closeModal: function _closeModal() {
	        this.setState({ showModal: false });
	    },
	    _disclaimer: function _disclaimer() {
	        return this.props.disclaimer && Disclaimers[this.props.disclaimer] || { title: null, content: null };
	    },
	    _afterDownloadButtonClicked: function _afterDownloadButtonClicked() {
	        if (!this._disclaimer().title && !this._disclaimer().content) {
	            this._commenceDownload();
	        } else {
	            this.setState({ showModal: true });
	        }
	    },
	    _commenceDownload: function _commenceDownload() {
	        this.props.onDownloadCallbackForAnalytics();
	        Download(this.props.download);
	    },
	    _commenceDownloadAndCloseModal: function _commenceDownloadAndCloseModal() {
	        this._commenceDownload();
	        this._closeModal();
	    },
	    render: function render() {
	        return React.createElement(
	            'a',
	            { onClick: this._afterDownloadButtonClicked },
	            React.createElement(
	                Button,
	                { bsSize: 'small',
	                    style: { textTransform: 'unset', letterSpacing: 'unset', height: 'unset' } },
	                React.createElement(Glyphicon, { glyph: 'download-alt' }),
	                ' Download table content'
	            ),
	            React.createElement(
	                Modal,
	                { show: this.state.showModal, onHide: this._closeModal },
	                React.createElement(
	                    Modal.Header,
	                    { closeButton: true },
	                    React.createElement(
	                        Modal.Title,
	                        null,
	                        this._disclaimer().title
	                    )
	                ),
	                React.createElement(
	                    Modal.Body,
	                    null,
	                    this._disclaimer().content
	                ),
	                React.createElement(
	                    Modal.Footer,
	                    null,
	                    React.createElement(
	                        Button,
	                        { onClick: this._closeModal },
	                        'Close'
	                    ),
	                    React.createElement(
	                        Button,
	                        { bsStyle: 'primary', onClick: this._commenceDownloadAndCloseModal },
	                        'Continue downloading'
	                    )
	                )
	            )
	        );
	    }
	});

	module.exports = DownloadProfilesButton;

/***/ },
/* 700 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(139);

	var BlueprintText = {
	    title: "The Blueprint project Data Reuse statement",
	    content: React.createElement(
	        "div",
	        null,
	        React.createElement(
	            "p",
	            null,
	            "This document refers to the reuse of data generated by the EC funded FP7 High Impact Project, Blueprint."
	        ),
	        React.createElement(
	            "p",
	            null,
	            "Blueprint regularly released analysis results via its ftp site and makes the raw sequence data available through the sequence archives at the EMBL-EBI. Much Blueprint data is generated from samples whose data must be released through a managed access process. For these data sets external users must apply for permission to access the data from the European Genome-phenome Archive (EGA) through the Blueprint Data Access Committee."
	        ),
	        React.createElement(
	            "p",
	            null,
	            "The Blueprint consortium expects this data to be valuable to other researchers and in keeping with Fort Lauderdale principles data users may use the data for many studies, but are expected to allow the data producers to make the first presentations and to publish the first paper with global analyses of the data."
	        ),
	        React.createElement(
	            "h4",
	            null,
	            "Global analyses of Project data"
	        ),
	        React.createElement(
	            "p",
	            null,
	            "Blueprint plans to publish global analyses of the sequencing data, epigenetic marks, expression levels and variation both in the context of normal hematopoietic cells and of those neoplastic and non-neoplastic diseases studied within th econsortium. Talks, posters, and papers on all such analyses are to be published first by the Blueprint project, by approved presenters on behalf of the Project, with the Project as author. When the first major Project paper on these analyses is published, then researchers inside and outside the Project are free to present and publish using the Project data for these and other analyses."
	        ),
	        React.createElement(
	            "h4",
	            null,
	            "Large-scale analyses of Project data"
	        ),
	        React.createElement(
	            "p",
	            null,
	            "Groups within the Project may make presentations and publish papers on more extensive analyses of topics to be included in the main analysis presentations and papers, coincident with the main project analysis presentations and papers. The major points would be included in the main Project presentations and papers, but these additional presentations and papers allow more focused discussion of methods and results. The author list would include the Consortium."
	        ),
	        React.createElement(
	            "h4",
	            null,
	            "Methods development using Project data"
	        ),
	        React.createElement(
	            "p",
	            null,
	            "Researchers who have used small amounts of Project data (<= one chromosome) may present methods development posters, talks, and papers that include these data prior to the first major Project paper, without needing Project approval or authorship, although the Project should be acknowledged. Methods presentations or papers on global analyses or analyses using large amounts of Project data, on topics that the Consortium plans to examine, would be similar to large-scale analyses of Project data: researchers within the Project may make presentations or submit papers at the same time as the main Project presentations and papers, and others could do so after the Project publishes the first major analysis paper."
	        ),
	        React.createElement(
	            "h4",
	            null,
	            "Disease studies using Project data"
	        ),
	        React.createElement(
	            "p",
	            null,
	            "Researchers may present and publish on use of Project data in specific chromosome regions (that are not of general interest) or as summaries (such as number of differentially expressed genes in cell types assayed by Blueprint) for studies on diseases not studied by BLUEPRINT without Project approval, prior to the first major Project paper being published. The Project should not be listed as an author."
	        ),
	        React.createElement(
	            "h4",
	            null,
	            "Authors who use data from the project must acknowledge Blueprint using the following wording"
	        ),
	        React.createElement(
	            "p",
	            null,
	            "This study makes use of data generated by the Blueprint Consortium. A full list of the investigators who contributed to the generation of the data is available from",
	            React.createElement(
	                "a",
	                { href: "http://www.blueprint-epigenome.eu" },
	                "www.blueprint-epigenome.eu"
	            ),
	            ". Funding for the project was provided by the European Union's Seventh Framework Programme (FP7/2007-2013) under grant agreement no 282510 \u2013 BLUEPRINT."
	        )
	    )
	};

	var ZebrafishText = {
	    title: "Data Reuse statement",
	    content: React.createElement(
	        "div",
	        null,
	        React.createElement(
	            "p",
	            null,
	            "This is a pre-publication release in accordance with ",
	            React.createElement(
	                "a",
	                { href: "http://www.sanger.ac.uk/datasharing/" },
	                "the Fort Lauderdale Agreement "
	            ),
	            ". Feel free to search and download data on your genes of interest."
	        ),
	        React.createElement(
	            "p",
	            null,
	            "Equally, you can use the dataset to show developmental expression profiles for specific genes in your publications."
	        ),
	        React.createElement(
	            "p",
	            null,
	            "However, we ask that you refrain from publishing larger scale or genome-wide analyses of this dataset for 12 months from the time of deposition in Expression Atlas or until we have published our transcriptional time-course paper, whichever comes first."
	        ),
	        React.createElement(
	            "p",
	            null,
	            "For citations in publications before the paper is out please use this link to the Expression Atlas site (",
	            React.createElement(
	                "a",
	                { href: "https://www.ebi.ac.uk/gxa/experiments/E-ERAD-475" },
	                "http://www.ebi.ac.uk/gxa/experiments/E-ERAD-475"
	            ),
	            ") and acknowledge us: \u201CWe would like to thank the Busch-Nentwich lab for providing RNA-seq data.\u201D"
	        )
	    )
	};

	module.exports = { "fortLauderdale": BlueprintText, "zebrafish": ZebrafishText };

/***/ },
/* 701 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CommenceDownload = undefined;

	var _range2 = __webpack_require__(702);

	var _range3 = _interopRequireDefault(_range2);

	var _downloadjs = __webpack_require__(13);

	var _downloadjs2 = _interopRequireDefault(_downloadjs);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// TODO Units? there can be both FPKMs and sometimes TPMs

	var heatmapDataIntoLinesOfData = function heatmapDataIntoLinesOfData(heatmapData) {

	  var heatmapDataAsMatrix = (0, _range3.default)(heatmapData.yAxisCategories.length).map(function (y) {
	    return (0, _range3.default)(heatmapData.xAxisCategories.length).map(function (x) {
	      return 'NA';
	    });
	  });

	  heatmapData.dataSeries.forEach(function (series) {
	    series.data.forEach(function (point) {
	      heatmapDataAsMatrix[point.y][point.x] = point.value;
	    });
	  });

	  return [[''].concat(heatmapData.xAxisCategories.map(function (header) {
	    return header.label;
	  }))].concat(heatmapData.yAxisCategories.map(function (rowLabel, ix) {
	    return [].concat.apply([rowLabel.label], heatmapDataAsMatrix[ix]);
	  })).map(function (line) {
	    return line.join('\t');
	  });
	};

	var CommenceDownload = function CommenceDownload(args) {
	  (0, _downloadjs2.default)(new Blob(['# Downloaded from: ' + window.location.href, '# Timestamp: ' + new Date().toISOString()].concat(_toConsumableArray(args.descriptionLines.map(function (line) {
	    return '# ' + line;
	  })), _toConsumableArray(heatmapDataIntoLinesOfData(args.heatmapData))).map(function (line) {
	    return line + '\n';
	  })), args.name.replace(/ +/, '_') + '.tsv', 'text/tsv');
	};

	exports.CommenceDownload = CommenceDownload;

/***/ },
/* 702 */
/***/ function(module, exports, __webpack_require__) {

	var createRange = __webpack_require__(703);

	/**
	 * Creates an array of numbers (positive and/or negative) progressing from
	 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	 * `start` is specified without an `end` or `step`. If `end` is not specified,
	 * it's set to `start` with `start` then set to `0`.
	 *
	 * **Note:** JavaScript follows the IEEE-754 standard for resolving
	 * floating-point values which can produce unexpected results.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} [step=1] The value to increment or decrement by.
	 * @returns {Array} Returns the range of numbers.
	 * @see _.inRange, _.rangeRight
	 * @example
	 *
	 * _.range(4);
	 * // => [0, 1, 2, 3]
	 *
	 * _.range(-4);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 5);
	 * // => [1, 2, 3, 4]
	 *
	 * _.range(0, 20, 5);
	 * // => [0, 5, 10, 15]
	 *
	 * _.range(0, -4, -1);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 4, 0);
	 * // => [1, 1, 1]
	 *
	 * _.range(0);
	 * // => []
	 */
	var range = createRange();

	module.exports = range;


/***/ },
/* 703 */
/***/ function(module, exports, __webpack_require__) {

	var baseRange = __webpack_require__(704),
	    isIterateeCall = __webpack_require__(705),
	    toFinite = __webpack_require__(718);

	/**
	 * Creates a `_.range` or `_.rangeRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new range function.
	 */
	function createRange(fromRight) {
	  return function(start, end, step) {
	    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	      end = step = undefined;
	    }
	    // Ensure the sign of `-0` is preserved.
	    start = toFinite(start);
	    if (end === undefined) {
	      end = start;
	      start = 0;
	    } else {
	      end = toFinite(end);
	    }
	    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	    return baseRange(start, end, step, fromRight);
	  };
	}

	module.exports = createRange;


/***/ },
/* 704 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil = Math.ceil,
	    nativeMax = Math.max;

	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	      result = Array(length);

	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}

	module.exports = baseRange;


/***/ },
/* 705 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(706),
	    isArrayLike = __webpack_require__(707),
	    isIndex = __webpack_require__(717),
	    isObject = __webpack_require__(715);

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ },
/* 706 */
/***/ function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ },
/* 707 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(708),
	    isLength = __webpack_require__(716);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ },
/* 708 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(709),
	    isObject = __webpack_require__(715);

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	module.exports = isFunction;


/***/ },
/* 709 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(710),
	    getRawTag = __webpack_require__(713),
	    objectToString = __webpack_require__(714);

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  value = Object(value);
	  return (symToStringTag && symToStringTag in value)
	    ? getRawTag(value)
	    : objectToString(value);
	}

	module.exports = baseGetTag;


/***/ },
/* 710 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(711);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ },
/* 711 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(712);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ },
/* 712 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	module.exports = freeGlobal;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 713 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(710);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	module.exports = getRawTag;


/***/ },
/* 714 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ },
/* 715 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ },
/* 716 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ },
/* 717 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ },
/* 718 */
/***/ function(module, exports, __webpack_require__) {

	var toNumber = __webpack_require__(719);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	module.exports = toFinite;


/***/ },
/* 719 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(715),
	    isSymbol = __webpack_require__(720);

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	module.exports = toNumber;


/***/ },
/* 720 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(709),
	    isObjectLike = __webpack_require__(721);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ },
/* 721 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ },
/* 722 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(139);
	var ReactHighcharts = __webpack_require__(605);
	var Highcharts = ReactHighcharts.Highcharts;
	__webpack_require__(17)(Highcharts);

	__webpack_require__(16)(Highcharts);
	// Overrides default Custom Events behaviour
	window.oncontextmenu = function () {
	    return true;
	};

	var hash = __webpack_require__(20);

	var PropTypes = __webpack_require__(697);

	//*------------------------------------------------------------------*

	var HeatmapCanvas = React.createClass({
	    displayName: 'HeatmapCanvas',

	    propTypes: {
	        marginRight: React.PropTypes.number.isRequired,
	        ontologyIdsToHighlight: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	        heatmapData: PropTypes.HeatmapData,
	        colorAxis: React.PropTypes.object,
	        formatters: React.PropTypes.shape({
	            xAxis: PropTypes.Formatter,
	            xAxisStyle: React.PropTypes.object.isRequired,
	            yAxis: PropTypes.Formatter,
	            yAxisStyle: React.PropTypes.object.isRequired,
	            tooltip: PropTypes.Formatter
	        }).isRequired,
	        genomeBrowserTemplate: React.PropTypes.string.isRequired,
	        onUserSelectsRow: React.PropTypes.func.isRequired,
	        onUserSelectsColumn: React.PropTypes.func.isRequired,
	        onUserSelectsPoint: React.PropTypes.func.isRequired,
	        onUserClicksColumn: React.PropTypes.func,
	        onZoom: React.PropTypes.func.isRequired
	    },

	    shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
	        return hash.MD5(nextProps.heatmapData) !== hash.MD5(this.props.heatmapData);
	    },

	    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	        var chart = this.refs.chart.getChart();
	        var forEachXNotInYsEmit = function forEachXNotInYsEmit(xs, ys, eventName) {
	            xs.filter(function (id) {
	                return ys.indexOf(id) == -1;
	            }).filter(function uniq(id, ix, self) {
	                return ix == self.indexOf(id);
	            }).forEach(function (id) {
	                Highcharts.fireEvent(chart, eventName, { svgPathId: id });
	            }.bind(this));
	        };
	        forEachXNotInYsEmit(nextProps.ontologyIdsToHighlight, this.props.ontologyIdsToHighlight, 'handleGxaAnatomogramTissueMouseEnter');
	        forEachXNotInYsEmit(this.props.ontologyIdsToHighlight, nextProps.ontologyIdsToHighlight, 'handleGxaAnatomogramTissueMouseLeave');
	    },

	    render: function render() {
	        var xAxisLongestHeaderLength = Math.max.apply(null, this.props.heatmapData.xAxisCategories.map(function (category) {
	            return category.label.length;
	        }));
	        var marginTop = this.props.heatmapData.xAxisCategories.length < 10 ? 30 : // labels aren’t tilted
	        this.props.heatmapData.xAxisCategories.length < 50 ? Math.min(150, Math.round(xAxisLongestHeaderLength * 3.75)) : // labels at -45°
	        Math.min(250, Math.round(xAxisLongestHeaderLength * 5.5)); // labels at -90°

	        var dimensions = {
	            marginTop: marginTop,
	            marginRight: //leave space for tilted long headers
	            //TODO the marginRight value of props used to be the same here and in top legend.
	            //Probably it's time to get rid of this prop.
	            this.props.marginRight * (1 + 10 / Math.pow(1 + this._countColumnsToShow(), 2)),
	            height: Math.max(70, this._countRowsToShow() * 30 + marginTop)
	        };

	        var maxWidthFraction = 1 - Math.exp(-(0.2 + 0.05 * Math.pow(this._countColumnsToShow() + 1, 2)));
	        return React.createElement(
	            'div',
	            { style: { maxWidth: maxWidthFraction * 100 + "%" } },
	            React.createElement(ReactHighcharts, {
	                config: this._highchartsOptions(dimensions, this.props.heatmapData),
	                ref: 'chart' })
	        );
	    },
	    _count_sToShow: function _count_sToShow(xOrY) {
	        return [].concat.apply([], this.props.heatmapData.dataSeries.map(function (el) {
	            return el.data;
	        })).map(function (el) {
	            return el[xOrY];
	        }).sort(function (l, r) {
	            return l - r;
	        }).filter(function (el, ix, self) {
	            return self.indexOf(el) == ix;
	        }).length;
	    },

	    _countRowsToShow: function _countRowsToShow() {
	        return this._count_sToShow("y");
	    },

	    _countColumnsToShow: function _countColumnsToShow() {
	        //we have turned the min and max on to show empty columns in heatmap
	        return this.props.heatmapData.xAxisCategories.length;
	    },

	    _highchartsOptions: function _highchartsOptions(dimensions, data) {
	        var _this = this;

	        return {
	            plotOptions: {
	                heatmap: {
	                    turboThreshold: 0
	                },
	                series: {
	                    cursor: !!this.props.genomeBrowserTemplate ? "pointer" : undefined,
	                    point: {
	                        events: {
	                            mouseOver: function () {
	                                var f = this.props.onUserSelectsPoint;
	                                return function () {
	                                    return f(this.options.info.xId || this.series.xAxis.categories[this.x].id, this.series.yAxis.categories[this.y].id);
	                                };
	                            }.bind(this)(),
	                            mouseOut: function () {
	                                var f = this.props.onUserSelectsColumn;
	                                return function () {
	                                    return f("", "");
	                                };
	                            }.bind(this)(),
	                            click: !this.props.genomeBrowserTemplate ? function () {} : function () {
	                                var x = this.series.xAxis.categories[this.x].info.trackId;
	                                var y = this.series.yAxis.categories[this.y].info.trackId;
	                                window.open(this.series.chart.userOptions.genomeBrowserTemplate.replace(/__x__/g, x).replace(/__y__/g, y), "_blank");
	                            }
	                        }
	                    },

	                    states: {
	                        hover: {
	                            color: '#eeec38' //#edab12 color cell on mouse over
	                        },
	                        select: {
	                            color: '#eeec38'
	                        }
	                    }
	                }
	            },
	            credits: {
	                enabled: false //remove Highcharts text in the bottom right corner
	            },
	            chart: Object.assign({
	                type: 'heatmap',
	                spacingTop: 0,
	                plotBorderWidth: 1,
	                zoomType: 'x',
	                events: {
	                    handleGxaAnatomogramTissueMouseEnter: function handleGxaAnatomogramTissueMouseEnter(e) {
	                        Highcharts.each(this.series, function (series) {
	                            Highcharts.each(series.points, function (point) {
	                                if (point.series.xAxis.categories[point.x].id === e.svgPathId) {
	                                    point.select(true, true);
	                                }
	                            });
	                        });
	                    },
	                    handleGxaAnatomogramTissueMouseLeave: function handleGxaAnatomogramTissueMouseLeave(e) {
	                        var points = this.getSelectedPoints();
	                        if (points.length > 0) {
	                            Highcharts.each(points, function (point) {
	                                point.select(false);
	                            });
	                        }
	                    }
	                }
	            }, dimensions),
	            legend: {
	                enabled: false
	            },
	            title: null,
	            colorAxis: this.props.colorAxis || undefined,
	            xAxis: { //assays
	                tickLength: 5,
	                tickColor: 'rgb(192, 192, 192)',
	                lineColor: 'rgb(192, 192, 192)',
	                labels: {
	                    style: this.props.formatters.xAxisStyle,
	                    events: {
	                        mouseover: function () {
	                            var f = _this.props.onUserSelectsColumn;
	                            return function () {
	                                return f && f(this.value);
	                            };
	                        }(),
	                        mouseout: function () {
	                            var f = _this.props.onUserSelectsColumn;
	                            return function () {
	                                return f && f("");
	                            };
	                        }(),
	                        click: function () {
	                            var f = _this.props.onUserClicksColumn;
	                            return function () {
	                                return f && f(this.value);
	                            };
	                        }()
	                    },
	                    autoRotation: [-45, -90],
	                    formatter: function () {
	                        var f = this.props.formatters.xAxis;return function () {
	                            return f(this.value);
	                        };
	                    }.bind(this)()
	                },

	                opposite: 'true',
	                categories: data.xAxisCategories,
	                min: 0,
	                max: data.xAxisCategories.length - 1,

	                events: {
	                    setExtremes: function (event) {
	                        this.props.onZoom(event.min !== undefined && event.max !== undefined);
	                    }.bind(this)
	                }
	            },
	            yAxis: { //experiments or bioentities
	                useHTML: true,
	                reversed: true,
	                labels: {
	                    style: this.props.formatters.yAxisStyle,
	                    events: {
	                        mouseover: function () {
	                            var f = this.props.onUserSelectsRow;
	                            return function () {
	                                return f( //We assume the longest text is the callback we want
	                                [].concat.apply([], [].concat.apply([], this.element.children).filter(function (c) {
	                                    return !c.style || c.style.fill != "black";
	                                }) //skip design elements
	                                ).map(function (c) {
	                                    return c.textContent;
	                                }).reduce(function (l, r) {
	                                    return l.length > r.length ? l : r;
	                                }, ""));
	                            };
	                        }.bind(this)(),
	                        mouseout: function () {
	                            var f = this.props.onUserSelectsRow;return function () {
	                                return f("");
	                            };
	                        }.bind(this)()
	                    },
	                    formatter: function () {
	                        var f = this.props.formatters.yAxis;return function () {
	                            return f(this.value);
	                        };
	                    }.bind(this)()
	                },

	                categories: data.yAxisCategories,
	                title: null,
	                gridLineWidth: 0,
	                minorGridLineWidth: 0,
	                endOnTick: false
	            },
	            tooltip: {
	                useHTML: true,
	                formatter: function () {
	                    var f = this.props.formatters.tooltip;return function () {
	                        return f(this.series, this.point);
	                    };
	                }.bind(this)()
	            },

	            genomeBrowserTemplate: this.props.genomeBrowserTemplate,
	            series: data.dataSeries.map(function (e) {
	                return {
	                    name: e.info.name,
	                    color: e.info.colour,
	                    borderWidth: data.xAxisCategories.length > 200 ? 0 : 1,
	                    borderColor: "white",
	                    data: e.data
	                };
	            })
	        };
	    }
	});

	module.exports = HeatmapCanvas;

/***/ },
/* 723 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(139);
	var Dropdown = __webpack_require__(423);
	var MenuItem = __webpack_require__(536);
	var Glyphicon = __webpack_require__(396);
	var PropTypes = __webpack_require__(697);

	var OrderingsDropdown = React.createClass({
	    displayName: "OrderingsDropdown",

	    propTypes: {
	        orderings: PropTypes.Orderings,
	        disabled: React.PropTypes.bool.isRequired
	    },

	    handleChange: function handleChange(eventKey, event) {
	        this.props.orderings.onSelect(event.target.text);
	        event.preventDefault();
	    },
	    _orderingIcon: function _orderingIcon(ordering) {
	        switch (ordering) {
	            case "Alphabetical order":
	                return "sort-by-alphabet";
	            case "Gene expression rank":
	                return "sort-by-attributes-alt";
	            case "Default":
	                return "sort-by-order";
	            default:
	                return "sort-by-order";
	        }
	    },
	    render: function render() {
	        return React.createElement(
	            "span",
	            null,
	            React.createElement(
	                Dropdown,
	                { id: "orderings-dropdown", onSelect: this.handleChange, title: this.props.disabled ? "Reset zoom to enable sorting options" : "" },
	                React.createElement(
	                    Dropdown.Toggle,
	                    { bsSize: "small", disabled: this.props.disabled,
	                        style: { textTransform: "unset", letterSpacing: "unset", height: "unset" } },
	                    React.createElement(Glyphicon, { glyph: this._orderingIcon(this.props.orderings.selected) }),
	                    " ",
	                    this.props.orderings.selected
	                ),
	                React.createElement(
	                    Dropdown.Menu,
	                    { bsSize: "small" },
	                    this.props.orderings.available.map(function (orderingName) {
	                        return React.createElement(
	                            MenuItem,
	                            { style: { listStyleImage: "none" }, key: orderingName, href: "#" },
	                            orderingName
	                        );
	                    })
	                )
	            )
	        );
	    }
	});

	module.exports = OrderingsDropdown;

/***/ },
/* 724 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var React = __webpack_require__(139);
	var Modal = __webpack_require__(537);
	var Button = __webpack_require__(390);
	var Glyphicon = __webpack_require__(396);

	var PropTypes = __webpack_require__(697);
	var FlatFilter = __webpack_require__(725);
	var GroupedFilter = __webpack_require__(794);

	var SettingsModal = React.createClass({
	    displayName: "SettingsModal",

	    propTypes: {
	        filters: React.PropTypes.arrayOf(PropTypes.Filter).isRequired,
	        disabled: React.PropTypes.bool.isRequired,
	        propagateChosenFilterSelection: React.PropTypes.func.isRequired
	    },

	    _filtersSelectionBeforeModalOpen: function _filtersSelectionBeforeModalOpen() {
	        return this.props.filters.map(function (_filter) {
	            return {
	                name: _filter.name,
	                selected: _filter.selected
	            };
	        });
	    },
	    getInitialState: function getInitialState() {
	        return {
	            filtersSelection: this._filtersSelectionBeforeModalOpen(),
	            showModal: false
	        };
	    },
	    _close: function _close() {
	        this.setState({
	            showModal: false
	        });
	    },
	    _apply: function _apply() {
	        this.props.propagateChosenFilterSelection(this.state.filtersSelection);
	        this.setState({ showModal: false });
	    },
	    _open: function _open() {
	        this.setState({ showModal: true,
	            filtersSelection: this._filtersSelectionBeforeModalOpen() });
	    },
	    _renderFilter: function _renderFilter(_filter) {
	        var _this = this;

	        var FilterComponent = _filter.valueGroupings ? GroupedFilter : FlatFilter;

	        return React.createElement(FilterComponent, _extends({
	            key: _filter.name,
	            propagateFilterSelection: function propagateFilterSelection(selected) {
	                _this.setState(function (previousState) {
	                    return {
	                        filtersSelection: previousState.filtersSelection.map(function (filterSelection) {
	                            return filterSelection.name == _filter.name ? Object.assign({}, filterSelection, { selected: selected }) : filterSelection;
	                        })
	                    };
	                });
	            },
	            disabled: this.props.disabled
	        }, _filter));
	    },
	    _filtersCorrespondingToCurrentSelection: function _filtersCorrespondingToCurrentSelection() {
	        var _this2 = this;

	        return this.props.filters.map(function (_filter) {
	            return Object.assign({}, _filter, { selected: _this2.state.filtersSelection.find(function (f) {
	                    return f.name == _filter.name;
	                }).selected
	            });
	        });
	    },
	    render: function render() {
	        return React.createElement(
	            "div",
	            null,
	            React.createElement(
	                Button,
	                { bsSize: "small", onClick: this._open, disabled: this.props.disabled, title: this.props.disabled ? "Reset zoom to enable filters" : "",
	                    style: { textTransform: "unset", letterSpacing: "unset", height: "unset" } },
	                React.createElement(Glyphicon, { glyph: "equalizer" }),
	                React.createElement(
	                    "span",
	                    { style: { verticalAlign: "middle" } },
	                    " Filters"
	                )
	            ),
	            React.createElement(
	                Modal,
	                { show: this.state.showModal, onHide: this._close, bsSize: "large" },
	                React.createElement(
	                    Modal.Header,
	                    { closeButton: true },
	                    React.createElement(
	                        Modal.Title,
	                        null,
	                        "Filters"
	                    )
	                ),
	                React.createElement(
	                    Modal.Body,
	                    null,
	                    this._filtersCorrespondingToCurrentSelection().map(this._renderFilter)
	                ),
	                React.createElement(
	                    Modal.Footer,
	                    null,
	                    React.createElement(
	                        Button,
	                        { bsStyle: "primary", onClick: this._apply,
	                            style: { textTransform: "unset", letterSpacing: "unset", height: "unset" } },
	                        "Apply"
	                    ),
	                    React.createElement(
	                        Button,
	                        { onClick: this._close,
	                            style: { textTransform: "unset", letterSpacing: "unset", height: "unset" } },
	                        "Close"
	                    )
	                )
	            )
	        );
	    }
	});

	module.exports = SettingsModal;

/***/ },
/* 725 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(139);
	var PropTypes = __webpack_require__(697);
	var xor = __webpack_require__(726);

	__webpack_require__(792);

	var FlatFilter = React.createClass({
	  displayName: "FlatFilter",

	  propTypes: Object.assign({}, PropTypes.FilterProps, {
	    propagateFilterSelection: React.PropTypes.func.isRequired,
	    disabled: React.PropTypes.bool.isRequired
	  }),

	  toggleOne: function toggleOne(which, evt) {
	    this.props.propagateFilterSelection(xor(this.props.selected, [which]));
	  },
	  render: function render() {
	    var _this = this;

	    return React.createElement(
	      "div",
	      { className: "gxaFilter" },
	      React.createElement(
	        "h4",
	        null,
	        this.props.name
	      ),
	      React.createElement(
	        "div",
	        { className: "filterBody" },
	        React.createElement(
	          "div",
	          null,
	          this.props.values.map(function (value) {
	            return React.createElement(
	              "div",
	              { key: value },
	              React.createElement("input", { type: "checkbox",
	                value: value,
	                onChange: function onChange(evt) {
	                  return _this.toggleOne(value, evt);
	                },
	                disabled: _this.props.selectDisabled,
	                checked: _this.props.selected.indexOf(value) > -1 }),
	              value
	            );
	          })
	        )
	      )
	    );
	  }
	});
	module.exports = FlatFilter;

/***/ },
/* 726 */
/***/ function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(727),
	    baseRest = __webpack_require__(728),
	    baseXor = __webpack_require__(743),
	    isArrayLikeObject = __webpack_require__(791);

	/**
	 * Creates an array of unique values that is the
	 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	 * of the given arrays. The order of result values is determined by the order
	 * they occur in the arrays.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @returns {Array} Returns the new array of filtered values.
	 * @see _.difference, _.without
	 * @example
	 *
	 * _.xor([2, 1], [2, 3]);
	 * // => [1, 3]
	 */
	var xor = baseRest(function(arrays) {
	  return baseXor(arrayFilter(arrays, isArrayLikeObject));
	});

	module.exports = xor;


/***/ },
/* 727 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	module.exports = arrayFilter;


/***/ },
/* 728 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(729),
	    overRest = __webpack_require__(730),
	    setToString = __webpack_require__(732);

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	module.exports = baseRest;


/***/ },
/* 729 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ },
/* 730 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(731);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = overRest;


/***/ },
/* 731 */
/***/ function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ },
/* 732 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(733),
	    shortOut = __webpack_require__(742);

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	module.exports = setToString;


/***/ },
/* 733 */
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(734),
	    defineProperty = __webpack_require__(735),
	    identity = __webpack_require__(729);

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	module.exports = baseSetToString;


/***/ },
/* 734 */
/***/ function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	module.exports = constant;


/***/ },
/* 735 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(736);

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	module.exports = defineProperty;


/***/ },
/* 736 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(737),
	    getValue = __webpack_require__(741);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	module.exports = getNative;


/***/ },
/* 737 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(708),
	    isMasked = __webpack_require__(738),
	    isObject = __webpack_require__(715),
	    toSource = __webpack_require__(740);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	module.exports = baseIsNative;


/***/ },
/* 738 */
/***/ function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(739);

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	module.exports = isMasked;


/***/ },
/* 739 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(711);

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	module.exports = coreJsData;


/***/ },
/* 740 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	module.exports = toSource;


/***/ },
/* 741 */
/***/ function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	module.exports = getValue;


/***/ },
/* 742 */
/***/ function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	module.exports = shortOut;


/***/ },
/* 743 */
/***/ function(module, exports, __webpack_require__) {

	var baseDifference = __webpack_require__(744),
	    baseFlatten = __webpack_require__(780),
	    baseUniq = __webpack_require__(786);

	/**
	 * The base implementation of methods like `_.xor`, without support for
	 * iteratee shorthands, that accepts an array of arrays to inspect.
	 *
	 * @private
	 * @param {Array} arrays The arrays to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of values.
	 */
	function baseXor(arrays, iteratee, comparator) {
	  var length = arrays.length;
	  if (length < 2) {
	    return length ? baseUniq(arrays[0]) : [];
	  }
	  var index = -1,
	      result = Array(length);

	  while (++index < length) {
	    var array = arrays[index],
	        othIndex = -1;

	    while (++othIndex < length) {
	      if (othIndex != index) {
	        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	      }
	    }
	  }
	  return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	}

	module.exports = baseXor;


/***/ },
/* 744 */
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(745),
	    arrayIncludes = __webpack_require__(771),
	    arrayIncludesWith = __webpack_require__(776),
	    arrayMap = __webpack_require__(777),
	    baseUnary = __webpack_require__(778),
	    cacheHas = __webpack_require__(779);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of methods like `_.difference` without support
	 * for excluding multiple arrays or iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Array} values The values to exclude.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 */
	function baseDifference(array, values, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      isCommon = true,
	      length = array.length,
	      result = [],
	      valuesLength = values.length;

	  if (!length) {
	    return result;
	  }
	  if (iteratee) {
	    values = arrayMap(values, baseUnary(iteratee));
	  }
	  if (comparator) {
	    includes = arrayIncludesWith;
	    isCommon = false;
	  }
	  else if (values.length >= LARGE_ARRAY_SIZE) {
	    includes = cacheHas;
	    isCommon = false;
	    values = new SetCache(values);
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee == null ? value : iteratee(value);

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var valuesIndex = valuesLength;
	      while (valuesIndex--) {
	        if (values[valuesIndex] === computed) {
	          continue outer;
	        }
	      }
	      result.push(value);
	    }
	    else if (!includes(values, computed, comparator)) {
	      result.push(value);
	    }
	  }
	  return result;
	}

	module.exports = baseDifference;


/***/ },
/* 745 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(746),
	    setCacheAdd = __webpack_require__(769),
	    setCacheHas = __webpack_require__(770);

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	module.exports = SetCache;


/***/ },
/* 746 */
/***/ function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(747),
	    mapCacheDelete = __webpack_require__(763),
	    mapCacheGet = __webpack_require__(766),
	    mapCacheHas = __webpack_require__(767),
	    mapCacheSet = __webpack_require__(768);

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	module.exports = MapCache;


/***/ },
/* 747 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(748),
	    ListCache = __webpack_require__(755),
	    Map = __webpack_require__(762);

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	module.exports = mapCacheClear;


/***/ },
/* 748 */
/***/ function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(749),
	    hashDelete = __webpack_require__(751),
	    hashGet = __webpack_require__(752),
	    hashHas = __webpack_require__(753),
	    hashSet = __webpack_require__(754);

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	module.exports = Hash;


/***/ },
/* 749 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(750);

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	module.exports = hashClear;


/***/ },
/* 750 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(736);

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	module.exports = nativeCreate;


/***/ },
/* 751 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = hashDelete;


/***/ },
/* 752 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(750);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	module.exports = hashGet;


/***/ },
/* 753 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(750);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	module.exports = hashHas;


/***/ },
/* 754 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(750);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	module.exports = hashSet;


/***/ },
/* 755 */
/***/ function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(756),
	    listCacheDelete = __webpack_require__(757),
	    listCacheGet = __webpack_require__(759),
	    listCacheHas = __webpack_require__(760),
	    listCacheSet = __webpack_require__(761);

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	module.exports = ListCache;


/***/ },
/* 756 */
/***/ function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	module.exports = listCacheClear;


/***/ },
/* 757 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(758);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	module.exports = listCacheDelete;


/***/ },
/* 758 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(706);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ },
/* 759 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(758);

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	module.exports = listCacheGet;


/***/ },
/* 760 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(758);

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	module.exports = listCacheHas;


/***/ },
/* 761 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(758);

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	module.exports = listCacheSet;


/***/ },
/* 762 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(736),
	    root = __webpack_require__(711);

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	module.exports = Map;


/***/ },
/* 763 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(764);

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = mapCacheDelete;


/***/ },
/* 764 */
/***/ function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(765);

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	module.exports = getMapData;


/***/ },
/* 765 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	module.exports = isKeyable;


/***/ },
/* 766 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(764);

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	module.exports = mapCacheGet;


/***/ },
/* 767 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(764);

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	module.exports = mapCacheHas;


/***/ },
/* 768 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(764);

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	module.exports = mapCacheSet;


/***/ },
/* 769 */
/***/ function(module, exports) {

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	module.exports = setCacheAdd;


/***/ },
/* 770 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	module.exports = setCacheHas;


/***/ },
/* 771 */
/***/ function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(772);

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	module.exports = arrayIncludes;


/***/ },
/* 772 */
/***/ function(module, exports, __webpack_require__) {

	var baseFindIndex = __webpack_require__(773),
	    baseIsNaN = __webpack_require__(774),
	    strictIndexOf = __webpack_require__(775);

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}

	module.exports = baseIndexOf;


/***/ },
/* 773 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = baseFindIndex;


/***/ },
/* 774 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	module.exports = baseIsNaN;


/***/ },
/* 775 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = strictIndexOf;


/***/ },
/* 776 */
/***/ function(module, exports) {

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arrayIncludesWith;


/***/ },
/* 777 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ },
/* 778 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	module.exports = baseUnary;


/***/ },
/* 779 */
/***/ function(module, exports) {

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	module.exports = cacheHas;


/***/ },
/* 780 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(781),
	    isFlattenable = __webpack_require__(782);

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	module.exports = baseFlatten;


/***/ },
/* 781 */
/***/ function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ },
/* 782 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(710),
	    isArguments = __webpack_require__(783),
	    isArray = __webpack_require__(785);

	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	module.exports = isFlattenable;


/***/ },
/* 783 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(784),
	    isObjectLike = __webpack_require__(721);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	module.exports = isArguments;


/***/ },
/* 784 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(709),
	    isObjectLike = __webpack_require__(721);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	module.exports = baseIsArguments;


/***/ },
/* 785 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ },
/* 786 */
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(745),
	    arrayIncludes = __webpack_require__(771),
	    arrayIncludesWith = __webpack_require__(776),
	    cacheHas = __webpack_require__(779),
	    createSet = __webpack_require__(787),
	    setToArray = __webpack_require__(790);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : createSet(array);
	    if (set) {
	      return setToArray(set);
	    }
	    isCommon = false;
	    includes = cacheHas;
	    seen = new SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	module.exports = baseUniq;


/***/ },
/* 787 */
/***/ function(module, exports, __webpack_require__) {

	var Set = __webpack_require__(788),
	    noop = __webpack_require__(789),
	    setToArray = __webpack_require__(790);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	  return new Set(values);
	};

	module.exports = createSet;


/***/ },
/* 788 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(736),
	    root = __webpack_require__(711);

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	module.exports = Set;


/***/ },
/* 789 */
/***/ function(module, exports) {

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	module.exports = noop;


/***/ },
/* 790 */
/***/ function(module, exports) {

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	module.exports = setToArray;


/***/ },
/* 791 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(707),
	    isObjectLike = __webpack_require__(721);

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	module.exports = isArrayLikeObject;


/***/ },
/* 792 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(793);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(672)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/less-loader/index.js!./Components.less", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./../../../node_modules/less-loader/index.js!./Components.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 793 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(671)();
	// imports


	// module
	exports.push([module.id, ".gxaFilter .filterBody input {\n  margin: 0.2rem;\n}\n.gxaFilter .filterBody .groupName {\n  display: inline-block;\n  cursor: pointer;\n}\n.gxaFilter .filterBody .groupName:hover {\n  text-decoration: underline;\n}\n.gxaFilter .filterBody .options {\n  padding-left: 15px;\n  font-size: 85%;\n  -webkit-column-width: 180px;\n  -moz-column-width: 180px;\n  column-width: 180px;\n}\n", ""]);

	// exports


/***/ },
/* 794 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(139);
	var Button = __webpack_require__(390);
	var Glyphicon = __webpack_require__(396);
	var PropTypes = __webpack_require__(697);
	var xor = __webpack_require__(726);
	__webpack_require__(792);

	var FilterOption = React.createClass({
	  displayName: "FilterOption",

	  propTypes: {
	    name: React.PropTypes.string.isRequired,
	    values: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	    selected: React.PropTypes.arrayOf(React.PropTypes.string).isRequired,
	    isOpen: React.PropTypes.bool.isRequired,
	    selectDisabled: React.PropTypes.bool.isRequired,
	    closeDisabled: React.PropTypes.bool.isRequired,
	    onToggleOpen: React.PropTypes.func.isRequired,
	    onNewSelected: React.PropTypes.func.isRequired
	  },

	  toggleAll: function toggleAll(evt) {
	    this.props.onNewSelected(xor(this.props.values, this.props.selected).length ? this.props.values : []);
	  },
	  toggleOne: function toggleOne(which, evt) {
	    this.props.onNewSelected(xor(this.props.selected, [which]));
	  },
	  toggleOpen: function toggleOpen(evt) {
	    this.props.onToggleOpen();
	  },
	  render: function render() {
	    var _this = this;

	    return React.createElement(
	      "div",
	      { className: "filterBody" },
	      React.createElement("input", { type: "checkbox",
	        value: this.props.name,
	        onChange: this.toggleAll,
	        disabled: this.props.selectDisabled,
	        checked: this.props.values.every(function (v) {
	          return _this.props.selected.indexOf(v) > -1;
	        }) }),
	      React.createElement(
	        "div",
	        { className: "groupName",
	          onClick: this.props.closeDisabled ? function () {} : this.toggleOpen,
	          href: "#" },
	        this.props.name,
	        !this.props.closeDisabled && React.createElement(Glyphicon, { style: { fontSize: "x-small", paddingLeft: "5px" }, glyph: this.props.isOpen ? "menu-up" : "menu-down" })
	      ),
	      this.props.isOpen && React.createElement(
	        "div",
	        { className: "options" },
	        this.props.values.map(function (value) {
	          return React.createElement(
	            "div",
	            { className: "option", key: value },
	            React.createElement("input", { type: "checkbox",
	              value: value,
	              onChange: function onChange(evt) {
	                return _this.toggleOne(value, evt);
	              },
	              disabled: _this.props.selectDisabled,
	              checked: _this.props.selected.indexOf(value) > -1 }),
	            React.createElement(
	              "span",
	              null,
	              " ",
	              value
	            )
	          );
	        })
	      )
	    );
	  }
	});

	var GroupedFilter = React.createClass({
	  displayName: "GroupedFilter",

	  propTypes: Object.assign({}, PropTypes.FilterProps, {
	    propagateFilterSelection: React.PropTypes.func.isRequired,
	    disabled: React.PropTypes.bool.isRequired
	  }),

	  getInitialState: function getInitialState() {
	    return {
	      groupsUserAskedToKeepOpen: []
	    };
	  },
	  renderValueGrouping: function renderValueGrouping(name, values) {
	    var _this2 = this;

	    var userWantedOpen = this.state.groupsUserAskedToKeepOpen.indexOf(name) > -1;
	    var selectedHere = this.props.selected.filter(function (e) {
	      return values.indexOf(e) > -1;
	    });
	    var selectedNotHere = this.props.selected.filter(function (e) {
	      return values.indexOf(e) == -1;
	    });
	    var impliedOpen = !(selectedHere.length == 0 || values.every(function (v) {
	      return selectedHere.indexOf(v) > -1;
	    }));
	    return React.createElement(FilterOption, { key: name,
	      name: name,
	      values: values,
	      selected: selectedHere,
	      isOpen: userWantedOpen || impliedOpen,
	      selectDisabled: this.props.disabled,
	      closeDisabled: impliedOpen,
	      onToggleOpen: function onToggleOpen() {
	        _this2.setState(function (previousState) {
	          return { groupsUserAskedToKeepOpen: xor(previousState.groupsUserAskedToKeepOpen, [name]) };
	        });
	      },
	      onNewSelected: function onNewSelected(selectedInThisOption) {
	        _this2.props.propagateFilterSelection(selectedNotHere.concat(selectedInThisOption));
	      } });
	  },
	  render: function render() {
	    var _this3 = this;

	    return React.createElement(
	      "div",
	      { className: "gxaFilter" },
	      React.createElement(
	        "h4",
	        null,
	        this.props.name
	      ),
	      React.createElement(
	        Button,
	        { bsSize: "xsmall", onClick: function onClick() {
	            _this3.props.propagateFilterSelection(_this3.props.values);
	          },
	          style: { textTransform: "unset", letterSpacing: "unset", height: "unset" } },
	        React.createElement(Glyphicon, { glyph: "plus" }),
	        React.createElement(
	          "span",
	          { style: { verticalAlign: "middle" } },
	          " Choose all"
	        )
	      ),
	      React.createElement(
	        Button,
	        { bsSize: "xsmall", onClick: function onClick() {
	            _this3.props.propagateFilterSelection([]);
	          },
	          style: { textTransform: "unset", letterSpacing: "unset", height: "unset" } },
	        React.createElement(Glyphicon, { glyph: "minus" }),
	        React.createElement(
	          "span",
	          { style: { verticalAlign: "middle" } },
	          " Remove all"
	        )
	      ),
	      this.props.valueGroupings.map(function (a) {
	        return _this3.renderValueGrouping(a[0], a[1]);
	      })
	    );
	  }
	});
	module.exports = GroupedFilter;

/***/ },
/* 795 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	This class is a wrapper around react-tooltip that lets us have one big tooltip.
	The tooltip gets hidden when you hover off, and changes content when you change what you hover on.
	Hack 1:
	I wanted the component to store the tooltip content, and then pass it as a child to react-tooltip.
	This didn't really work because I also need to put display:none on the tooltip when we hover off, not just an empty white tooltip.
	Hack 2:
	Additionally we use the freeze feature of react-tooltip- passed inside through props- and want to unfreeze after click outside.
	But that unfreeze also fired on clicking the column that turned freeze on in the first place, hence counting clicks.
	*/
	//*------------------------------------------------------------------*

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var React = __webpack_require__(139);
	var ReactTooltip = __webpack_require__(796);
	__webpack_require__(807);
	//*------------------------------------------------------------------*

	var TooltipStateManager = React.createClass({
	  displayName: 'TooltipStateManager',

	  propTypes: {
	    onUserSelectsRow: React.PropTypes.func.isRequired,
	    onUserSelectsColumn: React.PropTypes.func.isRequired,
	    onUserSelectsPoint: React.PropTypes.func.isRequired,
	    tooltips: React.PropTypes.shape({
	      row: React.PropTypes.func,
	      column: React.PropTypes.func,
	      point: React.PropTypes.func
	    }).isRequired,
	    managedComponent: React.PropTypes.any.isRequired,
	    managedComponentProps: React.PropTypes.object.isRequired,
	    enableFreeze: React.PropTypes.bool.isRequired
	  },

	  getInitialState: function getInitialState() {
	    return {
	      tooltipFrozen: false,
	      clickCount: 0
	    };
	  },

	  _onUserSelectsRow: function _onUserSelectsRow(rowLabel) {
	    if (this.state.tooltipFrozen) return;
	    this.refs["tooltip"].setState(rowLabel ? { placeholder: this.props.tooltips.row(rowLabel),
	      place: "right",
	      extraClass: "gxaGlobalTooltipContent" } : { extraClass: "gxaDisabled" });
	    this.props.onUserSelectsRow(rowLabel);
	  },
	  _onUserSelectsColumn: function _onUserSelectsColumn(columnLabel) {
	    if (this.state.tooltipFrozen) return;
	    this.refs["tooltip"].setState(columnLabel ? { placeholder: this.props.tooltips.column(columnLabel),
	      place: "bottom",
	      extraClass: "gxaGlobalTooltipContent" } : { extraClass: "gxaDisabled" });
	    this.props.onUserSelectsColumn(columnLabel);
	  },
	  _onUserSelectsPoint: function _onUserSelectsPoint(__args__) {
	    /*
	    //We let Highcharts manage the point formatter for now since we're not disappointed.
	    this.refs["tooltip"].setState(
	      hoveredPoint
	      ? {placeholder: this.props.tooltips.point(hoveredPoint),
	        extraClass:"gxaGlobalTooltipContent"}
	      : {extraClass:"gxaDisabled"}
	    );
	    */
	    this.props.onUserSelectsPoint.apply({}, arguments);
	  },

	  _dismissTooltip: function _dismissTooltip() {
	    if (this.state.clickCount > 0) {
	      this.setState({ tooltipFrozen: false, clickCount: 0 });
	      this.refs["tooltip"].setState({ extraClass: "gxaDisabled" });
	    }
	    this.setState(function (previousState) {
	      return { clickCount: previousState.clickCount + 1 };
	    });
	  },

	  _onUserClicksColumn: function _onUserClicksColumn(columnLabel) {
	    if (this.props.enableFreeze) {
	      this.setState(function (previousState) {
	        return { tooltipFrozen: !previousState.tooltipFrozen, clickCount: 0 };
	      });
	    }
	    this._onUserSelectsColumn(columnLabel);
	  },

	  render: function render() {
	    var ManagedComponent = this.props.managedComponent;
	    return React.createElement(
	      'div',
	      null,
	      React.createElement(
	        'div',
	        _extends({
	          'data-tip': true,
	          'data-for': 'gxaGlobalTooltipOverManagedComponent'
	        }, this.state.tooltipFrozen ? {
	          className: "gxaFadeBackgroundForOpenTooltip"
	        } : {}),
	        React.createElement(ManagedComponent, Object.assign({}, this.props.managedComponentProps, { onUserSelectsRow: this._onUserSelectsRow,
	          onUserSelectsColumn: this._onUserSelectsColumn,
	          onUserSelectsPoint: this._onUserSelectsPoint,
	          onUserClicksColumn: this._onUserClicksColumn,
	          "data-tip": true
	        }))
	      ),
	      React.createElement(
	        ReactTooltip,
	        {
	          ref: 'tooltip',
	          id: 'gxaGlobalTooltipOverManagedComponent',
	          type: 'light',
	          frozen: !!this.state.tooltipFrozen,
	          onClickOutside: this.props.enableFreeze ? this._dismissTooltip : undefined,
	          'class': "gxaDisabled" },
	        React.createElement('div', null)
	      )
	    );
	  }
	});

	module.exports = TooltipStateManager;

/***/ },
/* 796 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class, _class2, _temp;

	/* Decoraters */


	/* Utils */


	/* CSS */


	var _react = __webpack_require__(139);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(300);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _classnames = __webpack_require__(797);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _staticMethods = __webpack_require__(798);

	var _staticMethods2 = _interopRequireDefault(_staticMethods);

	var _windowListener = __webpack_require__(800);

	var _windowListener2 = _interopRequireDefault(_windowListener);

	var _customEvent = __webpack_require__(801);

	var _customEvent2 = _interopRequireDefault(_customEvent);

	var _isCapture = __webpack_require__(802);

	var _isCapture2 = _interopRequireDefault(_isCapture);

	var _getPosition = __webpack_require__(803);

	var _getPosition2 = _interopRequireDefault(_getPosition);

	var _getTipContent = __webpack_require__(804);

	var _getTipContent2 = _interopRequireDefault(_getTipContent);

	var _aria = __webpack_require__(805);

	var _style = __webpack_require__(806);

	var _style2 = _interopRequireDefault(_style);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ReactTooltip = (0, _staticMethods2.default)(_class = (0, _windowListener2.default)(_class = (0, _customEvent2.default)(_class = (0, _isCapture2.default)(_class = (_temp = _class2 = function (_Component) {
	  _inherits(ReactTooltip, _Component);

	  function ReactTooltip(props) {
	    _classCallCheck(this, ReactTooltip);

	    var _this = _possibleConstructorReturn(this, (ReactTooltip.__proto__ || Object.getPrototypeOf(ReactTooltip)).call(this, props));

	    _this.onClickOutsideFrozenTooltip = function (e) {
	      var _this$props = _this.props;
	      var frozen = _this$props.frozen;
	      var onClickOutside = _this$props.onClickOutside;
	      var currentTarget = _this.state.currentTarget;

	      if (frozen && onClickOutside && !_reactDom2.default.findDOMNode(_this).contains(e.target) && e.target !== currentTarget) {
	        onClickOutside();
	      }
	    };

	    _this.state = {
	      place: 'top', // Direction of tooltip
	      type: 'dark', // Color theme of tooltip
	      effect: 'float', // float or fixed
	      show: false,
	      border: false,
	      placeholder: '',
	      offset: {},
	      extraClass: '',
	      html: false,
	      delayHide: 0,
	      delayShow: 0,
	      event: props.event || null,
	      eventOff: props.eventOff || null,
	      currentEvent: null, // Current mouse event
	      currentTarget: null, // Current target of mouse event
	      ariaProps: (0, _aria.parseAria)(props), // aria- and role attributes
	      afterUnfreeze: function afterUnfreeze() {},
	      isEmptyTip: false,
	      disable: false
	    };

	    _this.bind(['showTooltip', 'updateTooltip', 'hideTooltip', 'globalRebuild', 'globalShow', 'globalHide', 'onWindowResize']);

	    _this.mount = true;
	    _this.delayShowLoop = null;
	    _this.delayHideLoop = null;
	    _this.intervalUpdateContent = null;
	    return _this;
	  }

	  /**
	   * For unify the bind and unbind listener
	   */


	  _createClass(ReactTooltip, [{
	    key: 'bind',
	    value: function bind(methodArray) {
	      var _this2 = this;

	      methodArray.forEach(function (method) {
	        _this2[method] = _this2[method].bind(_this2);
	      });
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this.setStyleHeader(); // Set the style to the <link>
	      this.bindListener(); // Bind listener for tooltip
	      this.bindWindowEvents(this.props.resizeHide); // Bind global event for static method
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(props) {
	      if (!props.frozen && this.props.frozen) {
	        this.state.afterUnfreeze();
	      }
	      var ariaProps = this.state.ariaProps;

	      var newAriaProps = (0, _aria.parseAria)(props);

	      var isChanged = Object.keys(newAriaProps).some(function (props) {
	        return newAriaProps[props] !== ariaProps[props];
	      });
	      if (isChanged) {
	        this.setState({ ariaProps: newAriaProps });
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.mount = false;

	      this.clearTimer();

	      this.unbindListener();
	      this.removeScrollListener();
	      this.unbindWindowEvents();
	    }

	    /**
	     * Pick out corresponded target elements
	     */

	  }, {
	    key: 'getTargetArray',
	    value: function getTargetArray(id) {
	      var targetArray = void 0;

	      if (!id) {
	        targetArray = document.querySelectorAll('[data-tip]:not([data-for])');
	      } else {
	        targetArray = document.querySelectorAll('[data-tip][data-for="' + id + '"]');
	      }

	      // targetArray is a NodeList, convert it to a real array
	      // I hope I can use Object.values...
	      return Object.keys(targetArray).filter(function (key) {
	        return key !== 'length';
	      }).map(function (key) {
	        return targetArray[key];
	      });
	    }

	    /**
	     * Bind listener to the target elements
	     * These listeners used to trigger showing or hiding the tooltip
	     */

	  }, {
	    key: 'bindListener',
	    value: function bindListener() {
	      var _this3 = this;

	      var _props = this.props;
	      var id = _props.id;
	      var globalEventOff = _props.globalEventOff;

	      var targetArray = this.getTargetArray(id);

	      targetArray.forEach(function (target) {
	        var isCaptureMode = _this3.isCapture(target);
	        if (target.getAttribute('currentItem') === null) {
	          target.setAttribute('currentItem', 'false');
	        }
	        _this3.unbindBasicListener(target);

	        if (_this3.isCustomEvent(target)) {
	          _this3.customBindListener(target);
	          return;
	        }

	        target.addEventListener('mouseenter', _this3.showTooltip, isCaptureMode);
	        if (_this3.state.effect === 'float') {
	          target.addEventListener('mousemove', _this3.updateTooltip, isCaptureMode);
	        }
	        target.addEventListener('mouseleave', _this3.hideTooltip, isCaptureMode);
	      });

	      // Global event to hide tooltip
	      if (globalEventOff) {
	        window.removeEventListener(globalEventOff, this.hideTooltip);
	        window.addEventListener(globalEventOff, this.hideTooltip, false);
	      }

	      if (this.props.onClickOutside) {
	        window.addEventListener('click', this.onClickOutsideFrozenTooltip);
	      }
	    }

	    /**
	     * Unbind listeners on target elements
	     */

	  }, {
	    key: 'unbindListener',
	    value: function unbindListener() {
	      var _this4 = this;

	      var _props2 = this.props;
	      var id = _props2.id;
	      var globalEventOff = _props2.globalEventOff;

	      var targetArray = this.getTargetArray(id);
	      targetArray.forEach(function (target) {
	        _this4.unbindBasicListener(target);
	        if (_this4.isCustomEvent(target)) _this4.customUnbindListener(target);
	      });

	      if (globalEventOff) window.removeEventListener(globalEventOff, this.hideTooltip);
	      window.removeEventListener('click', this.onClickOutsideFrozenTooltip);
	    }

	    /**
	     * Invoke this before bind listener and ummount the compont
	     * it is necessary to invloke this even when binding custom event
	     * so that the tooltip can switch between custom and default listener
	     */

	  }, {
	    key: 'unbindBasicListener',
	    value: function unbindBasicListener(target) {
	      target.removeEventListener('mouseenter', this.showTooltip);
	      target.removeEventListener('mousemove', this.updateTooltip);
	      target.removeEventListener('mouseleave', this.hideTooltip);
	    }

	    /**
	     * When mouse enter, show the tooltip
	     */

	  }, {
	    key: 'showTooltip',
	    value: function showTooltip(e, isGlobalCall) {
	      var _this5 = this;

	      if (isGlobalCall) {
	        // Don't trigger other elements belongs to other ReactTooltip
	        var targetArray = this.getTargetArray(this.props.id);
	        var isMyElement = targetArray.some(function (ele) {
	          return ele === e.currentTarget;
	        });
	        if (!isMyElement || this.state.show) return;
	      }
	      // Get the tooltip content
	      // calculate in this phrase so that tip width height can be detected
	      var _props3 = this.props;
	      var children = _props3.children;
	      var multiline = _props3.multiline;
	      var getContent = _props3.getContent;
	      var frozen = _props3.frozen;

	      if (frozen) return;
	      var originTooltip = e.currentTarget.getAttribute('data-tip');
	      var isMultiline = e.currentTarget.getAttribute('data-multiline') || multiline || false;

	      // Generate tootlip content
	      var content = void 0;
	      if (getContent) {
	        if (Array.isArray(getContent)) {
	          content = getContent[0] && getContent[0]();
	        } else {
	          content = getContent();
	        }
	      }
	      var placeholder = (0, _getTipContent2.default)(originTooltip, children, content, isMultiline);
	      var isEmptyTip = typeof placeholder === 'string' && placeholder === '' || placeholder === null;

	      // If it is focus event or called by ReactTooltip.show, switch to `solid` effect
	      var switchToSolid = e instanceof window.FocusEvent || isGlobalCall;

	      // if it need to skip adding hide listener to scroll
	      var scrollHide = true;
	      if (e.currentTarget.getAttribute('data-scroll-hide')) {
	        scrollHide = e.currentTarget.getAttribute('data-scroll-hide') === 'true';
	      } else if (this.props.scrollHide != null) {
	        scrollHide = this.props.scrollHide;
	      }

	      this.setState({
	        placeholder: placeholder,
	        isEmptyTip: isEmptyTip,
	        place: e.currentTarget.getAttribute('data-place') || this.props.place || 'top',
	        type: e.currentTarget.getAttribute('data-type') || this.props.type || 'dark',
	        effect: switchToSolid && 'solid' || e.currentTarget.getAttribute('data-effect') || this.props.effect || 'float',
	        offset: e.currentTarget.getAttribute('data-offset') || this.props.offset || {},
	        html: e.currentTarget.getAttribute('data-html') ? e.currentTarget.getAttribute('data-html') === 'true' : this.props.html || false,
	        delayShow: e.currentTarget.getAttribute('data-delay-show') || this.props.delayShow || 0,
	        delayHide: e.currentTarget.getAttribute('data-delay-hide') || this.props.delayHide || 0,
	        border: e.currentTarget.getAttribute('data-border') ? e.currentTarget.getAttribute('data-border') === 'true' : this.props.border || false,
	        extraClass: e.currentTarget.getAttribute('data-class') || this.props.class || '',
	        disable: e.currentTarget.getAttribute('data-tip-disable') ? e.currentTarget.getAttribute('data-tip-disable') === 'true' : this.props.disable || false
	      }, function () {
	        if (scrollHide) _this5.addScrollListener(e);
	        _this5.updateTooltip(e);

	        if (getContent && Array.isArray(getContent)) {
	          _this5.intervalUpdateContent = setInterval(function () {
	            if (_this5.mount) {
	              var _getContent = _this5.props.getContent;

	              var _placeholder = (0, _getTipContent2.default)(originTooltip, _getContent[0](), isMultiline);
	              var _isEmptyTip = typeof _placeholder === 'string' && _placeholder === '';
	              _this5.setState({
	                placeholder: _placeholder,
	                isEmptyTip: _isEmptyTip
	              });
	            }
	          }, getContent[1]);
	        }
	      });
	    }

	    /**
	     * When mouse hover, updatetooltip
	     */

	  }, {
	    key: 'updateTooltip',
	    value: function updateTooltip(e) {
	      var _this6 = this;

	      var _state = this.state;
	      var delayShow = _state.delayShow;
	      var show = _state.show;
	      var isEmptyTip = _state.isEmptyTip;
	      var disable = _state.disable;
	      var _props4 = this.props;
	      var afterShow = _props4.afterShow;
	      var frozen = _props4.frozen;
	      var placeholder = this.state.placeholder;

	      var delayTime = show ? 0 : parseInt(delayShow, 10);
	      var eventTarget = e.currentTarget;

	      if (isEmptyTip || disable) return; // if the tooltip is empty, disable the tooltip
	      var updateState = function updateState() {
	        if (Array.isArray(placeholder) && placeholder.length > 0 || placeholder) {
	          (function () {
	            var isInvisible = !_this6.state.show;
	            _this6.setState({
	              currentEvent: e,
	              currentTarget: eventTarget,
	              show: true
	            }, function () {
	              _this6.updatePosition();
	              if (isInvisible && afterShow) afterShow();
	            });
	          })();
	        }
	      };

	      clearTimeout(this.delayShowLoop);
	      if (frozen) {
	        this.setState({ afterUnfreeze: updateState });
	      } else if (delayShow) {
	        this.delayShowLoop = setTimeout(updateState, delayTime);
	      } else {
	        updateState();
	      }
	    }
	  }, {
	    key: 'hideTooltip',


	    /**
	     * When mouse leave, hide tooltip
	     */
	    value: function hideTooltip(e, hasTarget) {
	      var _this7 = this;

	      var _state2 = this.state;
	      var delayHide = _state2.delayHide;
	      var isEmptyTip = _state2.isEmptyTip;
	      var disable = _state2.disable;
	      var _props5 = this.props;
	      var afterHide = _props5.afterHide;
	      var frozen = _props5.frozen;

	      if (!this.mount) return;
	      if (isEmptyTip || disable) return; // if the tooltip is empty, disable the tooltip
	      if (hasTarget) {
	        // Don't trigger other elements belongs to other ReactTooltip
	        var targetArray = this.getTargetArray(this.props.id);
	        var isMyElement = targetArray.some(function (ele) {
	          return ele === e.currentTarget;
	        });
	        if (!isMyElement || !this.state.show) return;
	      }
	      var resetState = function resetState() {
	        var isVisible = _this7.state.show;
	        _this7.setState({
	          show: false
	        }, function () {
	          _this7.removeScrollListener();
	          if (isVisible && afterHide) afterHide();
	        });
	      };

	      this.clearTimer();
	      if (frozen) {
	        this.setState({ afterUnfreeze: resetState });
	      } else if (delayHide) {
	        this.delayHideLoop = setTimeout(resetState, parseInt(delayHide, 10));
	      } else {
	        resetState();
	      }
	    }

	    /**
	     * Add scroll eventlistener when tooltip show
	     * automatically hide the tooltip when scrolling
	     */

	  }, {
	    key: 'addScrollListener',
	    value: function addScrollListener(e) {
	      var isCaptureMode = this.isCapture(e.currentTarget);
	      window.addEventListener('scroll', this.hideTooltip, isCaptureMode);
	    }
	  }, {
	    key: 'removeScrollListener',
	    value: function removeScrollListener() {
	      window.removeEventListener('scroll', this.hideTooltip);
	    }

	    // Calculate the position

	  }, {
	    key: 'updatePosition',
	    value: function updatePosition() {
	      var _this8 = this;

	      var _state3 = this.state;
	      var currentEvent = _state3.currentEvent;
	      var currentTarget = _state3.currentTarget;
	      var place = _state3.place;
	      var effect = _state3.effect;
	      var offset = _state3.offset;

	      var node = _reactDom2.default.findDOMNode(this);
	      var result = (0, _getPosition2.default)(currentEvent, currentTarget, node, place, effect, offset);

	      if (result.isNewState) {
	        // Switch to reverse placement
	        return this.setState(result.newState, function () {
	          _this8.updatePosition();
	        });
	      }
	      // Set tooltip position
	      node.style.left = result.position.left + 'px';
	      node.style.top = result.position.top + 'px';
	    }

	    /**
	     * Set style tag in header
	     * in this way we can insert default css
	     */

	  }, {
	    key: 'setStyleHeader',
	    value: function setStyleHeader() {
	      if (!document.getElementsByTagName('head')[0].querySelector('style[id="react-tooltip"]')) {
	        var tag = document.createElement('style');
	        tag.id = 'react-tooltip';
	        tag.innerHTML = _style2.default;
	        document.getElementsByTagName('head')[0].appendChild(tag);
	      }
	    }

	    /**
	     * CLear all kinds of timeout of interval
	     */

	  }, {
	    key: 'clearTimer',
	    value: function clearTimer() {
	      clearTimeout(this.delayShowLoop);
	      clearTimeout(this.delayHideLoop);
	      clearInterval(this.intervalUpdateContent);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _state4 = this.state;
	      var placeholder = _state4.placeholder;
	      var extraClass = _state4.extraClass;
	      var html = _state4.html;
	      var ariaProps = _state4.ariaProps;
	      var disable = _state4.disable;
	      var isEmptyTip = _state4.isEmptyTip;

	      var tooltipClass = (0, _classnames2.default)('__react_component_tooltip', { 'show': this.state.show && !disable && !isEmptyTip }, { 'frozen': this.props.frozen }, { 'border': this.state.border }, { 'place-top': this.state.place === 'top' }, { 'place-bottom': this.state.place === 'bottom' }, { 'place-left': this.state.place === 'left' }, { 'place-right': this.state.place === 'right' }, { 'type-dark': this.state.type === 'dark' }, { 'type-success': this.state.type === 'success' }, { 'type-warning': this.state.type === 'warning' }, { 'type-error': this.state.type === 'error' }, { 'type-info': this.state.type === 'info' }, { 'type-light': this.state.type === 'light' });
	      if (html) {
	        return _react2.default.createElement('div', _extends({ className: tooltipClass + ' ' + extraClass
	        }, ariaProps, {
	          'data-id': 'tooltip',
	          dangerouslySetInnerHTML: { __html: placeholder } }));
	      } else {
	        return _react2.default.createElement(
	          'div',
	          _extends({ className: tooltipClass + ' ' + extraClass
	          }, ariaProps, {
	            'data-id': 'tooltip' }),
	          placeholder
	        );
	      }
	    }
	  }]);

	  return ReactTooltip;
	}(_react.Component), _class2.propTypes = {
	  children: _react.PropTypes.any,
	  place: _react.PropTypes.string,
	  type: _react.PropTypes.string,
	  effect: _react.PropTypes.string,
	  offset: _react.PropTypes.object,
	  multiline: _react.PropTypes.bool,
	  border: _react.PropTypes.bool,
	  class: _react.PropTypes.string,
	  id: _react.PropTypes.string,
	  html: _react.PropTypes.bool,
	  delayHide: _react.PropTypes.number,
	  delayShow: _react.PropTypes.number,
	  event: _react.PropTypes.string,
	  eventOff: _react.PropTypes.string,
	  watchWindow: _react.PropTypes.bool,
	  isCapture: _react.PropTypes.bool,
	  globalEventOff: _react.PropTypes.string,
	  getContent: _react.PropTypes.any,
	  afterShow: _react.PropTypes.func,
	  afterHide: _react.PropTypes.func,
	  disable: _react.PropTypes.bool,
	  frozen: _react.PropTypes.bool,
	  onClickOutside: _react.PropTypes.func,
	  scrollHide: _react.PropTypes.bool,
	  resizeHide: _react.PropTypes.bool
	}, _class2.defaultProps = {
	  resizeHide: true
	}, _temp)) || _class) || _class) || _class) || _class;

	/* export default not fit for standalone, it will exports {default:...} */


	module.exports = ReactTooltip;

/***/ },
/* 797 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 798 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (target) {
	  /**
	   * Hide all tooltip
	   * @trigger ReactTooltip.hide()
	   */
	  target.hide = function (target) {
	    dispatchGlobalEvent(_constant2.default.GLOBAL.HIDE, { target: target });
	  };

	  /**
	   * Rebuild all tooltip
	   * @trigger ReactTooltip.rebuild()
	   */
	  target.rebuild = function () {
	    dispatchGlobalEvent(_constant2.default.GLOBAL.REBUILD);
	  };

	  /**
	   * Show specific tooltip
	   * @trigger ReactTooltip.show()
	   */
	  target.show = function (target) {
	    dispatchGlobalEvent(_constant2.default.GLOBAL.SHOW, { target: target });
	  };

	  target.prototype.globalRebuild = function () {
	    if (this.mount) {
	      this.unbindListener();
	      this.bindListener();
	    }
	  };

	  target.prototype.globalShow = function (event) {
	    if (this.mount) {
	      // Create a fake event, specific show will limit the type to `solid`
	      // only `float` type cares e.clientX e.clientY
	      var e = { currentTarget: event.detail.target };
	      this.showTooltip(e, true);
	    }
	  };

	  target.prototype.globalHide = function (event) {
	    if (this.mount) {
	      var hasTarget = event && event.detail && event.detail.target && true || false;
	      this.hideTooltip({ currentTarget: hasTarget && event.detail.target }, hasTarget);
	    }
	  };
	};

	var _constant = __webpack_require__(799);

	var _constant2 = _interopRequireDefault(_constant);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var dispatchGlobalEvent = function dispatchGlobalEvent(eventName, opts) {
	  // Compatibale with IE
	  // @see http://stackoverflow.com/questions/26596123/internet-explorer-9-10-11-event-constructor-doesnt-work
	  var event = void 0;

	  if (typeof window.CustomEvent === 'function') {
	    event = new window.CustomEvent(eventName, { detail: opts });
	  } else {
	    event = document.createEvent('Event');
	    event.initEvent(eventName, false, true, opts);
	  }

	  window.dispatchEvent(event);
	}; /**
	    * Static methods for react-tooltip
	    */

/***/ },
/* 799 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {

	  GLOBAL: {
	    HIDE: '__react_tooltip_hide_event',
	    REBUILD: '__react_tooltip_rebuild_event',
	    SHOW: '__react_tooltip_show_event'
	  }
	};

/***/ },
/* 800 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (target) {
	  target.prototype.bindWindowEvents = function (resizeHide) {
	    // ReactTooltip.hide
	    window.removeEventListener(_constant2.default.GLOBAL.HIDE, this.globalHide);
	    window.addEventListener(_constant2.default.GLOBAL.HIDE, this.globalHide, false);

	    // ReactTooltip.rebuild
	    window.removeEventListener(_constant2.default.GLOBAL.REBUILD, this.globalRebuild);
	    window.addEventListener(_constant2.default.GLOBAL.REBUILD, this.globalRebuild, false);

	    // ReactTooltip.show
	    window.removeEventListener(_constant2.default.GLOBAL.SHOW, this.globalShow);
	    window.addEventListener(_constant2.default.GLOBAL.SHOW, this.globalShow, false);

	    // Resize
	    if (resizeHide) {
	      window.removeEventListener('resize', this.onWindowResize);
	      window.addEventListener('resize', this.onWindowResize, false);
	    }
	  };

	  target.prototype.unbindWindowEvents = function () {
	    window.removeEventListener(_constant2.default.GLOBAL.HIDE, this.globalHide);
	    window.removeEventListener(_constant2.default.GLOBAL.REBUILD, this.globalRebuild);
	    window.removeEventListener(_constant2.default.GLOBAL.SHOW, this.globalShow);
	    window.removeEventListener('resize', this.onWindowResize);
	  };

	  /**
	   * invoked by resize event of window
	   */
	  target.prototype.onWindowResize = function () {
	    if (!this.mount) return;
	    this.hideTooltip();
	  };
	};

	var _constant = __webpack_require__(799);

	var _constant2 = _interopRequireDefault(_constant);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 801 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (target) {
	  target.prototype.isCustomEvent = function (ele) {
	    var event = this.state.event;

	    return event || !!ele.getAttribute('data-event');
	  };

	  /* Bind listener for custom event */
	  target.prototype.customBindListener = function (ele) {
	    var _this = this;

	    var _state = this.state;
	    var event = _state.event;
	    var eventOff = _state.eventOff;

	    var dataEvent = ele.getAttribute('data-event') || event;
	    var dataEventOff = ele.getAttribute('data-event-off') || eventOff;

	    dataEvent.split(' ').forEach(function (event) {
	      ele.removeEventListener(event, customListener);
	      customListener = checkStatus.bind(_this, dataEventOff);
	      ele.addEventListener(event, customListener, false);
	    });
	    if (dataEventOff) {
	      dataEventOff.split(' ').forEach(function (event) {
	        ele.removeEventListener(event, _this.hideTooltip);
	        ele.addEventListener(event, _this.hideTooltip, false);
	      });
	    }
	  };

	  /* Unbind listener for custom event */
	  target.prototype.customUnbindListener = function (ele) {
	    var _state2 = this.state;
	    var event = _state2.event;
	    var eventOff = _state2.eventOff;

	    var dataEvent = event || ele.getAttribute('data-event');
	    var dataEventOff = eventOff || ele.getAttribute('data-event-off');

	    ele.removeEventListener(dataEvent, customListener);
	    if (dataEventOff) ele.removeEventListener(dataEventOff, this.hideTooltip);
	  };
	};

	/**
	 * Custom events to control showing and hiding of tooltip
	 *
	 * @attributes
	 * - `event` {String}
	 * - `eventOff` {String}
	 */

	var checkStatus = function checkStatus(dataEventOff, e) {
	  var show = this.state.show;
	  var id = this.props.id;

	  var dataIsCapture = e.currentTarget.getAttribute('data-iscapture');
	  var isCapture = dataIsCapture && dataIsCapture === 'true' || this.props.isCapture;
	  var currentItem = e.currentTarget.getAttribute('currentItem');

	  if (!isCapture) e.stopPropagation();
	  if (show && currentItem === 'true') {
	    if (!dataEventOff) this.hideTooltip(e);
	  } else {
	    e.currentTarget.setAttribute('currentItem', 'true');
	    setUntargetItems(e.currentTarget, this.getTargetArray(id));
	    this.showTooltip(e);
	  }
	};

	var setUntargetItems = function setUntargetItems(currentTarget, targetArray) {
	  for (var i = 0; i < targetArray.length; i++) {
	    if (currentTarget !== targetArray[i]) {
	      targetArray[i].setAttribute('currentItem', 'false');
	    } else {
	      targetArray[i].setAttribute('currentItem', 'true');
	    }
	  }
	};

	var customListener = void 0;

/***/ },
/* 802 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (target) {
	  target.prototype.isCapture = function (currentTarget) {
	    var dataIsCapture = currentTarget.getAttribute('data-iscapture');
	    return dataIsCapture && dataIsCapture === 'true' || this.props.isCapture || false;
	  };
	};

/***/ },
/* 803 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (e, target, node, place, effect, offset) {
	  var tipWidth = node.clientWidth;
	  var tipHeight = node.clientHeight;

	  var _getCurrentOffset = getCurrentOffset(e, target, effect);

	  var mouseX = _getCurrentOffset.mouseX;
	  var mouseY = _getCurrentOffset.mouseY;

	  var defaultOffset = getDefaultPosition(effect, target.clientWidth, target.clientHeight, tipWidth, tipHeight);

	  var _calculateOffset = calculateOffset(offset);

	  var extraOffset_X = _calculateOffset.extraOffset_X;
	  var extraOffset_Y = _calculateOffset.extraOffset_Y;


	  var windowWidth = window.innerWidth;
	  var windowHeight = window.innerHeight;

	  var _getParent = getParent(node);

	  var parentTop = _getParent.parentTop;
	  var parentLeft = _getParent.parentLeft;

	  // Get the edge offset of the tooltip

	  var getTipOffsetLeft = function getTipOffsetLeft(place) {
	    var offset_X = defaultOffset[place].l;
	    return mouseX + offset_X + extraOffset_X;
	  };
	  var getTipOffsetRight = function getTipOffsetRight(place) {
	    var offset_X = defaultOffset[place].r;
	    return mouseX + offset_X + extraOffset_X;
	  };
	  var getTipOffsetTop = function getTipOffsetTop(place) {
	    var offset_Y = defaultOffset[place].t;
	    return mouseY + offset_Y + extraOffset_Y;
	  };
	  var getTipOffsetBottom = function getTipOffsetBottom(place) {
	    var offset_Y = defaultOffset[place].b;
	    return mouseY + offset_Y + extraOffset_Y;
	  };

	  // Judge if the tooltip has over the window(screen)
	  var outsideVertical = function outsideVertical() {
	    var result = false;
	    var newPlace = void 0;
	    if (getTipOffsetTop('left') < 0 && getTipOffsetBottom('left') <= windowHeight && getTipOffsetBottom('bottom') <= windowHeight) {
	      result = true;
	      newPlace = 'bottom';
	    } else if (getTipOffsetBottom('left') > windowHeight && getTipOffsetTop('left') >= 0 && getTipOffsetTop('top') >= 0) {
	      result = true;
	      newPlace = 'top';
	    }
	    return { result: result, newPlace: newPlace };
	  };
	  var outsideLeft = function outsideLeft() {
	    var _outsideVertical = outsideVertical();

	    var result = _outsideVertical.result;
	    var newPlace = _outsideVertical.newPlace; // Deal with vertical as first priority

	    if (result && outsideHorizontal().result) {
	      return { result: false }; // No need to change, if change to vertical will out of space
	    }
	    if (!result && getTipOffsetLeft('left') < 0 && getTipOffsetRight('right') <= windowWidth) {
	      result = true; // If vertical ok, but let out of side and right won't out of side
	      newPlace = 'right';
	    }
	    return { result: result, newPlace: newPlace };
	  };
	  var outsideRight = function outsideRight() {
	    var _outsideVertical2 = outsideVertical();

	    var result = _outsideVertical2.result;
	    var newPlace = _outsideVertical2.newPlace;

	    if (result && outsideHorizontal().result) {
	      return { result: false }; // No need to change, if change to vertical will out of space
	    }
	    if (!result && getTipOffsetRight('right') > windowWidth && getTipOffsetLeft('left') >= 0) {
	      result = true;
	      newPlace = 'left';
	    }
	    return { result: result, newPlace: newPlace };
	  };

	  var outsideHorizontal = function outsideHorizontal() {
	    var result = false;
	    var newPlace = void 0;
	    if (getTipOffsetLeft('top') < 0 && getTipOffsetRight('top') <= windowWidth && getTipOffsetRight('right') <= windowWidth) {
	      result = true;
	      newPlace = 'right';
	    } else if (getTipOffsetRight('top') > windowWidth && getTipOffsetLeft('top') >= 0 && getTipOffsetLeft('left') >= 0) {
	      result = true;
	      newPlace = 'left';
	    }
	    return { result: result, newPlace: newPlace };
	  };
	  var outsideTop = function outsideTop() {
	    var _outsideHorizontal = outsideHorizontal();

	    var result = _outsideHorizontal.result;
	    var newPlace = _outsideHorizontal.newPlace;

	    if (result && outsideVertical().result) {
	      return { result: false };
	    }
	    if (!result && getTipOffsetTop('top') < 0 && getTipOffsetBottom('bottom') <= windowHeight) {
	      result = true;
	      newPlace = 'bottom';
	    }
	    return { result: result, newPlace: newPlace };
	  };
	  var outsideBottom = function outsideBottom() {
	    var _outsideHorizontal2 = outsideHorizontal();

	    var result = _outsideHorizontal2.result;
	    var newPlace = _outsideHorizontal2.newPlace;

	    if (result && outsideVertical().result) {
	      return { result: false };
	    }
	    if (!result && getTipOffsetBottom('bottom') > windowHeight && getTipOffsetTop('top') >= 0) {
	      result = true;
	      newPlace = 'top';
	    }
	    return { result: result, newPlace: newPlace };
	  };

	  // Return new state to change the placement to the reverse if possible
	  var outsideLeftResult = outsideLeft();
	  var outsideRightResult = outsideRight();
	  var outsideTopResult = outsideTop();
	  var outsideBottomResult = outsideBottom();

	  if (place === 'left' && outsideLeftResult.result) {
	    return {
	      isNewState: true,
	      newState: { place: outsideLeftResult.newPlace }
	    };
	  } else if (place === 'right' && outsideRightResult.result) {
	    return {
	      isNewState: true,
	      newState: { place: outsideRightResult.newPlace }
	    };
	  } else if (place === 'top' && outsideTopResult.result) {
	    return {
	      isNewState: true,
	      newState: { place: outsideTopResult.newPlace }
	    };
	  } else if (place === 'bottom' && outsideBottomResult.result) {
	    return {
	      isNewState: true,
	      newState: { place: outsideBottomResult.newPlace }
	    };
	  }

	  // Return tooltip offset position
	  return {
	    isNewState: false,
	    position: {
	      left: parseInt(getTipOffsetLeft(place) - parentLeft, 10),
	      top: parseInt(getTipOffsetTop(place) - parentTop, 10)
	    }
	  };
	};

	// Get current mouse offset
	var getCurrentOffset = function getCurrentOffset(e, currentTarget, effect) {
	  var boundingClientRect = currentTarget.getBoundingClientRect();
	  var targetTop = boundingClientRect.top;
	  var targetLeft = boundingClientRect.left;
	  var targetWidth = currentTarget.clientWidth;
	  var targetHeight = currentTarget.clientHeight;

	  if (effect === 'float') {
	    return {
	      mouseX: e.clientX,
	      mouseY: e.clientY
	    };
	  }
	  return {
	    mouseX: targetLeft + targetWidth / 2,
	    mouseY: targetTop + targetHeight / 2
	  };
	};

	// List all possibility of tooltip final offset
	// This is useful in judging if it is necessary for tooltip to switch position when out of window
	/**
	 * Calculate the position of tooltip
	 *
	 * @params
	 * - `e` {Event} the event of current mouse
	 * - `target` {Element} the currentTarget of the event
	 * - `node` {DOM} the react-tooltip object
	 * - `place` {String} top / right / bottom / left
	 * - `effect` {String} float / solid
	 * - `offset` {Object} the offset to default position
	 *
	 * @return {Object
	 * - `isNewState` {Bool} required
	 * - `newState` {Object}
	 * - `position` {OBject} {left: {Number}, top: {Number}}
	 */
	var getDefaultPosition = function getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight) {
	  var top = void 0;
	  var right = void 0;
	  var bottom = void 0;
	  var left = void 0;
	  var disToMouse = 3;
	  var triangleHeight = 2;
	  var cursorHeight = 12; // Optimize for float bottom only, cause the cursor will hide the tooltip

	  if (effect === 'float') {
	    top = {
	      l: -(tipWidth / 2),
	      r: tipWidth / 2,
	      t: -(tipHeight + disToMouse + triangleHeight),
	      b: -disToMouse
	    };
	    bottom = {
	      l: -(tipWidth / 2),
	      r: tipWidth / 2,
	      t: disToMouse + cursorHeight,
	      b: tipHeight + disToMouse + triangleHeight + cursorHeight
	    };
	    left = {
	      l: -(tipWidth + disToMouse + triangleHeight),
	      r: -disToMouse,
	      t: -(tipHeight / 2),
	      b: tipHeight / 2
	    };
	    right = {
	      l: disToMouse,
	      r: tipWidth + disToMouse + triangleHeight,
	      t: -(tipHeight / 2),
	      b: tipHeight / 2
	    };
	  } else if (effect === 'solid') {
	    top = {
	      l: -(tipWidth / 2),
	      r: tipWidth / 2,
	      t: -(targetHeight / 2 + tipHeight + triangleHeight),
	      b: -(targetHeight / 2)
	    };
	    bottom = {
	      l: -(tipWidth / 2),
	      r: tipWidth / 2,
	      t: targetHeight / 2,
	      b: targetHeight / 2 + tipHeight + triangleHeight
	    };
	    left = {
	      l: -(tipWidth + targetWidth / 2 + triangleHeight),
	      r: -(targetWidth / 2),
	      t: -(tipHeight / 2),
	      b: tipHeight / 2
	    };
	    right = {
	      l: targetWidth / 2,
	      r: tipWidth + targetWidth / 2 + triangleHeight,
	      t: -(tipHeight / 2),
	      b: tipHeight / 2
	    };
	  }

	  return { top: top, bottom: bottom, left: left, right: right };
	};

	// Consider additional offset into position calculation
	var calculateOffset = function calculateOffset(offset) {
	  var extraOffset_X = 0;
	  var extraOffset_Y = 0;

	  if (Object.prototype.toString.apply(offset) === '[object String]') {
	    offset = JSON.parse(offset.toString().replace(/\'/g, '\"'));
	  }
	  for (var key in offset) {
	    if (key === 'top') {
	      extraOffset_Y -= parseInt(offset[key], 10);
	    } else if (key === 'bottom') {
	      extraOffset_Y += parseInt(offset[key], 10);
	    } else if (key === 'left') {
	      extraOffset_X -= parseInt(offset[key], 10);
	    } else if (key === 'right') {
	      extraOffset_X += parseInt(offset[key], 10);
	    }
	  }

	  return { extraOffset_X: extraOffset_X, extraOffset_Y: extraOffset_Y };
	};

	// Get the offset of the parent elements
	var getParent = function getParent(currentTarget) {
	  var currentParent = currentTarget;
	  while (currentParent) {
	    if (window.getComputedStyle(currentParent).getPropertyValue('transform') !== 'none') break;
	    currentParent = currentParent.parentElement;
	  }

	  var parentTop = currentParent && currentParent.getBoundingClientRect().top || 0;
	  var parentLeft = currentParent && currentParent.getBoundingClientRect().left || 0;

	  return { parentTop: parentTop, parentLeft: parentLeft };
	};

/***/ },
/* 804 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	exports.default = function (tip, children, getContent, multiline) {
	  if (children) return children;
	  if (getContent !== undefined && getContent !== null) return getContent; // getContent can be 0, '', etc.
	  if (getContent === null) return null; // Tip not exist and childern is null or undefined

	  var regexp = /<br\s*\/?>/;
	  if (!multiline || multiline === 'false' || !regexp.test(tip)) {
	    // No trim(), so that user can keep their input
	    return tip;
	  }

	  // Multiline tooltip content
	  return tip.split(regexp).map(function (d, i) {
	    return _react2.default.createElement(
	      'span',
	      { key: i, className: 'multi-line' },
	      d
	    );
	  });
	};

	var _react = __webpack_require__(139);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 805 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parseAria = parseAria;
	/**
	 * Support aria- and role in ReactTooltip
	 *
	 * @params props {Object}
	 * @return {Object}
	 */
	function parseAria(props) {
	  var ariaObj = {};
	  Object.keys(props).filter(function (prop) {
	    // aria-xxx and role is acceptable
	    return (/(^aria-\w+$|^role$)/.test(prop)
	    );
	  }).forEach(function (prop) {
	    ariaObj[prop] = props[prop];
	  });

	  return ariaObj;
	}

/***/ },
/* 806 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = '.__react_component_tooltip{border-radius:3px;display:inline-block;font-size:13px;left:-999em;opacity:0;padding:8px 21px;position:fixed;pointer-events:none;transition:opacity 0.3s ease-out;top:-999em;visibility:hidden;z-index:999}.__react_component_tooltip:before,.__react_component_tooltip:after{content:"";width:0;height:0;position:absolute}.__react_component_tooltip.show{opacity:0.9;margin-top:0px;margin-left:0px;visibility:visible}.__react_component_tooltip.frozen{pointer-events:auto}.__react_component_tooltip.type-dark{color:#fff;background-color:#222}.__react_component_tooltip.type-dark.place-top:after{border-top-color:#222;border-top-style:solid;border-top-width:6px}.__react_component_tooltip.type-dark.place-bottom:after{border-bottom-color:#222;border-bottom-style:solid;border-bottom-width:6px}.__react_component_tooltip.type-dark.place-left:after{border-left-color:#222;border-left-style:solid;border-left-width:6px}.__react_component_tooltip.type-dark.place-right:after{border-right-color:#222;border-right-style:solid;border-right-width:6px}.__react_component_tooltip.type-dark.border{border:1px solid #fff}.__react_component_tooltip.type-dark.border.place-top:before{border-top:8px solid #fff}.__react_component_tooltip.type-dark.border.place-bottom:before{border-bottom:8px solid #fff}.__react_component_tooltip.type-dark.border.place-left:before{border-left:8px solid #fff}.__react_component_tooltip.type-dark.border.place-right:before{border-right:8px solid #fff}.__react_component_tooltip.type-success{color:#fff;background-color:#8DC572}.__react_component_tooltip.type-success.place-top:after{border-top-color:#8DC572;border-top-style:solid;border-top-width:6px}.__react_component_tooltip.type-success.place-bottom:after{border-bottom-color:#8DC572;border-bottom-style:solid;border-bottom-width:6px}.__react_component_tooltip.type-success.place-left:after{border-left-color:#8DC572;border-left-style:solid;border-left-width:6px}.__react_component_tooltip.type-success.place-right:after{border-right-color:#8DC572;border-right-style:solid;border-right-width:6px}.__react_component_tooltip.type-success.border{border:1px solid #fff}.__react_component_tooltip.type-success.border.place-top:before{border-top:8px solid #fff}.__react_component_tooltip.type-success.border.place-bottom:before{border-bottom:8px solid #fff}.__react_component_tooltip.type-success.border.place-left:before{border-left:8px solid #fff}.__react_component_tooltip.type-success.border.place-right:before{border-right:8px solid #fff}.__react_component_tooltip.type-warning{color:#fff;background-color:#F0AD4E}.__react_component_tooltip.type-warning.place-top:after{border-top-color:#F0AD4E;border-top-style:solid;border-top-width:6px}.__react_component_tooltip.type-warning.place-bottom:after{border-bottom-color:#F0AD4E;border-bottom-style:solid;border-bottom-width:6px}.__react_component_tooltip.type-warning.place-left:after{border-left-color:#F0AD4E;border-left-style:solid;border-left-width:6px}.__react_component_tooltip.type-warning.place-right:after{border-right-color:#F0AD4E;border-right-style:solid;border-right-width:6px}.__react_component_tooltip.type-warning.border{border:1px solid #fff}.__react_component_tooltip.type-warning.border.place-top:before{border-top:8px solid #fff}.__react_component_tooltip.type-warning.border.place-bottom:before{border-bottom:8px solid #fff}.__react_component_tooltip.type-warning.border.place-left:before{border-left:8px solid #fff}.__react_component_tooltip.type-warning.border.place-right:before{border-right:8px solid #fff}.__react_component_tooltip.type-error{color:#fff;background-color:#BE6464}.__react_component_tooltip.type-error.place-top:after{border-top-color:#BE6464;border-top-style:solid;border-top-width:6px}.__react_component_tooltip.type-error.place-bottom:after{border-bottom-color:#BE6464;border-bottom-style:solid;border-bottom-width:6px}.__react_component_tooltip.type-error.place-left:after{border-left-color:#BE6464;border-left-style:solid;border-left-width:6px}.__react_component_tooltip.type-error.place-right:after{border-right-color:#BE6464;border-right-style:solid;border-right-width:6px}.__react_component_tooltip.type-error.border{border:1px solid #fff}.__react_component_tooltip.type-error.border.place-top:before{border-top:8px solid #fff}.__react_component_tooltip.type-error.border.place-bottom:before{border-bottom:8px solid #fff}.__react_component_tooltip.type-error.border.place-left:before{border-left:8px solid #fff}.__react_component_tooltip.type-error.border.place-right:before{border-right:8px solid #fff}.__react_component_tooltip.type-info{color:#fff;background-color:#337AB7}.__react_component_tooltip.type-info.place-top:after{border-top-color:#337AB7;border-top-style:solid;border-top-width:6px}.__react_component_tooltip.type-info.place-bottom:after{border-bottom-color:#337AB7;border-bottom-style:solid;border-bottom-width:6px}.__react_component_tooltip.type-info.place-left:after{border-left-color:#337AB7;border-left-style:solid;border-left-width:6px}.__react_component_tooltip.type-info.place-right:after{border-right-color:#337AB7;border-right-style:solid;border-right-width:6px}.__react_component_tooltip.type-info.border{border:1px solid #fff}.__react_component_tooltip.type-info.border.place-top:before{border-top:8px solid #fff}.__react_component_tooltip.type-info.border.place-bottom:before{border-bottom:8px solid #fff}.__react_component_tooltip.type-info.border.place-left:before{border-left:8px solid #fff}.__react_component_tooltip.type-info.border.place-right:before{border-right:8px solid #fff}.__react_component_tooltip.type-light{color:#222;background-color:#fff}.__react_component_tooltip.type-light.place-top:after{border-top-color:#fff;border-top-style:solid;border-top-width:6px}.__react_component_tooltip.type-light.place-bottom:after{border-bottom-color:#fff;border-bottom-style:solid;border-bottom-width:6px}.__react_component_tooltip.type-light.place-left:after{border-left-color:#fff;border-left-style:solid;border-left-width:6px}.__react_component_tooltip.type-light.place-right:after{border-right-color:#fff;border-right-style:solid;border-right-width:6px}.__react_component_tooltip.type-light.border{border:1px solid #222}.__react_component_tooltip.type-light.border.place-top:before{border-top:8px solid #222}.__react_component_tooltip.type-light.border.place-bottom:before{border-bottom:8px solid #222}.__react_component_tooltip.type-light.border.place-left:before{border-left:8px solid #222}.__react_component_tooltip.type-light.border.place-right:before{border-right:8px solid #222}.__react_component_tooltip.place-top{margin-top:-10px}.__react_component_tooltip.place-top:before{border-left:10px solid transparent;border-right:10px solid transparent;bottom:-8px;left:50%;margin-left:-10px}.__react_component_tooltip.place-top:after{border-left:8px solid transparent;border-right:8px solid transparent;bottom:-6px;left:50%;margin-left:-8px}.__react_component_tooltip.place-bottom{margin-top:10px}.__react_component_tooltip.place-bottom:before{border-left:10px solid transparent;border-right:10px solid transparent;top:-8px;left:50%;margin-left:-10px}.__react_component_tooltip.place-bottom:after{border-left:8px solid transparent;border-right:8px solid transparent;top:-6px;left:50%;margin-left:-8px}.__react_component_tooltip.place-left{margin-left:-10px}.__react_component_tooltip.place-left:before{border-top:6px solid transparent;border-bottom:6px solid transparent;right:-8px;top:50%;margin-top:-5px}.__react_component_tooltip.place-left:after{border-top:5px solid transparent;border-bottom:5px solid transparent;right:-6px;top:50%;margin-top:-4px}.__react_component_tooltip.place-right{margin-left:10px}.__react_component_tooltip.place-right:before{border-top:6px solid transparent;border-bottom:6px solid transparent;left:-8px;top:50%;margin-top:-5px}.__react_component_tooltip.place-right:after{border-top:5px solid transparent;border-bottom:5px solid transparent;left:-6px;top:50%;margin-top:-4px}.__react_component_tooltip .multi-line{display:block;padding:2px 0px;text-align:center}';

/***/ },
/* 807 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(808);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(672)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./TooltipStateManager.less", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./TooltipStateManager.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 808 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(671)();
	// imports


	// module
	exports.push([module.id, ".gxaDisabled {\n  display: none !important;\n}\n.gxaFadeBackgroundForOpenTooltip {\n  opacity: 0.5;\n}\n", ""]);

	// exports


/***/ },
/* 809 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(139);
	var Slider = __webpack_require__(40);
	__webpack_require__(810);
	__webpack_require__(812);
	var Button = __webpack_require__(390);
	var Glyphicon = __webpack_require__(396);

	var CoexpressionOption = React.createClass({
	    displayName: "CoexpressionOption",

	    propTypes: {
	        geneName: React.PropTypes.string.isRequired,
	        numCoexpressionsVisible: React.PropTypes.number.isRequired,
	        numCoexpressionsAvailable: React.PropTypes.number.isRequired,
	        showCoexpressionsCallback: React.PropTypes.func.isRequired
	    },
	    getInitialState: function getInitialState() {
	        return { visible: 0 };
	    },
	    _chooseValue: function _chooseValue(amount) {
	        this.setState({ visible: amount });
	        this.props.showCoexpressionsCallback(amount);
	    },

	    _turnOnWithDefaultValue: function _turnOnWithDefaultValue() {
	        this._chooseValue(10);
	    },

	    _showOfferToDisplay: function _showOfferToDisplay() {
	        return React.createElement(
	            Button,
	            { bsSize: "small", onClick: this._turnOnWithDefaultValue },
	            React.createElement(Glyphicon, { glyph: "plus" }),
	            React.createElement(
	                "span",
	                { style: { verticalAlign: "middle" } },
	                " Add similarly expressed genes"
	            )
	        );
	    },

	    _showSlider: function _showSlider() {
	        var marks = {
	            0: "off",
	            10: "10"
	        };
	        marks[this.props.numCoexpressionsAvailable] = this.props.numCoexpressionsAvailable;
	        return React.createElement(
	            "div",
	            null,
	            React.createElement(
	                "p",
	                null,
	                "Display genes with similar expressions to " + this.props.geneName + ":"
	            ),
	            React.createElement(
	                "div",
	                { className: "gxaSlider" },
	                React.createElement(Slider, { min: 0, max: this.props.numCoexpressionsAvailable, onAfterChange: this._chooseValue,
	                    marks: marks, included: false, defaultValue: 10 })
	            )
	        );
	    },

	    render: function render() {
	        return React.createElement(
	            "div",
	            { className: "gxaDisplayCoexpressionOffer" },
	            this.props.numCoexpressionsAvailable ? this.props.numCoexpressionsVisible ? this._showSlider() : this._showOfferToDisplay() : React.createElement(
	                "span",
	                null,
	                "No genes with similar expressions to " + this.props.geneName + " available for display"
	            )
	        );
	    }
	});
	module.exports = CoexpressionOption;

/***/ },
/* 810 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(811);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(672)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./CoexpressionOption.less", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./CoexpressionOption.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 811 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(671)();
	// imports


	// module
	exports.push([module.id, ".gxaDisplayCoexpressionOffer {\n  margin-top: 30px;\n}\n.gxaDisplayCoexpressionOffer .gxaSlider {\n  width: 250px;\n  margin: 15px;\n  padding-bottom: 20px;\n}\n.gxaDisplayCoexpressionOffer p {\n  font-size: 93%;\n}\n", ""]);

	// exports


/***/ },
/* 812 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(813);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(672)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./index.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./index.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 813 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(671)();
	// imports


	// module
	exports.push([module.id, ".rc-slider {\n  position: relative;\n  height: 4px;\n  width: 100%;\n  border-radius: 6px;\n  background-color: #e9e9e9;\n  box-sizing: border-box;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n.rc-slider * {\n  box-sizing: border-box;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n.rc-slider-track {\n  position: absolute;\n  left: 0;\n  height: 4px;\n  border-radius: 6px;\n  background-color: #abe2fb;\n}\n.rc-slider-handle {\n  position: absolute;\n  margin-left: -7px;\n  margin-top: -5px;\n  width: 14px;\n  height: 14px;\n  cursor: pointer;\n  border-radius: 50%;\n  border: solid 2px #96dbfa;\n  background-color: #fff;\n}\n.rc-slider-handle:hover {\n  border-color: #57c5f7;\n}\n.rc-slider-handle-active:active {\n  border-color: #57c5f7;\n  box-shadow: 0 0 5px #57c5f7;\n}\n.rc-slider-mark {\n  position: absolute;\n  top: 10px;\n  left: 0;\n  width: 100%;\n  font-size: 12px;\n}\n.rc-slider-mark-text {\n  position: absolute;\n  display: inline-block;\n  vertical-align: middle;\n  text-align: center;\n  cursor: pointer;\n  color: #999;\n}\n.rc-slider-mark-text-active {\n  color: #666;\n}\n.rc-slider-step {\n  position: absolute;\n  width: 100%;\n  height: 4px;\n  background: transparent;\n}\n.rc-slider-dot {\n  position: absolute;\n  bottom: -2px;\n  margin-left: -4px;\n  width: 8px;\n  height: 8px;\n  border: 2px solid #e9e9e9;\n  background-color: #fff;\n  cursor: pointer;\n  border-radius: 50%;\n  vertical-align: middle;\n}\n.rc-slider-dot:first-child {\n  margin-left: -4px;\n}\n.rc-slider-dot:last-child {\n  margin-left: -4px;\n}\n.rc-slider-dot-active {\n  border-color: #96dbfa;\n}\n.rc-slider-disabled {\n  background-color: #e9e9e9;\n}\n.rc-slider-disabled .rc-slider-track {\n  background-color: #ccc;\n}\n.rc-slider-disabled .rc-slider-handle,\n.rc-slider-disabled .rc-slider-dot {\n  border-color: #ccc;\n  background-color: #fff;\n  cursor: not-allowed;\n}\n.rc-slider-disabled .rc-slider-mark-text,\n.rc-slider-disabled .rc-slider-dot {\n  cursor: not-allowed !important;\n}\n.rc-slider-vertical {\n  width: 4px;\n  height: 100%;\n}\n.rc-slider-vertical .rc-slider-track {\n  bottom: 0;\n  width: 4px;\n}\n.rc-slider-vertical .rc-slider-handle {\n  position: absolute;\n  margin-left: -5px;\n  margin-bottom: -7px;\n}\n.rc-slider-vertical .rc-slider-mark {\n  top: 0;\n  left: 10px;\n  height: 100%;\n}\n.rc-slider-vertical .rc-slider-step {\n  height: 100%;\n  width: 4px;\n}\n.rc-slider-vertical .rc-slider-dot {\n  left: 2px;\n  margin-bottom: -4px;\n}\n.rc-slider-vertical .rc-slider-dot:first-child {\n  margin-bottom: -4px;\n}\n.rc-slider-vertical .rc-slider-dot:last-child {\n  margin-bottom: -4px;\n}\n.rc-slider-tooltip-zoom-down-enter,\n.rc-slider-tooltip-zoom-down-appear {\n  -webkit-animation-duration: .3s;\n          animation-duration: .3s;\n  -webkit-animation-fill-mode: both;\n          animation-fill-mode: both;\n  display: block !important;\n  -webkit-animation-play-state: paused;\n          animation-play-state: paused;\n}\n.rc-slider-tooltip-zoom-down-leave {\n  -webkit-animation-duration: .3s;\n          animation-duration: .3s;\n  -webkit-animation-fill-mode: both;\n          animation-fill-mode: both;\n  display: block !important;\n  -webkit-animation-play-state: paused;\n          animation-play-state: paused;\n}\n.rc-slider-tooltip-zoom-down-enter.rc-slider-tooltip-zoom-down-enter-active,\n.rc-slider-tooltip-zoom-down-appear.rc-slider-tooltip-zoom-down-appear-active {\n  -webkit-animation-name: rcSliderTooltipZoomDownIn;\n          animation-name: rcSliderTooltipZoomDownIn;\n  -webkit-animation-play-state: running;\n          animation-play-state: running;\n}\n.rc-slider-tooltip-zoom-down-leave.rc-slider-tooltip-zoom-down-leave-active {\n  -webkit-animation-name: rcSliderTooltipZoomDownOut;\n          animation-name: rcSliderTooltipZoomDownOut;\n  -webkit-animation-play-state: running;\n          animation-play-state: running;\n}\n.rc-slider-tooltip-zoom-down-enter,\n.rc-slider-tooltip-zoom-down-appear {\n  -webkit-transform: scale(0, 0);\n          transform: scale(0, 0);\n  -webkit-animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n          animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\n}\n.rc-slider-tooltip-zoom-down-leave {\n  -webkit-animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n          animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n}\n@-webkit-keyframes rcSliderTooltipZoomDownIn {\n  0% {\n    opacity: 0;\n    -webkit-transform-origin: 50% 100%;\n            transform-origin: 50% 100%;\n    -webkit-transform: scale(0, 0);\n            transform: scale(0, 0);\n  }\n  100% {\n    -webkit-transform-origin: 50% 100%;\n            transform-origin: 50% 100%;\n    -webkit-transform: scale(1, 1);\n            transform: scale(1, 1);\n  }\n}\n@keyframes rcSliderTooltipZoomDownIn {\n  0% {\n    opacity: 0;\n    -webkit-transform-origin: 50% 100%;\n            transform-origin: 50% 100%;\n    -webkit-transform: scale(0, 0);\n            transform: scale(0, 0);\n  }\n  100% {\n    -webkit-transform-origin: 50% 100%;\n            transform-origin: 50% 100%;\n    -webkit-transform: scale(1, 1);\n            transform: scale(1, 1);\n  }\n}\n@-webkit-keyframes rcSliderTooltipZoomDownOut {\n  0% {\n    -webkit-transform-origin: 50% 100%;\n            transform-origin: 50% 100%;\n    -webkit-transform: scale(1, 1);\n            transform: scale(1, 1);\n  }\n  100% {\n    opacity: 0;\n    -webkit-transform-origin: 50% 100%;\n            transform-origin: 50% 100%;\n    -webkit-transform: scale(0, 0);\n            transform: scale(0, 0);\n  }\n}\n@keyframes rcSliderTooltipZoomDownOut {\n  0% {\n    -webkit-transform-origin: 50% 100%;\n            transform-origin: 50% 100%;\n    -webkit-transform: scale(1, 1);\n            transform: scale(1, 1);\n  }\n  100% {\n    opacity: 0;\n    -webkit-transform-origin: 50% 100%;\n            transform-origin: 50% 100%;\n    -webkit-transform: scale(0, 0);\n            transform: scale(0, 0);\n  }\n}\n.rc-tooltip {\n  position: absolute;\n  left: -9999px;\n  top: -9999px;\n  visibility: visible;\n  box-sizing: border-box;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n.rc-tooltip * {\n  box-sizing: border-box;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n.rc-tooltip-hidden {\n  display: none;\n}\n.rc-tooltip-placement-top {\n  padding: 4px 0 8px 0;\n}\n.rc-tooltip-inner {\n  padding: 6px 2px;\n  min-width: 24px;\n  height: 24px;\n  font-size: 12px;\n  line-height: 1;\n  color: #fff;\n  text-align: center;\n  text-decoration: none;\n  background-color: #6c6c6c;\n  border-radius: 6px;\n  box-shadow: 0 0 4px #d9d9d9;\n}\n.rc-tooltip-arrow {\n  position: absolute;\n  width: 0;\n  height: 0;\n  border-color: transparent;\n  border-style: solid;\n}\n.rc-tooltip-placement-top .rc-tooltip-arrow {\n  bottom: 4px;\n  left: 50%;\n  margin-left: -4px;\n  border-width: 4px 4px 0;\n  border-top-color: #6c6c6c;\n}\n", ""]);

	// exports


/***/ },
/* 814 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(815);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(672)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./SeriesLegend.less", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./SeriesLegend.less");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 815 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(671)();
	// imports


	// module
	exports.push([module.id, ".gxaHeatmapLegend {\n  color: #606060;\n  margin-left: 180px;\n  border: 0 solid olive;\n}\n.gxaHeatmapLegend .legend-item {\n  display: inline-block;\n  margin-left: 8px;\n  padding: 4px;\n  vertical-align: middle;\n  cursor: default;\n}\n.gxaHeatmapLegend .legend-item.legend-item-off {\n  color: #ccc;\n}\n.gxaHeatmapLegend .legend-item.legend-item-off div {\n  background-color: #f7f7f7;\n}\n.gxaHeatmapLegend .legend-item .legend-rectangle {\n  width: 12px;\n  height: 12px;\n  border: 1px rgba(0, 0, 0, 0.2) solid;\n  display: inline-block;\n  margin-right: 4px;\n  vertical-align: middle;\n}\n.gxaHeatmapLegend .legend-item .icon-generic:before {\n  font-size: 180%;\n  color: #7e7e7e;\n}\n.gxaHeatmapLegend .legend-item:hover .icon-generic:before {\n  color: #353535;\n}\n@font-face {\n  font-family: 'EBI-Generic';\n  src: url('https://www.ebi.ac.uk/web_guidelines/fonts/EBI-Generic/fonts/EBI-Generic.eot');\n  src: url('https://www.ebi.ac.uk/web_guidelines/fonts/EBI-Generic/fonts/EBI-Generic.eot?#iefix') format('embedded-opentype'), url('https://www.ebi.ac.uk/web_guidelines/fonts/EBI-Generic/fonts/EBI-Generic.woff') format('woff'), local('\\263A'), url('https://www.ebi.ac.uk/web_guidelines/fonts/EBI-Generic/fonts/EBI-Generic.svg#EBI-Generic') format('svg'), url('https://www.ebi.ac.uk/web_guidelines/fonts/EBI-Generic/fonts/EBI-Generic.ttf') format('truetype');\n  font-weight: normal;\n  font-style: normal;\n}\n.icon-generic:before {\n  font-family: 'EBI-Generic';\n  font-size: 100%;\n  color: #BBB;\n  content: attr(data-icon);\n  margin: 0 0 0 0;\n}\n", ""]);

	// exports


/***/ },
/* 816 */
/***/ function(module, exports) {

	"use strict";

	//*------------------------------------------------------------------*

	/*
	All functions in this module accept and return a following format of data:
	{
	  dataSeries : [info: {...: String}, data: [Point]}]
	  xAxisCategories: [X axis label]
	  yAxisCategories: [Y axis label]
	}
	*/

	//*------------------------------------------------------------------*

	var orderHeatmapData = function orderHeatmapData(ordering, data) {
	  var permuteX = function permuteX(x) {
	    return ordering.columns.indexOf(x);
	  };

	  var permuteY = function permuteY(y) {
	    return ordering.rows.indexOf(y);
	  };

	  var permutePoint = function permutePoint(point) {
	    return {
	      x: permuteX(point.x),
	      y: permuteY(point.y),
	      value: point.value,
	      info: point.info
	    };
	  };

	  var permuteArray = function permuteArray(arr, permute) {
	    return arr.map(function (el, ix) {
	      return [el, permute(ix)];
	    }).sort(function (l, r) {
	      return l[1] - r[1];
	    }).map(function (el) {
	      return el[0];
	    });
	  };

	  return {
	    dataSeries: data.dataSeries.map(function (series) {
	      return {
	        info: series.info,
	        data: series.data.map(permutePoint)
	      };
	    }),
	    xAxisCategories: permuteArray(data.xAxisCategories, permuteX),
	    yAxisCategories: permuteArray(data.yAxisCategories, permuteY)
	  };
	};

	var _axisElementsForFilteredDataSeries = function _axisElementsForFilteredDataSeries(axis, conditionPerSeries, conditionPerPoint, dataSeries) {
	  return dataSeries.filter(conditionPerSeries).map(function (e) {
	    return e.data;
	  }).reduce(function (l, r) {
	    return l.concat(r);
	  }, []).filter(conditionPerPoint).map(function (e) {
	    return e[axis];
	  }).filter(function (e, ix, self) {
	    return self.indexOf(e) === ix;
	  }).sort(function (l, r) {
	    return l - r;
	  });
	};

	var _filterHeatmapData = function _filterHeatmapData(keepSeries, keepPoint, data) {
	  var allXs = _axisElementsForFilteredDataSeries("x", keepSeries, keepPoint, data.dataSeries);
	  var allYs = _axisElementsForFilteredDataSeries("y", keepSeries, keepPoint, data.dataSeries);

	  var newDataSeries = data.dataSeries.map(function (series, ix) {
	    return keepSeries(series, ix) ? series.data.filter(keepPoint) : [];
	  }).map(function (series) {
	    return series.map(function (point) {
	      return {
	        x: allXs.indexOf(point.x),
	        y: allYs.indexOf(point.y),
	        value: point.value,
	        info: point.info
	      };
	    }).filter(function (point) {
	      return point.x > -1 && point.y > -1;
	    });
	  });

	  return {
	    dataSeries: data.dataSeries.map(function (e, ix) {
	      return {
	        info: e.info,
	        data: newDataSeries[ix]
	      };
	    }),
	    xAxisCategories: data.xAxisCategories.filter(function (e, ix) {
	      return allXs.indexOf(ix) > -1;
	    }),
	    yAxisCategories: data.yAxisCategories.filter(function (e, ix) {
	      return allYs.indexOf(ix) > -1;
	    })
	  };
	};

	var filterHeatmapData = function filterHeatmapData(keepSeries, keepRow, keepColumn, data) {
	  return _filterHeatmapData(keepSeries, function (point) {
	    return keepRow(data.yAxisCategories[point.y]) && keepColumn(data.xAxisCategories[point.x]);
	  }, data);
	};

	var _calculateInserts = function _calculateInserts(fullColumns, originalColumns) {
	  var result = [];
	  var fullColumnsCursor = 0;
	  var originalColumnsCursor = 0;
	  while (fullColumnsCursor < fullColumns.length && originalColumnsCursor < originalColumns.length) {
	    if (fullColumns.length > fullColumnsCursor && originalColumns.length > originalColumnsCursor && fullColumns[fullColumnsCursor] == originalColumns[originalColumnsCursor]) {
	      result.push("");
	      fullColumnsCursor++;
	      originalColumnsCursor++;
	    } else if (fullColumns.length > fullColumnsCursor) {
	      result.push(fullColumns[fullColumnsCursor]);
	      fullColumnsCursor++;
	    } else if (originalColumns[originalColumnsCursor].length > originalColumnsCursor) {
	      result.push("");
	      originalColumnsCursor++;
	    }
	  }
	  return result;
	};

	var _indicesForInserts = function _indicesForInserts(inserts) {
	  var i = -1;
	  return inserts.map(function (e) {
	    !e && i++;
	    return i;
	  });
	};

	var insertEmptyColumns = function insertEmptyColumns(newColumns, data) {
	  var fullColumns = newColumns.concat(data.xAxisCategories.filter(function (originalColumn) {
	    return newColumns.findIndex(function (e) {
	      return e.label == originalColumn.label;
	    }) == -1;
	  }));
	  var insertIndices = _indicesForInserts(_calculateInserts(fullColumns.map(function (e) {
	    return e.label;
	  }), data.xAxisCategories.map(function (e) {
	    return e.label;
	  })));
	  return {
	    dataSeries: data.dataSeries.map(function (e) {
	      return {
	        info: e.info,
	        data: e.data.map(function (point) {
	          return Object.assign({}, point, { x: insertIndices.indexOf(point.x)
	          });
	        })
	      };
	    }),
	    xAxisCategories: fullColumns,
	    yAxisCategories: data.yAxisCategories
	  };
	};

	exports.insertEmptyColumns = insertEmptyColumns;
	exports.filterHeatmapData = filterHeatmapData;
	exports.order = orderHeatmapData;

	exports.manipulate = function (args, data) {
	  return insertEmptyColumns(args.allowEmptyColumns ? orderHeatmapData(args.ordering, data).xAxisCategories : [], filterHeatmapData(args.keepSeries, args.keepRow, args.keepColumn, orderHeatmapData(args.ordering, data)));
	};

/***/ },
/* 817 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(818);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(672)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../node_modules/css-loader/index.js!./HighchartsHeatmapContainer.css", function() {
				var newContent = require("!!./../node_modules/css-loader/index.js!./HighchartsHeatmapContainer.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 818 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(671)();
	// imports


	// module
	exports.push([module.id, ".gxaInnerHeatmap {\n    position: relative;\n    overflow: hidden;\n}\n\n.gxaAside {\n    float: left;\n}\n\n.gxaInnerHeatmap:after {\n    clear: both;\n    content: \".\";\n    display: block;\n    visibility: hidden;\n}\n", ""]);

	// exports


/***/ }
]);